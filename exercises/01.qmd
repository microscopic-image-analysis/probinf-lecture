---
jupyter: python3
title: Exercise 1
---

# Problem 1: Floating point random numbers

Random number generators are designed to deliver a stream of completely random bits, meaning each bit has probability 1/2 of being 1 (or 0), and the random values for different bits are __independent__.

Assume you've got such a source of random bits. If you take a chunk of 16 bits and interpret this as a ([IEEE-754](https://en.wikipedia.org/wiki/Floating-point_arithmetic#IEEE_754:_floating_point_in_modern_computers)) half-precision floating point number, you will get a random floating point number $x \in I$ in the interval $I = [-65500, 65500]$.

```{python}
import numpy as np

np.finfo(np.float16)
```

## a)
Are the random floating point numbers distributed uniformly in $I$?

* Think about it
* Then, generate many floating point numbers in this way, and visualize their empirical distribution via a [Histogram](https://en.wikipedia.org/wiki/Histogram) of the values
    * Hint: If you've thought about the bit representation of IEEE-754 floating points, you've figured there are some special values like `NaN` or `Â±Inf`. Drop such values before creating the histogram
    * Hint2: If you inted to use `matplotlib`'s `hist()` function, be aware that it doesn't like 16-bit floats. Convert the values to 32-bit (or 64-bit) floats before calling `hist()`.


## b)

(Pseudo-) random number libraries usually offer random floating point numbers from the interval $[0, 1)$.

* Sample random floating point numbers in the $[0, 1)$ interval and print their bit representation. What do you observe?
* How can we change our procedure in order to get uniformly distributed floating point numbers from our random bit stream?

# Problem 2: Sampling from a discrete model

Assume now that you have access to a function that samples uniform random numbers from the Interval $[0, 1)$.

Revisit the initial example from the first half of the lecture, which specified the following probability table $p(A, B, C)$:

![Probability table](images/ProbabilityTable.png)

```{python}
p = np.array([21, 8, 7, 8, 3, 24, 1, 24]) / 96

v = np.array([[1,1,1], [1,1,0], [1,0,1], [1,0,0], [0,1,1], [0,1,0], [0,0,1], [0,0,0]])
```


* Write a function that draws samples from that probability distribution
* Use the samples to create a histogram of $p(A | C = 1)$

# Problem 3: Quadrature vs Monte Carlo integration

Using Python, evaluate the integral $\int_0^1 \sin^2(1/x) dx$ by both, a deterministic approach such as quadrature (see `scipy.integrate`) and a Monte Carlo method.
