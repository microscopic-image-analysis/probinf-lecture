<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.313">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>lecture</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="lecture_files/libs/clipboard/clipboard.min.js"></script>
<script src="lecture_files/libs/quarto-html/quarto.js"></script>
<script src="lecture_files/libs/quarto-html/popper.min.js"></script>
<script src="lecture_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="lecture_files/libs/quarto-html/anchor.min.js"></script>
<link href="lecture_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="lecture_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="lecture_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="lecture_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="lecture_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#inference-in-probabilistic-models---sampling-methods" id="toc-inference-in-probabilistic-models---sampling-methods" class="nav-link active" data-scroll-target="#inference-in-probabilistic-models---sampling-methods">Inference in Probabilistic Models - Sampling Methods</a></li>
  <li><a href="#literature" id="toc-literature" class="nav-link" data-scroll-target="#literature">Literature</a></li>
  <li><a href="#lecture-1-introduction-1" id="toc-lecture-1-introduction-1" class="nav-link" data-scroll-target="#lecture-1-introduction-1">Lecture 1: Introduction</a></li>
  <li><a href="#lecture-2-direct-sampling-methods-1" id="toc-lecture-2-direct-sampling-methods-1" class="nav-link" data-scroll-target="#lecture-2-direct-sampling-methods-1">Lecture 2: Direct Sampling Methods</a></li>
  <li><a href="#lecture-3-rejection-and-importance-sampling-1" id="toc-lecture-3-rejection-and-importance-sampling-1" class="nav-link" data-scroll-target="#lecture-3-rejection-and-importance-sampling-1">Lecture 3: Rejection and Importance Sampling</a></li>
  <li><a href="#lecture-4-markov-chain-monte-carlo" id="toc-lecture-4-markov-chain-monte-carlo" class="nav-link" data-scroll-target="#lecture-4-markov-chain-monte-carlo">Lecture 4: Markov chain Monte Carlo</a></li>
  <li><a href="#lecture-5-the-metropolis-hastings-algorithm-1" id="toc-lecture-5-the-metropolis-hastings-algorithm-1" class="nav-link" data-scroll-target="#lecture-5-the-metropolis-hastings-algorithm-1">Lecture 5: The Metropolis-Hastings algorithm</a></li>
  <li><a href="#lecture-6-gibbs-sampling-1" id="toc-lecture-6-gibbs-sampling-1" class="nav-link" data-scroll-target="#lecture-6-gibbs-sampling-1">Lecture 6: Gibbs sampling</a></li>
  <li><a href="#lecture-7-hamiltonian-monte-carlo-1" id="toc-lecture-7-hamiltonian-monte-carlo-1" class="nav-link" data-scroll-target="#lecture-7-hamiltonian-monte-carlo-1">Lecture 7: Hamiltonian Monte Carlo</a></li>
  <li><a href="#lecture-8-hamiltonian-monte-carlo-practical-issues-1" id="toc-lecture-8-hamiltonian-monte-carlo-practical-issues-1" class="nav-link" data-scroll-target="#lecture-8-hamiltonian-monte-carlo-practical-issues-1">Lecture 8: Hamiltonian Monte Carlo, Practical Issues</a></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">



<section id="inference-in-probabilistic-models---sampling-methods" class="level1">
<h1>Inference in Probabilistic Models - Sampling Methods</h1>
<p>Michael Habeck - Jena University Hospital - michael.habeck@uni-jena.de</p>
<p>Wolfhart Feldmeier - Jena University Hospital - wolfhart.feldmeier@uni-jena.de</p>
<section id="dates-and-course-organization" class="level2">
<h2 class="anchored" data-anchor-id="dates-and-course-organization">Dates and course organization</h2>
<ul>
<li><p>Six weeks, two 2-hour lectures plus one 2-hour exercises session per week</p></li>
<li><p>Lectures on Monday and Friday, exercises on Wednesday</p></li>
<li><p>Timetable</p></li>
</ul>
<table class="table">
<colgroup>
<col style="width: 13%">
<col style="width: 16%">
<col style="width: 10%">
<col style="width: 17%">
<col style="width: 41%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Lecture</th>
<th style="text-align: center;">Date</th>
<th style="text-align: center;">Weekday</th>
<th>Time</th>
<th style="text-align: left;">Topic</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">Dec 16, 2022</td>
<td style="text-align: center;">Fri</td>
<td>10:15 - 11:45</td>
<td style="text-align: left;">Introduction</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">Jan 02, 2023</td>
<td style="text-align: center;">Mon</td>
<td>10:15 - 11:45</td>
<td style="text-align: left;">Direct Sampling Methods</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Ex 1</td>
<td style="text-align: center;">Jan 04, 2023</td>
<td style="text-align: center;">Wed</td>
<td>10:15 - 11:45</td>
<td style="text-align: left;">Exercises for lectures 1-2</td>
</tr>
<tr class="even">
<td style="text-align: center;">3</td>
<td style="text-align: center;">Jan 06, 2023</td>
<td style="text-align: center;">Fri</td>
<td>10:15 - 11:45</td>
<td style="text-align: left;">Rejection &amp; Importance Sampling</td>
</tr>
<tr class="odd">
<td style="text-align: center;">4</td>
<td style="text-align: center;">Jan 09, 2023</td>
<td style="text-align: center;">Mon</td>
<td>10:15 - 11:45</td>
<td style="text-align: left;">Markov chains, MCMC</td>
</tr>
<tr class="even">
<td style="text-align: center;">Ex 2</td>
<td style="text-align: center;">Jan 11, 2023</td>
<td style="text-align: center;">Wed</td>
<td>10:15 - 11:45</td>
<td style="text-align: left;">Exercises for lectures 3-4</td>
</tr>
<tr class="odd">
<td style="text-align: center;">5</td>
<td style="text-align: center;">Jan 13, 2023</td>
<td style="text-align: center;">Fri</td>
<td>10:15 - 11:45</td>
<td style="text-align: left;">The Metropolis-Hastings algorithm</td>
</tr>
<tr class="even">
<td style="text-align: center;">6</td>
<td style="text-align: center;">Jan 16, 2023</td>
<td style="text-align: center;">Mon</td>
<td>10:15 - 11:45</td>
<td style="text-align: left;">Gibbs sampling</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Ex 3</td>
<td style="text-align: center;">Jan 18, 2023</td>
<td style="text-align: center;">Wed</td>
<td>10:15 - 11:45</td>
<td style="text-align: left;">Exercises for lectures 5-6</td>
</tr>
<tr class="even">
<td style="text-align: center;">7</td>
<td style="text-align: center;">Jan 20, 2023</td>
<td style="text-align: center;">Fri</td>
<td>10:15 - 11:45</td>
<td style="text-align: left;">Hamiltonian Monte Carlo</td>
</tr>
<tr class="odd">
<td style="text-align: center;">8</td>
<td style="text-align: center;">Jan 23, 2023</td>
<td style="text-align: center;">Mon</td>
<td>10:15 - 11:45</td>
<td style="text-align: left;">Practical aspects of HMC</td>
</tr>
<tr class="even">
<td style="text-align: center;">Ex 4</td>
<td style="text-align: center;">Jan 25, 2023</td>
<td style="text-align: center;">Wed</td>
<td>10:15 - 11:45</td>
<td style="text-align: left;">Exercises for lectures 7-8</td>
</tr>
<tr class="odd">
<td style="text-align: center;">9</td>
<td style="text-align: center;">Jan 27, 2023</td>
<td style="text-align: center;">Fri</td>
<td>10:15 - 11:45</td>
<td style="text-align: left;">Slice sampling</td>
</tr>
<tr class="even">
<td style="text-align: center;">10</td>
<td style="text-align: center;">Jan 30, 2023</td>
<td style="text-align: center;">Mon</td>
<td>10:15 - 11:45</td>
<td style="text-align: left;">Practical aspects, Diagnostics</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Ex 5</td>
<td style="text-align: center;">Feb 01, 2023</td>
<td style="text-align: center;">Wed</td>
<td>10:15 - 11:45</td>
<td style="text-align: left;">Exercises for lectures 9-10</td>
</tr>
<tr class="even">
<td style="text-align: center;">11</td>
<td style="text-align: center;">Feb 03, 2023</td>
<td style="text-align: center;">Fri</td>
<td>10:15 - 11:45</td>
<td style="text-align: left;">TBA</td>
</tr>
<tr class="odd">
<td style="text-align: center;">12</td>
<td style="text-align: center;">Feb 06, 2023</td>
<td style="text-align: center;">Mon</td>
<td>10:15 - 11:45</td>
<td style="text-align: left;">TBA</td>
</tr>
<tr class="even">
<td style="text-align: center;">Ex 6</td>
<td style="text-align: center;">Feb 08, 2023</td>
<td style="text-align: center;">Wed</td>
<td>10:15 - 11:45</td>
<td style="text-align: left;">Exercises for lectures 11-12</td>
</tr>
<tr class="odd">
<td style="text-align: center;">13</td>
<td style="text-align: center;">Feb 10, 2023</td>
<td style="text-align: center;">Fri</td>
<td>10:15 - 11:45</td>
<td style="text-align: left;">TBA</td>
</tr>
</tbody>
</table>
</section>
<section id="topics" class="level2">
<h2 class="anchored" data-anchor-id="topics">Topics</h2>
<section id="lecture-1-introduction" class="level3">
<h3 class="anchored" data-anchor-id="lecture-1-introduction">Lecture 1: Introduction</h3>
<ul>
<li>Motivation</li>
<li>Monte Carlo approximation</li>
<li>An inefficient way of computing <span class="math inline">\(\pi\)</span></li>
</ul>
</section>
<section id="lecture-2-direct-sampling-methods" class="level3">
<h3 class="anchored" data-anchor-id="lecture-2-direct-sampling-methods">Lecture 2: Direct Sampling Methods</h3>
<ul>
<li>Can we beat the curse of dimensionality?</li>
<li>Random number generation</li>
<li>Direct sampling by variable transformation methods</li>
</ul>
</section>
<section id="lecture-3-rejection-and-importance-sampling" class="level3">
<h3 class="anchored" data-anchor-id="lecture-3-rejection-and-importance-sampling">Lecture 3: Rejection and Importance Sampling</h3>
<ul>
<li>More direct sampling methods</li>
<li>Rejection sampling</li>
<li>Importance sampling</li>
</ul>
</section>
<section id="lecture-4-markov-chains" class="level3">
<h3 class="anchored" data-anchor-id="lecture-4-markov-chains">Lecture 4: Markov chains</h3>
<ul>
<li>Markov chains</li>
<li>Some mathematical facts about Markov chains</li>
</ul>
</section>
<section id="lecture-5-the-metropolis-hastings-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="lecture-5-the-metropolis-hastings-algorithm">Lecture 5: The Metropolis-Hastings Algorithm</h3>
<ul>
<li>Fundamental theorem of Markov chains</li>
<li>Metropolis-Hastings algorithm</li>
</ul>
</section>
<section id="lecture-6-gibbs-sampling" class="level3">
<h3 class="anchored" data-anchor-id="lecture-6-gibbs-sampling">Lecture 6: Gibbs sampling</h3>
<ul>
<li>Recap: Metropolis-Hastings algorithm</li>
<li>Combining Markov chains</li>
<li>Gibbs sampling</li>
<li>Auxiliary variable methods</li>
</ul>
</section>
<section id="lecture-7-hamiltonian-monte-carlo" class="level3">
<h3 class="anchored" data-anchor-id="lecture-7-hamiltonian-monte-carlo">Lecture 7: Hamiltonian Monte Carlo</h3>
<ul>
<li>Recap: MCMC + Gibbs Sampling</li>
<li>More on auxiliary variable methods</li>
<li>Hamiltonian Monte Carlo</li>
</ul>
</section>
<section id="lecture-8-hamiltonian-monte-carlo-practical-issues" class="level3">
<h3 class="anchored" data-anchor-id="lecture-8-hamiltonian-monte-carlo-practical-issues">Lecture 8: Hamiltonian Monte Carlo, Practical Issues</h3>
<ul>
<li>Hamiltonian Monte Carlo continued</li>
<li>Practical Issues (convergence, diagnostic checks)</li>
</ul>
</section>
<section id="lecture-9-slice-sampling" class="level3">
<h3 class="anchored" data-anchor-id="lecture-9-slice-sampling">Lecture 9: Slice sampling</h3>
<ul>
<li>General slice sampling</li>
<li>Neal’s bracketing method</li>
</ul>
<section id="lecture-10-practical-aspects-of-mcmc" class="level4">
<h4 class="anchored" data-anchor-id="lecture-10-practical-aspects-of-mcmc">Lecture 10: Practical Aspects of MCMC</h4>
<ul>
<li>Convergence, diagnostic checks</li>
</ul>
</section>
</section>
<section id="lectures-11-13-tba" class="level3">
<h3 class="anchored" data-anchor-id="lectures-11-13-tba">Lectures 11-13: TBA</h3>
<section id="possible-topics" class="level4">
<h4 class="anchored" data-anchor-id="possible-topics">Possible topics</h4>
<ul>
<li>Annealed Importance Sampling</li>
<li>Nested Sampling</li>
<li>Parallel Tempering / Replica-exchange Monte Carlo</li>
<li>Sequential Monte Carlo (SMC)</li>
<li>Graphical models</li>
<li>Ising model</li>
<li>Simulator models</li>
<li>Stochastic differential equation &amp; Langevin dynamics</li>
<li>Bridge sampling, thermodynamic integration</li>
<li>Partition function estimation</li>
<li>Intractable models</li>
<li>Exchange algorithm</li>
<li>Adaptive Monte Carlo methods</li>
<li>Wang-Landau</li>
<li>Exact sampling: coupling from the past</li>
</ul>
</section>
</section>
</section>
</section>
<section id="literature" class="level1">
<h1>Literature</h1>
<ul>
<li><p>Matti Vihola: <a href="http://users.jyu.fi/~mvihola/stochsim/notes-2020.pdf">Lectures on Stochastic Simulation</a></p></li>
<li><p>Radford Neal: <a href="https://www.cs.toronto.edu/~radford/ftp/review.pdf">Probabilistic Inference Using Markov Chain Monte Carlo Methods</a></p></li>
<li><p>Chris Bishop: <a href="https://www.springer.com/gp/book/9780387310732">Pattern Recognition and Machine Learning, Chap. 11</a></p></li>
<li><p>David MacKay: <a href="http://www.inference.org.uk/itprnn/book.pdf">Information Theory, Inference, and Learning Algorithms, Chap. 29 + 30</a></p></li>
<li><p>Iain Murray: <a href="http://homepages.inf.ed.ac.uk/imurray2/pub/07thesis/murray_thesis_2007.pdf">Advances in Markov chain Monte Carlo methods</a></p></li>
<li><p>Andrieu, de Freitas, Doucet, Jordan: <a href="https://link.springer.com/article/10.1023/A:1020281327116">An Introduction to MCMC for Machine Learning</a></p></li>
<li><p>Charles Geyer: <a href="http://si.biostat.washington.edu/sites/default/files/modules/Geyer-Introduction%20to%20markov%20chain%20Monte%20Carlo_0.pdf">Introduction to Markov Chain Monte Carlo</a></p></li>
<li><p>Jun S. Liu: <a href="https://www.springer.com/de/book/9780387763699">Monte Carlo Strategies in Scientific Computing</a></p></li>
<li><p>David A Levin, Yuval Peres: <a href="https://www.academia.edu/download/30694248/recent.pdf">Markov chains and mixing times</a></p></li>
</ul>
</section>
<section id="lecture-1-introduction-1" class="level1">
<h1>Lecture 1: Introduction</h1>
<section id="outline" class="level2">
<h2 class="anchored" data-anchor-id="outline">Outline</h2>
<ul>
<li>Motivation</li>
<li>Monte Carlo approximation</li>
<li>An inefficient way of computing <span class="math inline">\(\pi\)</span></li>
</ul>
</section>
<section id="why-do-we-need-sampling-methods" class="level2">
<h2 class="anchored" data-anchor-id="why-do-we-need-sampling-methods">Why do we need sampling methods?</h2>
<section id="solving-inference-problems" class="level3">
<h3 class="anchored" data-anchor-id="solving-inference-problems">Solving inference problems</h3>
<p>A major motivation is to use sampling methods for doing Bayesian inference and more generally for solving inference in probabilistic models. But sampling methods are also very important in many other domains such as Physics, Chemistry etc. Monte Carlo techniques are also essential in machine learning.</p>
<p>Being good Bayesians we are interested in the following computational tasks</p>
<ol type="1">
<li><p><strong>Marginalization</strong>: Integrating or summing out uninteresting parameters in a probabilistic model</p></li>
<li><p><strong>Conditioning</strong>: Fixing some variables and evaluating probabilities conditioned on the fixed variables. For example, conditioning on the observed data in order to compute the posterior probability</p></li>
<li><p><strong>Expectation</strong>: Computing the mean value of some function (e.g.&nbsp;computation of the <em>model evidence</em>)</p></li>
</ol>
</section>
<section id="bayesian-inference" class="level3">
<h3 class="anchored" data-anchor-id="bayesian-inference">Bayesian inference</h3>
<p>At its most fundamental level, <a href="https://en.wikipedia.org/wiki/Bayesian_inference">Bayesian inference</a> involves applying the sum and product rule of probability theory to learn a model from some information:</p>
<p><span id="eq-bayes"><span class="math display">\[
    \underbrace{\Pr(\theta\mid D, M)}_{Posterior}\,\, \underbrace{\Pr(D\mid M)}_{Evidence} = \underbrace{\Pr(D\mid \theta, M)}_{Likelihood}\,\, \underbrace{\Pr(\theta\mid M)}_{Prior}
\tag{1}\]</span></span></p>
<p>where <span class="math inline">\(D\)</span> are the data, <span class="math inline">\(M\)</span> is a model with parameters <span class="math inline">\(\theta\)</span>.</p>
<p>There are two main tasks in Bayesian inference:</p>
<ol type="1">
<li><p>estimation of the model parameters <span class="math inline">\(\theta\)</span>,</p></li>
<li><p>comparison of model <span class="math inline">\(M\)</span> to alternative model <span class="math inline">\(M'\)</span>.</p></li>
</ol>
<p>First task requires computations with the (unnormalized) posterior <span class="math inline">\(\Pr(\theta\mid{}D,M)\)</span> or <span class="math inline">\(\Pr(D\mid{}\theta,M)\,\Pr(\theta\mid{}M)\)</span>. The second task involves computation of the model evidence:</p>
<p><span id="eq-evidence"><span class="math display">\[
    \Pr(D\mid{}M) = \int \Pr(D\mid{}\theta, M)\, \Pr(\theta\mid{}M)\, d\theta
\tag{2}\]</span></span></p>
<p>Other important integrals that need to be computed in Bayesian analysis are:</p>
<ul>
<li><p>Marginal posterior: <span class="math display">\[
\Pr(\theta_1\mid{}D,M) = \int \Pr(\theta_1, \theta_2\mid{}D, M)\, d{\theta_2}
\]</span></p></li>
<li><p>Getting rid of <a href="https://en.wikipedia.org/wiki/Nuisance_parameter">nuisance parameters</a>: <span class="math display">\[
\Pr(D\mid{}\theta_1, M) = \int \Pr(D, \theta_2 \mid{} \theta_1, M) \, d{\theta_2}
\]</span></p></li>
<li><p>Getting rid of <a href="https://en.wikipedia.org/wiki/Hyperparameter">hyperparameters</a>: <span class="math display">\[
\Pr(\theta\mid{}D, M) \propto \int \Pr(D\mid{}\theta, M)\, \Pr(\theta\mid{}\alpha, M)\, \Pr(\alpha\mid{}M)\, d{\alpha}
\]</span></p></li>
<li><p>Evaluation of predictive distributions: <span class="math display">\[
\Pr(y\mid{}D,M) = \int \Pr(y\mid{}\theta, M)\, \Pr(\theta \mid{} D, M)\, d{\theta}
\]</span></p></li>
</ul>
</section>
<section id="use-of-monte-carlo-methods-in-machine-learning" class="level3">
<h3 class="anchored" data-anchor-id="use-of-monte-carlo-methods-in-machine-learning">Use of Monte Carlo methods in machine learning</h3>
<p>Monte Carlo methods are also crucial in machine learning. A straightforward application is relevant to supervised learning with large datasets. Assume that the risk functional, which we minimize to train a model <span class="math inline">\(f(x)\)</span>, is</p>
<p><span class="math display">\[
R(f) = \sum_{n=1}^N \ell(y_n, f(x_n))
\]</span></p>
<p>where <span class="math inline">\(\ell(\cdot, \cdot)\)</span> is a loss function that assesses the discrepancy between the observation <span class="math inline">\(y_n\)</span> and the prediction <span class="math inline">\(f(x_n)\)</span> based on a (non-parametric) model <span class="math inline">\(f(x)\)</span>. For large <span class="math inline">\(N\)</span>, evaluation of <span class="math inline">\(R(f)\)</span> can be very costly. A simple strategy to overcome this problem is to train a surrogate of the risk obtained by <em>randomly</em> selecting a small subset from the data, a <em>mini-batch</em> <span class="math inline">\(B\)</span>, and use</p>
<p><span class="math display">\[
\hat R_B(f) = \frac{N}{|B|} \sum_{n\in B} \ell(y_n, f(x_n))
\]</span></p>
<p>as a cost function for training <span class="math inline">\(f(x)\)</span>. <a href="https://en.wikipedia.org/wiki/Stochastic_gradient_descent">Stochastic gradient descent</a> follows the gradient of the surrogate rather than the full empirical risk, for example, when training deep neural nets.</p>
<p>Another application is learning of <em>intractable models</em> in representation learning (unsupervised learning). Many important models such as <a href="https://en.wikipedia.org/wiki/Boltzmann_machine">Boltzmann machines</a> or <a href="https://en.wikipedia.org/wiki/Restricted_Boltzmann_machine">restrictive Boltzmann machines</a> are members of the exponential family involving a vector of features <span class="math inline">\(f(y)\)</span>:</p>
<p><span class="math display">\[
\Pr(y\mid{}\theta) = \frac{1}{Z(\theta)} \exp\bigl\{\theta^T\!\!f(y)\bigr\}\,\,\,\text{with}\,\,\, Z(\theta) = \int \exp\bigl\{\theta^T\!\!f(y)\bigr\} dy.
\]</span></p>
<p>The normalizing constant <span class="math inline">\(Z(\theta)\)</span> is called the <em>partition function</em> (by borrowing the terminology from <a href="https://en.wikipedia.org/wiki/Partition_function_(statistical_mechanics)">Statistical Physics</a>). <span class="math inline">\(Z(\theta)\)</span> is often <em>intractable</em>, meaning that we don’t have a closed form expression for evaluating <span class="math inline">\(Z(\theta)\)</span>. Computation of <span class="math inline">\(Z(\theta)\)</span> is formally analogous to computing the model evidence in Bayesian inference.</p>
<p>The log likelihood of observing <span class="math inline">\(y\)</span> is</p>
<p><span class="math display">\[
\log \Pr(y\mid{}\theta) = \theta^T\!\!f(y) - \log Z(\theta)
\]</span></p>
<p>and maximized by following its gradient</p>
<p><span class="math display">\[
\nabla_\theta \log \Pr(y\mid{}\theta) = f(y) - \mathbb E_{\Pr(y\mid{}\theta)}[f]\,\,\,\text{where}\,\,\,\mathbb E_{\Pr(y\mid{}\theta)}[f] = \int f(y) \Pr(y\mid{}\theta)\, dy = \sum_{y \in \mathcal X} f(y)\, \Pr(y \mid{} \theta)
\]</span></p>
<p>If computation of <span class="math inline">\(Z(\theta)\)</span> is challenging, then also the expectation of the features <span class="math inline">\(\mathbb E[f]\)</span> is oftentimes not available in analytically closed form. In this case, one often resorts to a Monte Carlo approximation of <span class="math inline">\(\mathbb E[f]\)</span>, for example, in the <a href="http://www.cs.toronto.edu/~hinton/absps/guideTR.pdf"><em>contrastive divergence</em></a> approach by Geoffrey Hinton.</p>
</section>
</section>
<section id="generating-representative-states" class="level2">
<h2 class="anchored" data-anchor-id="generating-representative-states">Generating representative states</h2>
<p>In addition to the motivation coming from (Bayesian) learning, we also need sampling methods to answer queries over probabilistic models approximately. A sum over the entire sample space is approximated by a (weighted) sum over representative samples. Another motivation for developing sampling methods is to generate representative configurations for visualization.</p>
<section id="example-sampling-protein-structures" class="level3">
<h3 class="anchored" data-anchor-id="example-sampling-protein-structures">Example: Sampling protein structures</h3>
<p>As an example for a high-dimensional continuous sample space, we consider the three-dimensional structure of large biomolecules such as proteins. Here, the parameters <span class="math inline">\(x\)</span> are the angles parameterizing a protein configuration (these are the so-called <a href="https://en.wikipedia.org/wiki/Dihedral_angle#Proteins">dihedral angles</a>, rotational degrees of freedom about chemical bonds). Proteins are linear polymers, i.e.&nbsp;chain molecules with a backbone from which side-chain branch off. <a href="https://www.rcsb.org/3d-view/6YQ5">Here</a> is an example of a protein structure that was computed with Monte Carlo methods by sampling a posterior distribution over the dihedral angles.</p>
</section>
<section id="example-sampling-of-ising-models" class="level3">
<h3 class="anchored" data-anchor-id="example-sampling-of-ising-models">Example: Sampling of Ising models</h3>
<p>Ising models are very simple graphical models. Each node can have two colors only, <span class="math inline">\(\{-1, +1\}\)</span>. The graph is a regular square lattice with nearest neighbor edges but no connections otherwise (except for the periodic boundary conditions). The <a href="https://en.wikipedia.org/wiki/Ising_model">Ising model</a> originates in Statistical Physics and was introduced in 1925 by Ernst Ising as a model for spontaneous magnetization observed in ferromagnetic materials.</p>
<p>The probability of a state <span class="math inline">\(x\in\{-1, +1\}^{L\times L}\)</span> is</p>
<p><span class="math display">\[
p(x) = \frac{1}{Z(\beta)} \exp\biggl\{\beta \sum_{i\sim j} x_i x_j \biggr\}
= \frac{1}{Z(\beta)} \exp\bigl\{-\beta\, E(x) \bigr\}
\]</span></p>
<p>where the sum runs over all nearest neighbors <span class="math inline">\(i\sim j\)</span> on the <a href="https://en.wikipedia.org/wiki/Square_lattice_Ising_model">square lattice</a> of edge length <span class="math inline">\(L\)</span>, i.e.&nbsp;each spin has four neighbors with whom it interacts. The energy (negative log probability)</p>
<p><span class="math display">\[
E(x) = -\sum_{i\sim j} x_i x_j
\]</span></p>
<p>favors configurations in which neighboring spins are aligned. The partition function is</p>
<p><span class="math display">\[
Z(\beta) = \sum_{i\sim j} \exp\bigl\{-\beta\, E(x) \bigr\}
\]</span></p>
<p>The parameters <span class="math inline">\(\beta &gt; 0\)</span> is the inverse temperature (from a physical perspective). For <span class="math inline">\(\beta=0\)</span>, we have a uniform distribution over the hypercube. For increasing <span class="math inline">\(\beta\)</span>, the configurations become more and more fragmented forming patches of spins with the same orientation. For large <span class="math inline">\(\beta\)</span> (such as 1), practically only the configurations with all spins up <span class="math inline">\(x_i=+1\)</span> or down <span class="math inline">\(x_i=-1\)</span> have a non-vanishing probability.</p>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>load_ext Cython</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="op">%%</span>cython</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>cimport cython</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>cimport numpy <span class="im">as</span> np</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pylab <span class="im">as</span> plt</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> libc.math cimport exp</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> libc.stdlib cimport rand</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>cdef extern <span class="im">from</span> <span class="st">"limits.h"</span>:</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">int</span> RAND_MAX</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="at">@cython.boundscheck</span>(<span class="va">False</span>)</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="at">@cython.wraparound</span>(<span class="va">False</span>)</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ising_energy(np.int64_t[:, :] x):</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    cdef <span class="bu">int</span> N <span class="op">=</span> x.shape[<span class="dv">0</span>]</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    cdef <span class="bu">int</span> M <span class="op">=</span> x.shape[<span class="dv">1</span>]</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>    cdef <span class="bu">int</span> E <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>    cdef <span class="bu">int</span> i, j</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(M):</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>            E <span class="op">+=</span> x[i,j] <span class="op">*</span> (x[i,(j<span class="op">+</span><span class="dv">1</span>)<span class="op">%</span>M] <span class="op">+</span> x[(i<span class="op">+</span><span class="dv">1</span>)<span class="op">%</span>N, j])</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span>E</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a><span class="at">@cython.boundscheck</span>(<span class="va">False</span>)</span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a><span class="at">@cython.wraparound</span>(<span class="va">False</span>)</span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ising_sweep(np.int64_t[:, :] x, <span class="bu">float</span> beta<span class="op">=</span><span class="fl">0.4</span>):</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>    cdef <span class="bu">int</span> N <span class="op">=</span> x.shape[<span class="dv">0</span>]</span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>    cdef <span class="bu">int</span> M <span class="op">=</span> x.shape[<span class="dv">1</span>]</span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>    cdef <span class="bu">int</span> n_offset, m_offset, n, m</span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> n_offset <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>):</span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> m_offset <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>):</span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(n_offset, N, <span class="dv">2</span>):</span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> m <span class="kw">in</span> <span class="bu">range</span>(m_offset, M, <span class="dv">2</span>):</span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>                    ising_flip(x, n, m, beta)</span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array(x)</span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a><span class="at">@cython.boundscheck</span>(<span class="va">False</span>)</span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a><span class="at">@cython.wraparound</span>(<span class="va">False</span>)</span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>cdef ising_flip(np.int64_t[:, :] x, <span class="bu">int</span> i, <span class="bu">int</span> j, <span class="bu">float</span> beta):</span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>    cdef <span class="bu">int</span> total <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>    cdef <span class="bu">int</span> N <span class="op">=</span> x.shape[<span class="dv">0</span>]</span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>    cdef <span class="bu">int</span> M <span class="op">=</span> x.shape[<span class="dv">1</span>]    </span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>    cdef <span class="bu">float</span> dE <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> x[i, j] <span class="op">*</span> (x[(i<span class="op">-</span><span class="dv">1</span>)<span class="op">%</span>N,j] <span class="op">+</span> x[(i<span class="op">+</span><span class="dv">1</span>)<span class="op">%</span>N,j] <span class="op">+</span> <span class="op">\</span></span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a>                                   x[i,(j<span class="op">-</span><span class="dv">1</span>)<span class="op">%</span>M] <span class="op">+</span> x[i,(j<span class="op">+</span><span class="dv">1</span>)<span class="op">%</span>M])</span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> dE <span class="op">&lt;=</span> <span class="dv">0</span>:</span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a>        x[i, j] <span class="op">*=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> exp(<span class="op">-</span>dE <span class="op">*</span> beta) <span class="op">*</span> RAND_MAX <span class="op">&gt;</span> rand():</span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a>        x[i, j] <span class="op">*=</span> <span class="op">-</span><span class="dv">1</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>In file included from /opt/hostedtoolcache/Python/3.10.9/x64/lib/python3.10/site-packages/numpy/core/include/numpy/ndarraytypes.h:1948,
                 from /opt/hostedtoolcache/Python/3.10.9/x64/lib/python3.10/site-packages/numpy/core/include/numpy/ndarrayobject.h:12,
                 from /opt/hostedtoolcache/Python/3.10.9/x64/lib/python3.10/site-packages/numpy/core/include/numpy/arrayobject.h:5,
                 from /home/runner/.cache/ipython/cython/_cython_magic_7bae0d7313cdd423600d65a294630b12.c:769:
/opt/hostedtoolcache/Python/3.10.9/x64/lib/python3.10/site-packages/numpy/core/include/numpy/npy_1_7_deprecated_api.h:17:2: warning: #warning "Using deprecated NumPy API, disable it with " "#define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION" [-Wcpp]
   17 | #warning "Using deprecated NumPy API, disable it with " \
      |  ^~~~~~~</code></pre>
</div>
</div>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>L <span class="op">=</span> <span class="dv">2</span><span class="op">**</span><span class="dv">8</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.random.choice([<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>],size<span class="op">=</span>(L,L))</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>betas <span class="op">=</span> [<span class="fl">0.</span>, <span class="fl">0.3</span>, <span class="fl">0.4</span>, <span class="fl">0.44</span>, <span class="fl">0.45</span>, <span class="fl">0.8</span>]</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> [x.copy()]</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> beta <span class="kw">in</span> betas[<span class="dv">1</span>:]:</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    X.append(x.copy())</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">100</span>):</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>        ising_sweep(X[<span class="op">-</span><span class="dv">1</span>], beta)</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="bu">len</span>(betas)<span class="op">//</span><span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">6</span>))</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> <span class="bu">list</span>(ax.flat)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> a, beta, x <span class="kw">in</span> <span class="bu">zip</span>(ax, betas, X):</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    a.set_title(<span class="vs">r'$\beta=</span><span class="sc">{0:.2f}</span><span class="vs">$'</span>.<span class="bu">format</span>(beta))</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    a.matshow(x, cmap<span class="op">=</span>plt.cm.gray_r)</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    a.xaxis.set_visible(<span class="va">False</span>)</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    a.yaxis.set_visible(<span class="va">False</span>)</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-4-output-1.png" width="984" height="565"></p>
</div>
</div>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Notation and conventions
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li><p>Most of the time I will consider a <em>probability density function</em> (pdf) or <em>probability mass function</em> (pmf) <span class="math inline">\(p(x)\)</span> where <span class="math inline">\(x\)</span> could be a parameter vector of a probabilistic model (e.g.&nbsp;in case we want to do computations with the posterior) or the observations from which we want to learn a model. For continuous sample spaces <span class="math inline">\(\mathcal X\)</span>, we are dealing with a <strong>pdf</strong>. In case of a discrete sample space <span class="math inline">\(\mathcal X\)</span> (finite or countably infinite), <span class="math inline">\(p(x)\)</span> is a <strong>pmf</strong>.</p></li>
<li><p>It is generally hard to compute normalized probabilities, but also not really necessary for many sampling algorithms. Therefore, often <span class="math inline">\(p(x)\)</span> is just a nonnegative function, and we assume that the integral <span class="math inline">\(\int_{\mathcal X} p(x)dx &lt; \infty\)</span> or sum <span class="math inline">\(\sum_{x\in\mathcal X} p(x) &lt; \infty\)</span> is finite.</p></li>
<li><p>Often, the computation that we need to carry out can be expressed as the <strong>expectation</strong> of some quantity under a probability. We will denote expectations by</p>
<p><span class="math display">\[
\mathbb{E}_{p}[f] = \int_{\mathcal X} f(x)\, p(x)\,  dx
\]</span> e.g.&nbsp;the model evidence used in Bayesian model comparison is <span class="math inline">\(\Pr(D\mid{}M) = \mathbb E_{\Pr(\theta\mid{}M)}[\Pr(D\mid{}\theta,M)]\)</span>.</p></li>
<li><p>The notation <span id="eq-sample_from"><span class="math display">\[
x \sim p(x)
\tag{3}\]</span></span></p>
<p>means that <span class="math inline">\(x\)</span> follows the distribution <span class="math inline">\(p\)</span></p></li>
</ul>
</div>
</div>
<p>At <span class="math inline">\(\beta = \frac{\log(1 + \sqrt 2)}{2} \approx 0.44\)</span>, something peculiar happens. The “attractive forces” that tend to align neighboring spins become so dominant that large regions form. Across these regions, all spins have a similar orientation. This is a <em>phase transition</em>. Similar phenomena occur also in learning large probabilistic models where the prior and the likelihood often favor distinct regions in parameter space.</p>
<p>In graphical models such as the Ising model all computations are finite but have an exponential complexity. For a square lattice of length <span class="math inline">\(L\)</span> there are <span class="math inline">\(2^{L^2}\)</span> possible states. Visiting all states is not an option even for small to moderate lattice sizes such as <span class="math inline">\(L=32\)</span>. In this case, we have <span class="math inline">\(2^{1024}\)</span> states. Compare this to the number of atoms in the universe which is estimated to be approx. <span class="math inline">\(2^{266}\)</span>. As an aside, according to <a href="https://en.wikipedia.org/wiki/Eddington_number">Eddington</a> the number of electrons in the universe is in fact</p>
<p><span class="math inline">\(15747724136275002577605653961181555468044717914527116709366231425076185631031296 \approx 2^{263}\)</span></p>
<p>Anyways, if each atom were a computing device and running since the Bing Bang, i.e.&nbsp;for <span class="math inline">\(13.5 \text{ billion years} \approx 2^{59} s\)</span>, at a rate of <span class="math inline">\(3.3 \text{Gz} =2^{32}\)</span> Hz, then we could have visited <span class="math inline">\(2^{357}\)</span> states. This is only a vanishingly small fraction of the entire state space of the <span class="math inline">\(32\times 32\)</span> Ising model. We would have to wait for <span class="math inline">\(2^{667} \simeq 10^{201}\)</span> universe life times until we had visited all possible states.</p>
<p>For a thorough discussion read the Chap. 29 in David MacKay’s book <a href="http://www.inference.org.uk/itprnn/book.pdf">Information Theory, Inference, and Learning Algorithms</a>.</p>
</section>
</section>
<section id="monte-carlo-methods" class="level2">
<h2 class="anchored" data-anchor-id="monte-carlo-methods">Monte Carlo methods</h2>
<p>The basic idea of <strong>Monte Carlo methods</strong> is to use a random process to compute a (deterministic) quantity. That is, we give up deterministic guarantees and satisfy ourselves with statistical guarantees: we resort to gambling (therefore the name “Monte Carlo”). For a historical background on the beginning of modern Monte Carlo methods have a look at the recollections of pioneers Nick Metropolis (<a href="https://fas.org/sgp/othergov/doe/lanl/pubs/00326866.pdf">The Beginning of the Monte Carlo Method</a>) and Roger Eckhard (<a href="https://fas.org/sgp/othergov/doe/lanl/pubs/00326867.pdf">Stan Ulam, John von Neumann, and the Monte Carlo Method</a>). Using a random experiment to compute a quantity is at least as old as <a href="https://en.wikipedia.org/wiki/Buffon%27s_needle_problem">Buffon’s needle problem</a>:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<figure class="figure">
<img src="images/McCracken_TheMonteCarloMethod_Fig1.png" title="Buffon's needle" class="img-fluid figure-img">
</figure>
<p></p><figcaption class="figure-caption">Buffon’s needle</figcaption><p></p>
</figure>
</div>
<p>Figure from <a href="https://www.jstor.org/stable/24944647?seq=1#metadata_info_tab_contents">McCracken: The Monte Carlo Method</a>.</p>
<p>The idea of the Monte Carlo method for probabilistic inference is simple: Instead of computing the integral/sum by systematically visiting all possible states in <span class="math inline">\(\mathcal X\)</span>, we (randomly) pick those states that are likely to contribute strongly to the sum/integral:</p>
<p><span id="eq-sampling"><span class="math display">\[
\mathbb{E}_{p}[f] = \int_{\mathcal X} f(x)\, p(x)\,  dx \approx \hat f_S := \frac{1}{S} \sum_{s=1}^S f(x^{(s)})\,\,\,\text{with}\,\,\,  x^{(s)} \sim p(x)
\tag{4}\]</span></span> where <span class="math inline">\(x^{(s)}\)</span> are <span class="math inline">\(S\in\mathbb N\)</span> samples from <span class="math inline">\(p(x)\)</span> (the index <span class="math inline">\(s\)</span> enumerates all samples) and <span class="math inline">\(\hat f_S\)</span> is a <em>Monte Carlo estimate</em> or <em>Monte Carlo approximation</em> of <span class="math inline">\(\mathbb E_p[f]\)</span>. Our hope is that with <span class="math inline">\(S\to\infty\)</span>, the approximation becomes better and better. This is indeed the case, as we will see in a second.</p>
<section id="monte-carlo-as-density-estimation" class="level3">
<h3 class="anchored" data-anchor-id="monte-carlo-as-density-estimation">Monte Carlo as density estimation</h3>
<p>The Monte Carlo approximation can also be viewed as a <em>density estimation</em> approach since the estimate <span class="math inline">\(\hat f_S\)</span> can be interpreted as the expectation under the approximate probability <span id="eq-approximate_pdf"><span class="math display">\[
\hat p_S(x) = \frac{1}{S} \sum_{s=1}^S \delta(x - x^{(s)})
\tag{5}\]</span></span> where <span class="math inline">\(\delta(\cdot)\)</span> is the <a href="https://en.wikipedia.org/wiki/Dirac_delta_function">delta distribution</a>: <span id="eq-sampling2"><span class="math display">\[
\hat f_S := \frac{1}{S} \sum_{s=1}^S f(x^{(s)}) = \mathbb E_{\hat p_S}[f]
\tag{6}\]</span></span> We approximate the true probability <span class="math inline">\(p(x)\)</span> with a Monte Carlo estimate <span class="math inline">\(\hat p_S(x)\)</span> obtained at <span class="math inline">\(S\)</span> samples <span class="math inline">\(x^{(s)}\)</span> where</p>
<p><span class="math display">\[
|\hat p_S - p| \to 0\,\,\, \text{for}\,\,\, S\to \infty
\]</span></p>
<p>in some appropriate norm <span class="math inline">\(|\cdot|\)</span>.</p>
</section>
<section id="why-does-it-work" class="level3">
<h3 class="anchored" data-anchor-id="why-does-it-work">Why does it work?</h3>
<section id="unbiasedness" class="level4">
<h4 class="anchored" data-anchor-id="unbiasedness">Unbiasedness</h4>
<p>The joint distribution of all Monte Carlo samples is simply a product density, because all samples are generated <em>independently</em> of each other: <span id="eq-MC-sample-independece"><span class="math display">\[
p_S(x^{(1)}, \ldots, x^{(S)}) = \prod_{s=1}^S p(x^{(s)})
\tag{7}\]</span></span></p>
<p>The Monte Carlo estimate <span class="math inline">\(\hat f_S\)</span> is a random quantity, because with each realization of <span class="math inline">\(x^{(1)}, \ldots, x^{(S)}\)</span> we obtain a different result. We can compute the first two moments of <span class="math inline">\(\hat f_S\)</span>:</p>
<p><span id="eq-MCbias"><span class="math display">\[
\mathbb E_{p_S}[\hat f_S] = \frac{1}{S} \sum_{s=1}^S \mathbb{E}_p[f(x^{(s)})] = \mathbb{E}_p[f] =: \mu
\tag{8}\]</span></span> That is, the Monte Carlo estimate of <span class="math inline">\(\mathbb E_p[f]\)</span> is <strong>unbiased</strong>.</p>
<p>How accurate is the estimate on average (i.e.&nbsp;how close do we get to the true value if we run many replications of the sampling procedure)? To answer this question, we compute the variance</p>
<p><span id="eq-MCvariance"><span class="math display">\[
    \text{var}_{p_S}[\hat f_S] = \mathbb{E}_{p_S}\bigl[(\hat f_S - \mu)^2\bigr] =
    \frac{1}{S} \text{var}_{p}[f]\, .
\tag{9}\]</span></span></p>
<p>To see the validity of the last result, we first write</p>
<p><span class="math display">\[
\begin{aligned}
    \text{var}_{p_S}[\hat f_S]
    &amp;= \mathbb{E}_{p_S}\bigl[(\hat f_S - \mu)^2\bigr] \\
    &amp;= \mathbb{E}_{p_S}\bigl[\frac{1}{S^2} \sum_{s,s'} \underbrace{(f(x^{(s)}) - \mu)}_{\tilde f(x^{(s)})} (f(x^{(s')}) - \mu))\bigr] \\
    &amp;= \mathbb{E}_{p_S}\bigl[\frac{1}{S^2} \sum_{s,s'} \tilde f(x^{(s)}) \tilde f(x^{(s')}) \bigr] \\
\end{aligned}
\]</span></p>
<p>where <span class="math inline">\(\tilde f(x^{(s)}) := f(x^{(s)}) - \mu\)</span> has a vanishing first moment:</p>
<p><span class="math display">\[
\mathbb{E}_{p_S}\bigl[ \tilde f(x^{(s)}) \bigr]
= \mathbb{E}_{p(x^{(s)})}\bigl[ \tilde f(x^{(s)}) \bigr]
= \mathbb{E}_{p}[f] - \mu = 0\, .
\]</span></p>
<p>The second moment is identical to the variance of f:</p>
<p><span class="math display">\[
\mathbb{E}_{p_S}\bigl[( \tilde f(x^{(s)}) )^2 \bigr]
= \mathbb{E}_{p(x^{(s)})} \bigl[( \tilde f(x^{(s)}) )^2 \bigr]
= \mathbb{E}_{p}[(f - \mu)^2]
= \text{var}_{p}[f]\, .
\]</span></p>
<p>It follows that <span class="math display">\[
\begin{aligned}
    \text{var}_{p_S}[\hat f_S]
    &amp;= \mathbb{E}_{p_S}\bigl[\frac{1}{S^2} \sum_{s,s'} \tilde f(x^{(s)}) \tilde f(x^{(s')}) \bigr] \\
    &amp;= \frac{1}{S^2} \sum_{s,s'} \mathbb{E}_{p_S}\bigl[\tilde f(x^{(s)}) \tilde f(x^{(s')}) \bigr] \\
    &amp;= \frac{1}{S^2} \sum_{s} \mathbb{E}_{p_S}\bigl[(\tilde f(x^{(s)}))^2 \bigr] + \frac{1}{S^2} \sum_{s\not= s'} \mathbb{E}_{p_S}\bigl[\tilde f(x^{(s)}) \tilde f(x^{(s')}) \bigr] \\
    &amp;= \frac{1}{S} \text{var}_{p}[f] + \frac{1}{S^2} \sum_{s\not= s'} \underbrace{\mathbb{E}_{p(x^{(s)})}\bigl[\tilde f(x^{(s)})\bigr]}_{0} \, \mathbb{E}_{p(x^{(s')})}\bigl[ \tilde f(x^{(s')}) \bigr] \\
    &amp;= \frac{1}{S} \text{var}_{p}[f] \\
\end{aligned}
\]</span></p>
<p>where we’ve made use of the linearity of expectations in the second equality, and of the independence of the samples (eq. <a href="#eq-MC-sample-independece">Equation&nbsp;7</a>) in the third.</p>
<p>The result shows that Monte Carlo error bars shrink like <span class="math inline">\(1/\sqrt{S}\)</span>:</p>
<p><span id="eq-MCerror"><span class="math display">\[
\sigma(\hat f_S) := \sqrt{\text{var}[\hat f_S]} = \sigma(f) / \sqrt{S}
\tag{10}\]</span></span></p>
<p>where the proportionality constant <span class="math inline">\(\sigma(f)=\sqrt{\text{var}[f]}\)</span> depends on the specific estimation problem. In practice, <span class="math inline">\(\sigma(f)\)</span> is not available (after all we are doing Monte Carlo because we cannot do the sum/integrals that are necessary to compute means and variances…). However, we can use Monte Carlo to estimate <span class="math inline">\(\sigma(f)\)</span>.</p>
</section>
<section id="asymptotic-guarantees" class="level4">
<h4 class="anchored" data-anchor-id="asymptotic-guarantees">Asymptotic guarantees</h4>
<p>So far, we studied the behavior of the Monte Carlo estimator for fixed number of samples <span class="math inline">\(S\)</span> and many repetitions. Let us now look at the limit <span class="math inline">\(S\to\infty\)</span>. We have (almost surely)</p>
<p><span id="eq-slln"><span class="math display">\[
\hat f_S \overset{S\to\infty}{\longrightarrow} \mu = \mathbb E_p[f]
\tag{11}\]</span></span></p>
<p>This result is known as the <a href="https://en.wikipedia.org/wiki/Law_of_large_numbers"><em>strong law of large numbers</em></a>.</p>
<p>If <span class="math inline">\(\text{var}[f] &lt; \infty\)</span>, then the <a href="https://en.wikipedia.org/wiki/Central_limit_theorem"><strong>Central limit theorem</strong> (CLT)</a>, a fundamental theorem in Statistics, guarantees that Monte Carlo works:</p>
<p><span id="eq-CLT"><span class="math display">\[
\hat f_S \overset{S\to\infty}{\longrightarrow} \mathcal N\left(\mathbb E_p[f], \sigma(f)^2/S\right)
\tag{12}\]</span></span></p>
<p>where <span class="math inline">\(\mathcal N(\mu, \sigma^2)\)</span> is the <a href="https://en.wikipedia.org/wiki/Normal_distribution">Normal distribution</a> with mean <span class="math inline">\(\mu\)</span> and variance <span class="math inline">\(\sigma\)</span>.</p>
<p>But these are only statistical, asymptotic guarantees for the convergence of Monte Carlo methods.</p>
</section>
</section>
<section id="application-a-slightly-silly-way-to-estimate-pi" class="level3">
<h3 class="anchored" data-anchor-id="application-a-slightly-silly-way-to-estimate-pi">Application: A slightly silly way to estimate <span class="math inline">\(\pi\)</span></h3>
<p>Let us use a simple Monte Carlo approach to estimate <span class="math inline">\(\pi\)</span>. We have</p>
<p><span id="eq-pi"><span class="math display">\[
\pi = \int_{[-1,1]^2} \mathbb 1(x^2 + y^2 &lt; 1)\, \, dx dy = \int_{\mathcal X} f(x, y)\, p(x, y)\, dxdy
\tag{13}\]</span></span></p>
<p>where <span class="math inline">\(\mathbb 1(\cdot)\)</span> is the indicator function. In this example, the distribution <span class="math inline">\(p(x,y)=1/4\)</span> is the uniform distribution over the square <span class="math inline">\(\mathcal X = [-1, 1]^2\)</span> and <span class="math inline">\(f(x, y) = 4\cdot\mathbb 1(x^2 + y^2 &lt; 1)\)</span>. We have:</p>
<p><span class="math display">\[
\mathbb E[f] = \pi\,\,\,\text{and}\,\,\,\text{var}[f] = (4-\pi)\, \pi
\]</span></p>
<p>This integral can be approximated by:</p>
<p><span id="eq-pi_MC"><span class="math display">\[
\pi \approx \frac{1}{S} \sum_{s=1}^S f(x^{(s)}, y^{(s)})
\tag{14}\]</span></span></p>
<p>where <span class="math inline">\((x^{(s)}, y^{(s)})\)</span> are picked randomly from the unit square. The approximate value of <span class="math inline">\(\pi\)</span> is just four times the fraction of sampling points that land in the unit disk.</p>
<p>Let’s code it in Python:</p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># graphical illustration</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib.patches <span class="im">import</span> Circle</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.random.uniform(<span class="op">-</span><span class="dv">1</span>, <span class="op">+</span><span class="dv">1</span>, size<span class="op">=</span>(<span class="dv">2</span>, S))</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> np.<span class="bu">sum</span>(x<span class="op">**</span><span class="dv">2</span>, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>circle <span class="op">=</span> Circle((<span class="fl">0.</span>,<span class="fl">0.</span>), radius<span class="op">=</span><span class="fl">1.</span>, facecolor<span class="op">=</span><span class="st">'b'</span>, alpha<span class="op">=</span><span class="fl">0.1</span>, edgecolor<span class="op">=</span><span class="st">'k'</span>, lw<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">5</span>, <span class="dv">5</span>))</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>ax.scatter(<span class="op">*</span>x[:,r<span class="op">&lt;=</span><span class="dv">1</span>], color<span class="op">=</span><span class="st">'b'</span>, s<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>ax.scatter(<span class="op">*</span>x[:,r<span class="op">&gt;</span><span class="dv">1</span>], color<span class="op">=</span><span class="st">'r'</span>, s<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>ax.add_patch(circle)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-5-output-1.png" width="470" height="470"></p>
</div>
</div>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> estimate_pi(S):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Monte Carlo estimate of pi.</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="co">    ----------</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="co">    S : number of samples</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># pick S points from unit square</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> np.random.uniform(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, size<span class="op">=</span>(<span class="dv">2</span>, <span class="bu">int</span>(S)))</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># compute squared distance from center</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> np.<span class="bu">sum</span>(x<span class="op">**</span><span class="dv">2</span>, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># fraction of points in unit circle</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">4</span> <span class="op">*</span> np.mean(r <span class="op">&lt;</span> <span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>How well does this simple Monte Carlo procedure work, if we increase the number of sampling points?</p>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> np.logspace(<span class="dv">3</span>, <span class="dv">6</span>, <span class="dv">10</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>estimates <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(estimate_pi, S))</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>kw <span class="op">=</span> <span class="bu">dict</span>(xlabel<span class="op">=</span><span class="vs">r'number of samples $S$'</span>)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">5</span>), subplot_kw<span class="op">=</span>kw)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].plot(S, estimates, color<span class="op">=</span><span class="st">'k'</span>, lw<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].axhline(np.pi, ls<span class="op">=</span><span class="st">'--'</span>, color<span class="op">=</span><span class="st">'r'</span>, lw<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_ylabel(<span class="vs">r'estimated $\pi$'</span>)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].plot(S, np.fabs(np.array(estimates)<span class="op">-</span>np.pi), color<span class="op">=</span><span class="st">'k'</span>, lw<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_ylabel(<span class="vs">r'error'</span>)</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>np.<span class="bu">round</span>(np.transpose([S, estimates]), <span class="dv">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="6">
<pre><code>array([[1.00000000e+03, 3.17600000e+00],
       [2.15443500e+03, 3.17200000e+00],
       [4.64158900e+03, 3.14800000e+00],
       [1.00000000e+04, 3.14800000e+00],
       [2.15443470e+04, 3.15800000e+00],
       [4.64158880e+04, 3.16000000e+00],
       [1.00000000e+05, 3.13700000e+00],
       [2.15443469e+05, 3.14200000e+00],
       [4.64158883e+05, 3.13900000e+00],
       [1.00000000e+06, 3.14000000e+00]])</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-7-output-2.png" width="949" height="468"></p>
</div>
</div>
<p>To quantify the statistical error, we run multiple replications of the procedure:</p>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>n_rep <span class="op">=</span> <span class="dv">200</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>estimates <span class="op">=</span> np.array([<span class="bu">list</span>(<span class="bu">map</span>(estimate_pi, S)) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n_rep)])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>mean_pi <span class="op">=</span> estimates.mean(<span class="dv">0</span>)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>std_pi <span class="op">=</span> estimates.std(<span class="dv">0</span>)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>var <span class="op">=</span> np.pi <span class="op">*</span> (<span class="fl">4.0</span> <span class="op">-</span> np.pi)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">5</span>), subplot_kw<span class="op">=</span>kw)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>ax.fill_between(S, mean_pi <span class="op">-</span> np.pi <span class="op">+</span> std_pi, mean_pi <span class="op">-</span> np.pi <span class="op">-</span> std_pi,</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>                color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>ax.plot(S, mean_pi <span class="op">-</span> np.pi, lw<span class="op">=</span><span class="dv">3</span>, color<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>ax.plot(S, <span class="op">-</span>(var<span class="op">/</span>S)<span class="op">**</span><span class="fl">0.5</span>, color<span class="op">=</span><span class="st">'r'</span>, ls<span class="op">=</span><span class="st">'--'</span>)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>ax.plot(S, <span class="op">+</span>(var<span class="op">/</span>S)<span class="op">**</span><span class="fl">0.5</span>, color<span class="op">=</span><span class="st">'r'</span>, ls<span class="op">=</span><span class="st">'--'</span>)</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="vs">r'Monte Carlo error'</span>)</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>ax.semilogx()</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-9-output-1.png" width="758" height="466"></p>
</div>
</div>
</section>
</section>
</section>
<section id="lecture-2-direct-sampling-methods-1" class="level1">
<h1>Lecture 2: Direct Sampling Methods</h1>
<section id="outline-1" class="level2">
<h2 class="anchored" data-anchor-id="outline-1">Outline</h2>
<ul>
<li>Can we beat the curse of dimensionality?</li>
<li>Random number generation</li>
<li>Direct sampling by variable transformation methods</li>
</ul>
<section id="a-warning" class="level3">
<h3 class="anchored" data-anchor-id="a-warning">A warning</h3>
<p>Alan Sokal (<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.49.4444&amp;rep=rep1&amp;type=pdf">Monte Carlo methods in statistical mechanics</a>):</p>
<blockquote class="blockquote">
<p>Monte Carlo is an extremely bad method; it should be used only when all alternative methods are worse.</p>
</blockquote>
<p>Why is this so? As we saw Monte Carlo methods have a statistical error that roughly scales with <span class="math inline">\(1/\sqrt{\text{computational budget}}\)</span>. Typically, for low-dimensional problems other numerical methods scale much better. For example, even simple quadrature methods such as <a href="https://en.wikipedia.org/wiki/Simpson%27s_rule">Simpon’s rule</a> have an error that scales with <span class="math inline">\(\mathcal O(S^{-4/D})\)</span> rather than <span class="math inline">\(\mathcal O(S^{-1/2})\)</span> where <span class="math inline">\(D\)</span> is the dimension of the integrand. This means that for <span class="math inline">\(D\le 8\)</span>, Simpson’s rule will be more efficient than Monte Carlo. However, in higher dimensions this is often no longer the case, and we have to resort to Monte Carlo methods.</p>
<p>Our specific application of Monte Carlo (estimation of <span class="math inline">\(\pi\)</span>) is a clear case where Sokal’s warning applies. If we use numerical quadrature, we can achieve a high accuracy with much less effort:</p>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pylab <span class="im">as</span> plt</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.integrate <span class="im">import</span> quad</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>val, err, info <span class="op">=</span> quad(<span class="kw">lambda</span> x: (<span class="dv">1</span><span class="op">-</span>x<span class="op">**</span><span class="dv">2</span>)<span class="op">**</span>(<span class="dv">1</span><span class="op">/</span><span class="dv">2</span>), <span class="fl">0.</span>, <span class="fl">1.</span>, full_output<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'estimate: </span><span class="sc">{</span><span class="dv">4</span><span class="op">*</span>val<span class="sc">}</span><span class="ss"> based on </span><span class="sc">{</span>info[<span class="st">"neval"</span>]<span class="sc">}</span><span class="ss"> points'</span>)</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'accuracy: </span><span class="sc">{</span><span class="bu">abs</span>(<span class="dv">4</span><span class="op">*</span>val<span class="op">-</span>np.pi)<span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>estimate: 3.1415926535897922 based on 231 points
accuracy: 8.881784197001252e-16</code></pre>
</div>
</div>
</section>
</section>
<section id="do-we-beat-the-curse-of-dimensionality" class="level2">
<h2 class="anchored" data-anchor-id="do-we-beat-the-curse-of-dimensionality">Do we beat the curse of dimensionality?</h2>
<p>Although Monte Carlo doesn’t depend explicitly on the dimension of the sample space, it does so in practice. If we go back to our expression for the Monte Carlo error (Eq. <a href="#eq-MCerror">Equation&nbsp;10</a>)</p>
<p><span class="math display">\[
\sigma(\hat f_S) = \sigma(f) / \sqrt{S}
\]</span></p>
<p>for a generalized version of the <span class="math inline">\(\pi\)</span> estimation approach, then the dependence on the dimension of the sampling problem becomes apparent.</p>
<p>In the generalized version, we estimate the volume of a <a href="https://en.wikipedia.org/wiki/Ball_(mathematics)"><span class="math inline">\(D\)</span>-dimensional unit-ball</a> <span class="math inline">\(V(D)\)</span> by the following Monte Carlo procedure:</p>
<ul>
<li>Pick a point from a unit hypercube (assuming that this can be done easily)</li>
<li>Check if point lies inside ball</li>
</ul>
<p>Written out in equations where <span class="math inline">\(x\)</span> is now a <span class="math inline">\(D\)</span>-dimensional vector:</p>
<p><span class="math display">\[
V(D) = \int \mathbb 1(\|x\| \le 1) dx = \int p(x)\, f(x)\, dx
\]</span> with <span class="math display">\[
f(x) = 2^D\, \mathbb 1(\|x\| \le 1)\,\,\, \text{and} \,\,\, p(x) = \frac{1}{2^D} \mathbb 1(x \in [-1, 1]^D)
\]</span></p>
<p>We can compute how the Monte Carlo error scales by evaluating the mean and variance of <span class="math inline">\(f\)</span>:</p>
<p><span class="math display">\[
\begin{aligned}
    \mathbb E[f] &amp;= V(D)\\
    \text{var}[f] &amp;= \mathbb E[f^2]  - V^2(D) = 2^D V(D) - V^2(D) = \bigl(2^D - V(D)\bigr)\, V(D)
\end{aligned}
\]</span></p>
<p>Therefore, the error of the above Monte Carlo procedure scales with <span class="math inline">\(D\)</span> as follows:</p>
<p><span class="math display">\[
\sigma(\hat f) = \sqrt{\frac{\bigl(2^D - V(D)\bigr)\, V(D)}{S}}
\]</span></p>
<p>We <a href="https://en.wikipedia.org/wiki/Volume_of_an_n-ball">have</a>:</p>
<p><span class="math display">\[
V(D) = \frac{\pi^{D/2}}{\Gamma(D/2+1)} \approx \frac{1}{\sqrt{D\pi}} \left(\frac{2\pi e}{D}\right)^{D/2}
\]</span></p>
<p>Therefore, overall:</p>
<p><span class="math display">\[
\sigma(\hat f) \approx (8e\pi/D)^{D/4} \bigl/\bigr. (\pi D)^{1/4} \sqrt{S}
\]</span></p>
<div class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.special <span class="im">import</span> gammaln, lambertw</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> estimate_volume(D, S):</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="co">    D : dimension of embedding space</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="co">    S : number of sampling points</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    volcube <span class="op">=</span> <span class="dv">2</span><span class="op">**</span>D</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    points <span class="op">=</span> np.random.uniform(<span class="op">-</span><span class="fl">1.</span>, <span class="fl">1.</span>, size<span class="op">=</span>(S, D))</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    distance <span class="op">=</span> np.linalg.norm(points, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.mean(distance <span class="op">&lt;=</span> <span class="fl">1.</span>) <span class="op">*</span> volcube</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> volball(D):</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a><span class="co">    Volume of a unit ball in D dimensions</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a><span class="co">    See: https://en.wikipedia.org/wiki/Volume_of_an_n-ball</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>    logvol <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> D <span class="op">*</span> np.log(np.pi) <span class="op">-</span> gammaln(D<span class="op">/</span><span class="dv">2</span> <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.exp(logvol)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> <span class="dv">10000</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>n_trials <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>dims <span class="op">=</span> np.arange(<span class="dv">1</span>, <span class="dv">30</span>)</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>vols <span class="op">=</span> np.array([[estimate_volume(D, S) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n_trials)] <span class="cf">for</span> D <span class="kw">in</span> dims])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co"># show results</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>dims <span class="op">=</span> np.arange(<span class="bu">len</span>(vols))<span class="op">+</span><span class="dv">1</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>kw <span class="op">=</span> <span class="bu">dict</span>(xlabel<span class="op">=</span><span class="vs">r'dimension $D$'</span>)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">4</span>), subplot_kw<span class="op">=</span>kw)</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].fill_between(dims, vols.mean(<span class="dv">1</span>) <span class="op">+</span> vols.std(<span class="dv">1</span>), </span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>                   vols.mean(<span class="dv">1</span>) <span class="op">-</span> vols.std(<span class="dv">1</span>), color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].plot(dims, vols.mean(<span class="dv">1</span>), lw<span class="op">=</span><span class="dv">3</span>, color<span class="op">=</span><span class="st">'k'</span>, label<span class="op">=</span><span class="st">'estimated volume'</span>)</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].plot(dims, volball(dims), lw<span class="op">=</span><span class="dv">2</span>, color<span class="op">=</span><span class="st">'r'</span>, ls<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="st">'true volume'</span>)</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_ylabel(<span class="st">'volume of unit ball'</span>)</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].legend()</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_ylim(<span class="op">-</span><span class="fl">1.</span>, <span class="fl">6.</span>)</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Monte Carlo error</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>dims <span class="op">=</span> np.arange(<span class="dv">1</span>, <span class="dv">100</span>)</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>err <span class="op">=</span> np.sqrt((<span class="fl">2.</span><span class="op">**</span>dims <span class="op">-</span> volball(dims)) <span class="op">*</span> volball(dims))</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>approx_err <span class="op">=</span> (np.pi<span class="op">*</span>dims)<span class="op">**</span>(<span class="op">-</span><span class="dv">1</span><span class="op">/</span><span class="dv">4</span>) <span class="op">*</span> (<span class="dv">8</span><span class="op">*</span>np.pi<span class="op">*</span>np.e<span class="op">/</span>dims)<span class="op">**</span>(dims<span class="op">/</span><span class="dv">4</span>)</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>dim_crit <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">/</span>lambertw(<span class="op">-</span><span class="dv">1</span><span class="op">/</span>(<span class="dv">8</span><span class="op">*</span>np.pi)).real</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].plot(dims, err, lw<span class="op">=</span><span class="dv">3</span>, color<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].plot(dims, approx_err, lw<span class="op">=</span><span class="dv">2</span>, color<span class="op">=</span><span class="st">'r'</span>, ls<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="st">'approx. error'</span>)</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].axvline(dim_crit, lw<span class="op">=</span><span class="dv">2</span>, color<span class="op">=</span><span class="st">'b'</span>, ls<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="st">'largest MC error</span><span class="ch">\n</span><span class="st">'</span> <span class="op">+</span> <span class="vs">r'at $D=24$'</span>)</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_ylabel(<span class="st">'MC error'</span>)</span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].legend()</span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(volball(np.arange(<span class="dv">1</span>, <span class="dv">10</span>)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[2.         3.14159265 4.1887902  4.9348022  5.26378901 5.16771278
 4.72476597 4.05871213 3.2985089 ]</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-13-output-2.png" width="757" height="373"></p>
</div>
</div>
<p>The Monte Carlo error depends on the dimension in a non-trivial fashion. The dimension with the largest scaling factor <span class="math inline">\(\sigma(f)\)</span> is approximately</p>
<p><span class="math display">\[
D_{\text{max. error}} \approx -1 / W(-1/(8\pi)) \approx 24
\]</span></p>
<p>where <span class="math inline">\(W\)</span> is the <a href="https://en.wikipedia.org/wiki/Lambert_W_function">Lambert W function</a>. Another problem is that the chance of hitting a point in the unit ball by sampling from the hypercube <span class="math inline">\([-1, 1]^D\)</span> dwindles dramatically as <span class="math inline">\(D\)</span> decreases, since</p>
<p><span class="math display">\[
\text{acceptance rate} = \frac{\text{ volume ball}}{\text{ volume cube}} = \frac{V(D)}{2^D} \to 0
\]</span></p>
<p>That is, although the Monte Carlo error decays beyond <span class="math inline">\(D &gt; 24\)</span>, the generation of a point inside the ball becomes extremely rare.</p>
</section>
<section id="pros-and-cons-of-monte-carlo" class="level2">
<h2 class="anchored" data-anchor-id="pros-and-cons-of-monte-carlo">Pros and Cons of Monte Carlo</h2>
<p><strong>Pros</strong> of the Monte Carlo method:</p>
<ul>
<li><p>Monte Carlo methods are widely applicable. For instance, <span class="math inline">\(f\)</span> and <span class="math inline">\(p\)</span> need not be continuous, differentiable etc.</p></li>
<li><p>Monte Carlo is often easy to implement.</p></li>
<li><p>Monte Carlo <em>can</em> work well in multiple dimensions, where grid-based methods can be inefficient/inapplicable. This is supported by the “<span class="math inline">\(\mathcal O(1/\sqrt{S})\)</span> rate of convergence” which is independent of the dimension.</p></li>
</ul>
<p><strong>Cons</strong>:</p>
<ul>
<li><p>Even though the Monte Carlo rate is usually <span class="math inline">\(\mathcal O(1/\sqrt{S})\)</span>, the constants involved may grow exponentially in dimension.</p></li>
<li><p>Deterministic methods may have better rate of convergence than the Monte Carlo rate <span class="math inline">\(1/\sqrt{S}\)</span> (but may also deteriorate faster when dimension increases).</p></li>
<li><p>Monte Carlo estimate is always random, so we never have a guaranteed tolerance, but only statistical evidence (consistent confidence intervals at best).</p></li>
</ul>
</section>
<section id="pseudo-random-number-generators" class="level2">
<h2 class="anchored" data-anchor-id="pseudo-random-number-generators">Pseudo-random Number Generators</h2>
<p>Monte Carlo Estimation depends on the availability of uniform random numbers (we needed these in order to generate points in the hypercube). One possibility to generate random numbers is to do random experiments such as rolling a die. Swiss Astronomer <a href="https://en.wikipedia.org/wiki/Rudolf_Wolf">Rudolf Wolf</a> rolled a pair of dice 20000 times (see e.g.&nbsp;<a href="https://www.lesswrong.com/posts/zd89utY4afA59p58k/wolf-s-dice">Wolf dice data</a>). He also performed <a href="https://en.wikipedia.org/wiki/Buffon%27s_needle_problem">Buffon’s needle</a> experiment to verify the value of <span class="math inline">\(\pi\)</span>. Francis Galton designed a device, the quincunx or <a href="https://en.wikipedia.org/wiki/Bean_machine">Galton board</a>, for generating randomly distributed balls or beans that follow a Gaussian distribution (in fact Binomial distribution). Here is a nice <a href="https://twitter.com/CentrlPotential/status/1332124614391173123">animation</a> and an interactive <a href="https://www.mathsisfun.com/data/quincunx.html">online tool</a>. The RAND cooperation used an electrical roulette wheel to generate 1 million random numbers that were published as a <a href="https://en.wikipedia.org/wiki/A_Million_Random_Digits_with_100,000_Normal_Deviates">book</a>. More hardware implementations for generating random numbers have been developed (see <a href="https://en.wikipedia.org/wiki/Hardware_random_number_generator">wikipedia</a> for more information). For example, <a href="https://en.wikipedia.org/wiki/RDRAND">RDRAND</a> extracts random numbers from an Intel on-chip hardware random number generator.</p>
<div class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># simulation of Galton board</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> GaltonBoard:</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># directions into which ball can jump</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    left, right <span class="op">=</span> <span class="op">-</span><span class="fl">0.5</span>, <span class="op">+</span><span class="fl">0.5</span>    </span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, n_beans<span class="op">=</span><span class="fl">1e4</span>, n_pegs<span class="op">=</span><span class="dv">20</span>):</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a><span class="co">        n_beans : int or float</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a><span class="co">          number of beans that will run through board</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a><span class="co">        n_pegs : int &gt; 0</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a><span class="co">          number of pegs from top to bottom</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.n_beans <span class="op">=</span> <span class="bu">int</span>(n_beans)</span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.n_pegs <span class="op">=</span> <span class="bu">int</span>(n_pegs)</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> simulate_jumps(<span class="va">self</span>):</span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Simulate all jumps as a random walk. """</span></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.random.choice([GaltonBoard.left, GaltonBoard.right], </span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>                                size<span class="op">=</span>(<span class="va">self</span>.n_beans, <span class="va">self</span>.n_pegs))</span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> sample_positions(<span class="va">self</span>):</span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Simulate jumps and return final position of beans by adding up</span></span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a><span class="co">        all steps for left/right. </span></span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.simulate_jumps().<span class="bu">sum</span>(<span class="dv">1</span>)</span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a>board <span class="op">=</span> GaltonBoard(n_beans<span class="op">=</span><span class="fl">1e3</span>, n_pegs<span class="op">=</span><span class="dv">99</span>)</span>
<span id="cb17-32"><a href="#cb17-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-33"><a href="#cb17-33" aria-hidden="true" tabindex="-1"></a><span class="co"># accumulate</span></span>
<span id="cb17-34"><a href="#cb17-34" aria-hidden="true" tabindex="-1"></a>x, counts <span class="op">=</span> np.unique(board.sample_positions(), return_counts<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb17-35"><a href="#cb17-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-36"><a href="#cb17-36" aria-hidden="true" tabindex="-1"></a><span class="co"># convert counts to probability</span></span>
<span id="cb17-37"><a href="#cb17-37" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> counts.astype(<span class="st">'d'</span>) <span class="op">/</span> counts.<span class="bu">sum</span>()</span>
<span id="cb17-38"><a href="#cb17-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-39"><a href="#cb17-39" aria-hidden="true" tabindex="-1"></a><span class="co"># fit Gaussian</span></span>
<span id="cb17-40"><a href="#cb17-40" aria-hidden="true" tabindex="-1"></a>mu <span class="op">=</span> np.dot(p, x)</span>
<span id="cb17-41"><a href="#cb17-41" aria-hidden="true" tabindex="-1"></a>sigma <span class="op">=</span> np.dot(p, (x<span class="op">-</span>mu)<span class="op">**</span><span class="dv">2</span>)<span class="op">**</span>(<span class="dv">1</span><span class="op">/</span><span class="dv">2</span>)</span>
<span id="cb17-42"><a href="#cb17-42" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.linspace(<span class="op">-</span><span class="fl">1.</span>, <span class="fl">1.</span>, <span class="dv">1000</span>) <span class="op">*</span> <span class="dv">5</span> <span class="op">*</span> sigma <span class="op">+</span> mu</span>
<span id="cb17-43"><a href="#cb17-43" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> np.exp(<span class="op">-</span><span class="fl">0.5</span> <span class="op">*</span> (t<span class="op">-</span>mu)<span class="op">**</span><span class="dv">2</span><span class="op">/</span>sigma<span class="op">**</span><span class="dv">2</span> <span class="op">-</span> <span class="fl">0.5</span> <span class="op">*</span> np.log(<span class="dv">2</span><span class="op">*</span>np.pi<span class="op">*</span>sigma<span class="op">**</span><span class="dv">2</span>))</span>
<span id="cb17-44"><a href="#cb17-44" aria-hidden="true" tabindex="-1"></a>g <span class="op">*=</span> np.diff(x).<span class="bu">min</span>()</span>
<span id="cb17-45"><a href="#cb17-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-46"><a href="#cb17-46" aria-hidden="true" tabindex="-1"></a><span class="co"># compare results graphically</span></span>
<span id="cb17-47"><a href="#cb17-47" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb17-48"><a href="#cb17-48" aria-hidden="true" tabindex="-1"></a>ax.bar(x, p, color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.2</span>)</span>
<span id="cb17-49"><a href="#cb17-49" aria-hidden="true" tabindex="-1"></a>ax.plot(t, g, lw<span class="op">=</span><span class="dv">3</span>, color<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb17-50"><a href="#cb17-50" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-14-output-1.png" width="662" height="470"></p>
</div>
</div>
<section id="linear-congruential-generator" class="level3">
<h3 class="anchored" data-anchor-id="linear-congruential-generator">Linear congruential generator</h3>
<p><a href="https://en.wikipedia.org/wiki/Pseudorandom_number_generator">Pseudo random number generators (PRNGs)</a> are typically used to produce uniformly distributed pseudo random numbers. One of the standard PRGNs is the <a href="https://en.wikipedia.org/wiki/Linear_congruential_generator"><strong>linear congruential generator</strong> (LCG)</a> introduced by <a href="https://en.wikipedia.org/wiki/D._H._Lehmer">D. H. Lehmer</a>. LCG uses a recurrence relation to generate a new random number <span class="math inline">\(x^{(s+1)}\)</span> from a current one <span class="math inline">\(x^{(s)}\)</span>:</p>
<p><span class="math display">\[
x^{(s+1)} = (a x^{(s)} + c)\, \text{mod}\, m
\]</span></p>
<p>with</p>
<ul>
<li><p><strong>modulus</strong> <span class="math inline">\(m &gt; 0\)</span></p></li>
<li><p><strong>multiplier</strong> <span class="math inline">\(a\)</span> where <span class="math inline">\(0 &lt; a &lt; m\)</span></p></li>
<li><p><strong>increment</strong> <span class="math inline">\(c\)</span> where <span class="math inline">\(0 \le c &lt; m\)</span></p></li>
<li><p><strong>seed</strong> <span class="math inline">\(x^{(0)}\)</span> where <span class="math inline">\(0 \le x^{(0)} &lt; m\)</span></p></li>
</ul>
<p>This is an iterative linear mapping combined with the modulo operation resulting in a discontinuity as soon as the next number escapes from the interval <span class="math inline">\([0,m-1]\)</span>. The initial value <span class="math inline">\(x^{(0)}\)</span> is called the <strong>random seed</strong> or just <strong>seed</strong>. LCGs produce <em>periodic</em> random numbers: as soon as a number is visited twice it will produce the exact same sequence of random numbers. This will happen after at most <span class="math inline">\(m\)</span> iterations. Therefore, the period of the sequence is <span class="math inline">\(m\)</span> or smaller, and we have to choose large <span class="math inline">\(m\)</span> in order to not exhaust our random numbers too quickly. Moreover, we should also choose the increment <span class="math inline">\(c\)</span> and multiplier <span class="math inline">\(a\)</span> such that they are smaller than <span class="math inline">\(m\)</span>. By construction, <span class="math inline">\(x^{(s)}\in[m]\)</span> and <span class="math inline">\(u^{(s)} = x^{(s)}/m\)</span> are uniformly distributed random numbers in <span class="math inline">\([0,1)\)</span>. Among the most widely used PRNGs is the <a href="https://en.wikipedia.org/wiki/Mersenne_Twister">Mersenne Twister</a>.</p>
<div class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co">"""</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="co">Pseudo random number generator</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="co">"""</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> PRNG:</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""PRNG</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="co">    Pseudo-random number generator implemented as iterator. Using a linear </span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="co">    congruential generator (LCG) to generate random numbers. Default settings</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a><span class="co">    for modulus, multiplier and period are taken from Numerical Recipes. </span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a><span class="co">    Example</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a><span class="co">    -------</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a><span class="co">    &gt;&gt;&gt; prng = PRNG(maximum=1e4)</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a><span class="co">    x = list(prng)</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a><span class="co">    &gt;&gt;&gt; len(x)</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a><span class="co">    10000</span></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a><span class="co">    Details:</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a><span class="co">    * https://en.wikipedia.org/wiki/Linear_congruential_generator</span></span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, m<span class="op">=</span><span class="dv">2</span><span class="op">**</span><span class="dv">32</span>, a<span class="op">=</span><span class="dv">1664525</span>, c<span class="op">=</span><span class="dv">1013904223</span>, seed<span class="op">=</span><span class="dv">10</span>, maximum<span class="op">=</span><span class="fl">1e6</span>):</span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a><span class="co">        Parameters</span></span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a><span class="co">        ----------</span></span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a><span class="co">        m : int &gt; 0</span></span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a><span class="co">            modulus or period</span></span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a><span class="co">        a : int &gt; 0</span></span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a><span class="co">            multiplier (should be smaller than modulus)</span></span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true" tabindex="-1"></a><span class="co">        c : int &gt;= 0</span></span>
<span id="cb18-32"><a href="#cb18-32" aria-hidden="true" tabindex="-1"></a><span class="co">            increment (should be smaller than modulus)</span></span>
<span id="cb18-33"><a href="#cb18-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-34"><a href="#cb18-34" aria-hidden="true" tabindex="-1"></a><span class="co">        seed : int &gt;= 0</span></span>
<span id="cb18-35"><a href="#cb18-35" aria-hidden="true" tabindex="-1"></a><span class="co">            initial state (should be smaller than modulus)</span></span>
<span id="cb18-36"><a href="#cb18-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-37"><a href="#cb18-37" aria-hidden="true" tabindex="-1"></a><span class="co">        maximum : float or int</span></span>
<span id="cb18-38"><a href="#cb18-38" aria-hidden="true" tabindex="-1"></a><span class="co">            maximum number of random numbers to be generated by PRNG</span></span>
<span id="cb18-39"><a href="#cb18-39" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb18-40"><a href="#cb18-40" aria-hidden="true" tabindex="-1"></a>        <span class="kw">def</span> check_int(i, lower<span class="op">=</span><span class="dv">0</span>, upper<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb18-41"><a href="#cb18-41" aria-hidden="true" tabindex="-1"></a>            valid <span class="op">=</span> <span class="bu">type</span>(i) <span class="kw">is</span> <span class="bu">int</span> <span class="kw">and</span> i <span class="op">&gt;=</span> lower</span>
<span id="cb18-42"><a href="#cb18-42" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> upper <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb18-43"><a href="#cb18-43" aria-hidden="true" tabindex="-1"></a>                valid <span class="op">&amp;=</span> i <span class="op">&lt;</span> upper</span>
<span id="cb18-44"><a href="#cb18-44" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> valid</span>
<span id="cb18-45"><a href="#cb18-45" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb18-46"><a href="#cb18-46" aria-hidden="true" tabindex="-1"></a>        msg <span class="op">=</span> <span class="st">'"</span><span class="sc">{0}</span><span class="st">" must be int &gt;= </span><span class="sc">{1}</span><span class="st">'</span></span>
<span id="cb18-47"><a href="#cb18-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">assert</span> check_int(m, <span class="dv">1</span>), msg.<span class="bu">format</span>(<span class="st">'m'</span>, <span class="dv">1</span>)</span>
<span id="cb18-48"><a href="#cb18-48" aria-hidden="true" tabindex="-1"></a>        <span class="cf">assert</span> check_int(a, <span class="dv">1</span>, m), msg.<span class="bu">format</span>(<span class="st">'a'</span>, <span class="dv">1</span>)</span>
<span id="cb18-49"><a href="#cb18-49" aria-hidden="true" tabindex="-1"></a>        <span class="cf">assert</span> check_int(c, <span class="dv">0</span>, m), msg.<span class="bu">format</span>(<span class="st">'c'</span>, <span class="dv">0</span>)</span>
<span id="cb18-50"><a href="#cb18-50" aria-hidden="true" tabindex="-1"></a>        <span class="cf">assert</span> check_int(seed, <span class="dv">0</span>, m), msg.<span class="bu">format</span>(<span class="st">'seed'</span>, <span class="dv">0</span>)</span>
<span id="cb18-51"><a href="#cb18-51" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb18-52"><a href="#cb18-52" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.a, <span class="va">self</span>.c, <span class="va">self</span>.m, <span class="va">self</span>.seed <span class="op">=</span> a, c, m, seed</span>
<span id="cb18-53"><a href="#cb18-53" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._max <span class="op">=</span> <span class="bu">int</span>(maximum)</span>
<span id="cb18-54"><a href="#cb18-54" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb18-55"><a href="#cb18-55" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._reset()</span>
<span id="cb18-56"><a href="#cb18-56" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb18-57"><a href="#cb18-57" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _reset(<span class="va">self</span>):        </span>
<span id="cb18-58"><a href="#cb18-58" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.x <span class="op">=</span> <span class="va">self</span>.seed</span>
<span id="cb18-59"><a href="#cb18-59" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._counter <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb18-60"><a href="#cb18-60" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb18-61"><a href="#cb18-61" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__next__</span>(<span class="va">self</span>):</span>
<span id="cb18-62"><a href="#cb18-62" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb18-63"><a href="#cb18-63" aria-hidden="true" tabindex="-1"></a><span class="co">        Using recurrence relation </span></span>
<span id="cb18-64"><a href="#cb18-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-65"><a href="#cb18-65" aria-hidden="true" tabindex="-1"></a><span class="co">            X_{n+1} = (a X_n + c) mod m</span></span>
<span id="cb18-66"><a href="#cb18-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-67"><a href="#cb18-67" aria-hidden="true" tabindex="-1"></a><span class="co">        to generate new random number</span></span>
<span id="cb18-68"><a href="#cb18-68" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb18-69"><a href="#cb18-69" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>._counter <span class="op">&gt;=</span> <span class="va">self</span>._max:</span>
<span id="cb18-70"><a href="#cb18-70" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">StopIteration</span></span>
<span id="cb18-71"><a href="#cb18-71" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb18-72"><a href="#cb18-72" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.x <span class="op">=</span> (<span class="va">self</span>.a <span class="op">*</span> <span class="va">self</span>.x <span class="op">+</span> <span class="va">self</span>.c) <span class="op">%</span> <span class="va">self</span>.m</span>
<span id="cb18-73"><a href="#cb18-73" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._counter <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb18-74"><a href="#cb18-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-75"><a href="#cb18-75" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.x</span>
<span id="cb18-76"><a href="#cb18-76" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb18-77"><a href="#cb18-77" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__iter__</span>(<span class="va">self</span>):</span>
<span id="cb18-78"><a href="#cb18-78" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._reset()</span>
<span id="cb18-79"><a href="#cb18-79" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span></span>
<span id="cb18-80"><a href="#cb18-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-81"><a href="#cb18-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-82"><a href="#cb18-82" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Uniform(PRNG):</span>
<span id="cb18-83"><a href="#cb18-83" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Pseudo-random numbers between 0 and 1. """</span></span>
<span id="cb18-84"><a href="#cb18-84" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__next__</span>(<span class="va">self</span>):</span>
<span id="cb18-85"><a href="#cb18-85" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">super</span>().<span class="fu">__next__</span>() <span class="op">/</span> <span class="bu">float</span>(<span class="va">self</span>.m)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The quality of a LCG depends on the choice of the four “magic numbers” <span class="math inline">\(a, c, m\)</span> and <span class="math inline">\(x^{(0)}\)</span>. Let us look at what happens for small periods <span class="math inline">\(m\)</span> (you can also do this with a nice <a href="https://demonstrations.wolfram.com/LinearCongruentialGenerators/">online app</a> and another <a href="https://demonstrations.wolfram.com/LinearCongruentialSequences/">app</a>). Let’s do it with our Python code:</p>
<div class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>prng <span class="op">=</span> PRNG(m<span class="op">=</span><span class="dv">181</span>, a<span class="op">=</span><span class="dv">40</span>, c<span class="op">=</span><span class="dv">0</span>, seed<span class="op">=</span><span class="dv">1</span>, maximum<span class="op">=</span><span class="dv">1000</span>)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.array(<span class="bu">list</span>(prng))</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> np.fft.fft(x)</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>kw <span class="op">=</span> <span class="bu">dict</span>(s<span class="op">=</span><span class="dv">40</span>, color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">3</span>))</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].scatter(np.arange(<span class="dv">100</span>), x[:<span class="dv">100</span>], <span class="op">**</span>kw)</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].plot(x[:<span class="dv">100</span>], color<span class="op">=</span><span class="st">'k'</span>, lw<span class="op">=</span><span class="dv">2</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_xlabel(<span class="vs">r'iteration $s$'</span>)</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_ylabel(<span class="vs">r'pseudo random number $x^{(s)}$'</span>)</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].scatter(x[:<span class="dv">100</span>], x[<span class="dv">1</span>:<span class="dv">101</span>], <span class="op">**</span>kw)</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlabel(<span class="vs">r'$x^{(s)}$'</span>)</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_ylabel(<span class="vs">r'$x^{(s+1)}$'</span>)</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].plot(np.<span class="bu">abs</span>(np.fft.fftshift(X))[<span class="dv">1</span>:<span class="bu">len</span>(x)<span class="op">//</span><span class="dv">2</span>], </span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>                  lw<span class="op">=</span><span class="dv">3</span>, color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].set_xlabel(<span class="st">'spatial frequency'</span>)</span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].set_ylabel(<span class="vs">r'spectrum $|FT|$'</span>)</span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-16-output-1.png" width="1140" height="278"></p>
</div>
</div>
<p>As shown in this simple example, LCGs can suffer from serious deficits and biases. A famous example is IBM’s <a href="https://en.wikipedia.org/wiki/RANDU">RANDU</a> algorithm, according to Donald Knuth a “truly horrible” algorithm. A whole array of <a href="https://en.wikipedia.org/wiki/Randomness_tests"><em>randomness tests</em></a> has been developed ever since. For example, in the <a href="https://en.wikipedia.org/wiki/Spectral_test">spectral test</a> successive random numbers are plotted against each other, thereby revealing nonrandom structures in the pseudo random number sequence.</p>
<div class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co"># LCG from Numerical Recipes</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>n_samples <span class="op">=</span> <span class="fl">1e5</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>prng <span class="op">=</span> PRNG(maximum<span class="op">=</span>n_samples)</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.array(<span class="bu">list</span>(prng))   </span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> x <span class="op">/</span> <span class="bu">float</span>(prng.m)</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>kw <span class="op">=</span> <span class="bu">dict</span>(s<span class="op">=</span><span class="dv">5</span>, color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.2</span>)</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">4</span>))</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].hist(u, bins<span class="op">=</span><span class="dv">100</span>, density<span class="op">=</span><span class="va">True</span>, color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.2</span>)</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].scatter(x[:<span class="dv">5000</span>], x[<span class="dv">1</span>:<span class="dv">5001</span>], <span class="op">**</span>kw)</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlabel(<span class="vs">r'$x^{(s)}$'</span>)</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_ylabel(<span class="vs">r'$x^{(s+1)}$'</span>)</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()    </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-17-output-1.png" width="758" height="374"></p>
</div>
</div>
</section>
</section>
<section id="sampling-a-discrete-model" class="level2">
<h2 class="anchored" data-anchor-id="sampling-a-discrete-model">Sampling a discrete model</h2>
<p>Assuming that we have a good source for pseudo random numbers, let us first look at how to use these for sampling a <em>discrete model</em>. The sample space is finite or countably infinite: <span class="math inline">\(\mathcal X = \{x_1, \ldots, x_N\}\)</span>, where <span class="math inline">\(N=\infty\)</span> is also possible. Without loss of generality we assume <span class="math inline">\(p_i&gt;0\)</span> (zero-probability states are excluded from the sample space).</p>
<p>How can we use uniform random numbers from <span class="math inline">\([0, 1]\)</span> to generate samples from <span class="math inline">\(p\)</span>? For given <span class="math inline">\(u\sim \mathcal U(0,1)\)</span> pick state <span class="math inline">\(i\in[N]\)</span> such that</p>
<p><span id="eq-discrete_sampling"><span class="math display">\[
    i = \min\bigl\{j \in\mathbb N\, :\, \sum_{k=1}^j p_k \ge u  \bigr\}
\tag{15}\]</span></span></p>
<p>Here and in the following <span class="math inline">\(\mathcal U(0,1)\)</span> denotes the uniform distribution over the unit interval, i.e.&nbsp;<span class="math inline">\(x\sim U(0,1)\)</span> has density <span class="math inline">\(p(x) = \mathbb 1(0 &lt; x &lt; 1)\)</span>.</p>
<p>Why is this procedure correct? Let us call <span class="math inline">\(c_i = \sum_{k=1}^i p_k\)</span>, then <span class="math inline">\(c_1 = p_1 &gt; 0\)</span> and <span class="math inline">\(c_N = 1\)</span>. Moreover, define <span class="math inline">\(c_0:= 0\)</span>. All <span class="math inline">\(c_i\in(0,1]\)</span> (except <span class="math inline">\(c_0\)</span>) and sorted <span class="math inline">\(c_{i-1} &lt; c_i\)</span> (since all <span class="math inline">\(p_i&gt;0\)</span>). So the intervals <span class="math inline">\(I_i=[c_{i-1}, c_i)\)</span> form a partition of <span class="math inline">\([0,1)\)</span> and the uniform distribution <span class="math inline">\(\mathbb 1\bigl(x\in[0,1)\bigr)\)</span> can be written as a mixture of uniform distributions:</p>
<p><span class="math display">\[
\mathbb 1\bigl(x\in[0,1)\bigr) = \sum_{i=1}^{N} \mathbb 1\bigl(x\in[c_{i-1}, c_{i})\bigr)
\]</span></p>
<p>Criterion (Eq. <a href="#eq-discrete_sampling">Equation&nbsp;15</a>) picks the interval with <span class="math inline">\(u\in[c_{i-1}, c_{i})=:I_i\)</span>. The length of each interval <span class="math inline">\(I_i\)</span> is <span class="math inline">\(c_i - c_{i-1} = p_i\)</span>, and equal to the chance of landing in <span class="math inline">\(I_i\)</span>. Therefor the generated <span class="math inline">\(x_i\)</span> will follow <span class="math inline">\(p\)</span>.</p>
<div class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co"># illustration discrete sampling</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> np.random.random(N)</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>p <span class="op">/=</span> p.<span class="bu">sum</span>()</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> np.arange(N<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> np.append(<span class="fl">0.</span>, np.add.accumulate(p))</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>ax.barh(i, c, color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="vs">r'$i$'</span>, fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>ax.set_xticks(c)</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>ax.set_xticklabels([<span class="vs">r'$c_</span><span class="sc">{{{}}}</span><span class="vs">$'</span>.<span class="bu">format</span>(ii) <span class="cf">for</span> ii <span class="kw">in</span> i])</span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> cc <span class="kw">in</span> c:</span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>    ax.axvline(cc, ls<span class="op">=</span><span class="st">'--'</span>, color<span class="op">=</span><span class="st">'r'</span>, lw<span class="op">=</span><span class="dv">2</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-18-output-1.png" width="951" height="566"></p>
</div>
</div>
<section id="sampling-from-the-poisson-distribution" class="level3">
<h3 class="anchored" data-anchor-id="sampling-from-the-poisson-distribution">Sampling from the Poisson distribution</h3>
<p>The Poisson distribution is a pmf over the sample space <span class="math inline">\(\mathbb N\)</span>, i.e.&nbsp;<span class="math inline">\(x=0, 1, 2, \ldots\)</span> and defined as</p>
<p><span id="eq-poisson"><span class="math display">\[
p(x) = \frac{\lambda^x}{x!} e^{-\lambda}, \,\,\, \lambda &gt; 0
\tag{16}\]</span></span></p>
<p>the parameter <span class="math inline">\(\lambda\)</span> is called <em>rate</em>. The mean and variance of <span class="math inline">\(x\)</span> are</p>
<p><span class="math display">\[
\mathbb E[x] = \lambda, \,\,\, \text{var}[x] = \lambda\,.
\]</span></p>
<div class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Sampling from the Poisson distribution</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="co"># - this is how it's *not* done in practice -</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.special <span class="im">import</span> gammaln</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sample_poisson(S, rate<span class="op">=</span><span class="fl">1.</span>, return_cdf<span class="op">=</span><span class="va">True</span>):</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a><span class="co">    S : number of samples</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a><span class="co">    rate : rate of Poisson distribution</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># uniform random numbers</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>    u <span class="op">=</span> np.random.random(<span class="bu">int</span>(S))</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> np.argsort(u)</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># array storing samples</span></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> <span class="op">-</span>np.ones(u.shape, dtype<span class="op">=</span><span class="st">'i'</span>)</span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># building up cdf</span></span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>    cdf <span class="op">=</span> [<span class="fl">0.</span>]</span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># stepping through sorted list of uniform random numbers</span></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v, j <span class="kw">in</span> <span class="bu">zip</span>(u[i], i):</span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> v <span class="op">&gt;</span> cdf[k]:</span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a>            k <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a>            pmf <span class="op">=</span> np.exp(k <span class="op">*</span> np.log(rate) <span class="op">-</span> rate <span class="op">-</span> gammaln(k<span class="op">+</span><span class="dv">1</span>))</span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a>            cdf.append(cdf[<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> pmf)</span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a>        x[j] <span class="op">=</span> k</span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> return_cdf:</span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> x, np.array(cdf)</span>
<span id="cb22-33"><a href="#cb22-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x</span>
<span id="cb22-34"><a href="#cb22-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-35"><a href="#cb22-35" aria-hidden="true" tabindex="-1"></a>rate <span class="op">=</span> <span class="fl">10.</span></span>
<span id="cb22-36"><a href="#cb22-36" aria-hidden="true" tabindex="-1"></a>limits <span class="op">=</span> <span class="fl">0.</span>, <span class="dv">10</span> <span class="op">*</span> rate<span class="op">**</span><span class="fl">0.5</span></span>
<span id="cb22-37"><a href="#cb22-37" aria-hidden="true" tabindex="-1"></a>x, cdf <span class="op">=</span> sample_poisson(<span class="fl">1e3</span>, rate)</span>
<span id="cb22-38"><a href="#cb22-38" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> np.arange(<span class="bu">len</span>(cdf))</span>
<span id="cb22-39"><a href="#cb22-39" aria-hidden="true" tabindex="-1"></a>pmf <span class="op">=</span> np.exp(k <span class="op">*</span> np.log(rate) <span class="op">-</span> rate <span class="op">-</span> gammaln(k<span class="op">+</span><span class="dv">1</span>))</span>
<span id="cb22-40"><a href="#cb22-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-41"><a href="#cb22-41" aria-hidden="true" tabindex="-1"></a>bins, hist <span class="op">=</span> np.unique(x, return_counts<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb22-42"><a href="#cb22-42" aria-hidden="true" tabindex="-1"></a>hist <span class="op">=</span> hist.astype(<span class="st">'d'</span>) <span class="op">/</span> hist.<span class="bu">sum</span>()</span>
<span id="cb22-43"><a href="#cb22-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-44"><a href="#cb22-44" aria-hidden="true" tabindex="-1"></a>settings <span class="op">=</span> <span class="bu">dict</span>(xlim<span class="op">=</span>limits, xlabel<span class="op">=</span><span class="vs">r'bin $i$'</span>)</span>
<span id="cb22-45"><a href="#cb22-45" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">4</span>), subplot_kw<span class="op">=</span>settings)</span>
<span id="cb22-46"><a href="#cb22-46" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].plot(k, pmf, color<span class="op">=</span><span class="st">'r'</span>, lw<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb22-47"><a href="#cb22-47" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].bar(k, cdf, color<span class="op">=</span><span class="st">'lightgrey'</span>)</span>
<span id="cb22-48"><a href="#cb22-48" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_ylabel(<span class="vs">r'cdf $\sum_{k=1}^i\, p_k$'</span>)</span>
<span id="cb22-49"><a href="#cb22-49" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].bar(bins, hist, color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.2</span>)</span>
<span id="cb22-50"><a href="#cb22-50" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].plot(k, pmf, color<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb22-51"><a href="#cb22-51" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-19-output-1.png" width="758" height="373"></p>
</div>
</div>
</section>
</section>
<section id="variable-transformation-methods" class="level2">
<h2 class="anchored" data-anchor-id="variable-transformation-methods">Variable transformation methods</h2>
<p>We will now move on to continuous sample spaces. Assuming that we can generate uniform random samples from <span class="math inline">\(\mathcal U(0, 1)\)</span>, how can we use these samples to generate samples from a non-uniform distribution <span class="math inline">\(p(x)\)</span>? In the last section we saw how to do this for pmfs (although it might not be practical for large finite models such as Ising models).</p>
<p>Let’s first look at the simplest version of sampling from a pdf where the sample space is one-dimensional. So we are looking for ways of how to transform a single uniformly distributed variable <span class="math inline">\(u \sim \mathcal U(0, 1)\)</span> to <span class="math inline">\(x \sim p(x)\)</span>. To design such as method, we first need to understand how probability distributions transform under parameter transformations.</p>
<section id="transformation-of-probability-distributions" class="level3">
<h3 class="anchored" data-anchor-id="transformation-of-probability-distributions">Transformation of probability distributions</h3>
<p>Let <span class="math inline">\(h\)</span> be a <em>one-to-one mapping</em> between two one-dimensional sample spaces <span class="math inline">\(h: \mathcal X \to \mathcal Y\)</span>, and <span class="math inline">\(h^{-1}\)</span> is the inverse function. If <span class="math inline">\(x\sim p_x(x)\)</span>, what is the distribution <span class="math inline">\(p_y(y)\)</span> of <span class="math inline">\(y=h(x)\)</span>? To answer this question let us compute the distribution <span class="math inline">\(p_y\)</span>:</p>
<p><span id="eq-transform1d"><span class="math display">\[
p_y(y) = \int_{\mathcal X} \delta(y - h(x))\, p_x(x)\, dx = \int_{\mathcal X} \frac{1}{|h'(x)|} \delta(x - h^{-1}(y))\, p_x(x)\, dx = \frac{p_x(h^{-1}(y))}{|h'(h^{-1}(y))|}
\tag{17}\]</span></span></p>
<p>where we used the transformation property of the <a href="https://en.wikipedia.org/wiki/Dirac_delta_function#Composition_with_a_function">delta distribution</a>. The transformation rule guarantees that normalized pdfs transform into normalized pdfs.</p>
<p>This result can be generalized to multiple dimensions. Let <span class="math inline">\(h\)</span> be an invertible one-to-one mapping between two <span class="math inline">\(D\)</span> dimensional sample spaces. Assume further that <span class="math inline">\(h\)</span> is continuously differentiable such that the Jacobian</p>
<p><span class="math display">\[
\nabla h(x) = \left(\frac{\partial h_i(x)}{\partial x_j} \right)_{i,j}
\]</span></p>
<p>is everywhere invertible in <span class="math inline">\(\mathcal X\)</span>, i.e.&nbsp;<span class="math inline">\(\text{det}(\nabla h(x)) \not= 0\)</span> for all <span class="math inline">\(x\in \mathcal X\)</span>. Then <span class="math inline">\(y=h(x)\)</span> has density</p>
<p><span class="math display">\[
p_y(y) = \left\{ \begin{array}{c c}
p_x(h^{-1}(y)) \, |\text{det}(\nabla h^{-1})(y)|, &amp; y \in h(\mathcal X) \\
0, &amp; y \notin h(\mathcal X)
\end{array}\right.
\]</span></p>
</section>
<section id="inversion-method" class="level3">
<h3 class="anchored" data-anchor-id="inversion-method">Inversion method</h3>
<p>The <a href="https://en.wikipedia.org/wiki/Inverse_transform_sampling"><em>inversion method</em></a> is a simple variable transformation method. Let <span class="math inline">\(p(x)\)</span> be a pdf over a sample space <span class="math inline">\(\mathcal X \subset \mathbb R\)</span>, then the <a href="https://en.wikipedia.org/wiki/Cumulative_distribution_function"><em>cumulative distribution function</em> (cdf)</a> is:</p>
<p><span id="eq-cdf"><span class="math display">\[
P(y) = \Pr(x \le y) = \mathbb E_p[x \le y] = \int^y_{-\infty} p(x)\, dx
\tag{18}\]</span></span></p>
<p>this is the continuous analog of <span class="math inline">\(c_i\)</span> defined above in the section on sampling discrete models. By construction, <span class="math inline">\(P(x) \in [0, 1]\)</span> for <span class="math inline">\(x \in\mathcal X\)</span>. <span class="math inline">\(P(x)\)</span> is continuous and strictly increasing and therefore invertible. Inverse transform sampling uses the following mathematical fact:</p>
<p><span id="eq-inversion_method"><span class="math display">\[
x = P^{-1}(u) \sim p(x)\,\,\,\text{for}\,\,\, u\sim\mathcal U(0,1)
\tag{19}\]</span></span></p>
<p>That is, we can generate random samples from <span class="math inline">\(p(x)\)</span> by generating uniformly distributed random numbers in <span class="math inline">\([0, 1]\)</span> and map them to <span class="math inline">\(\mathcal X\)</span> with the inverse of the cdf <span class="math inline">\(P^{-1}\)</span>.</p>
<p>To see that this is a valid sampling procedure, let us compute the distribution of <span class="math inline">\(x=P^{-1}(u)\)</span> using the transformation rule (Eq. <a href="#eq-transform1d">Equation&nbsp;17</a>): We have</p>
<p><span class="math display">\[
\frac{d\, P^{-1}(u)}{d\, u} = \frac{1}{P'(P^{-1}(u))} = \frac{1}{p(P^{-1}(u))}
\]</span></p>
<p>Plugging this expression into (Eq. <a href="#eq-transform1d">Equation&nbsp;17</a>) yields</p>
<p><span class="math display">\[
p_x(x) = \frac{p_u(P(x))}{(P^{-1})'(P(x))} = \frac{1}{1 / p(x)} = p(x)
\]</span></p>
<p><em>Example</em>: Let us apply inverse transformation sampling to the exponential distribution</p>
<p><span class="math display">\[
p(x) = \lambda \, \exp\{-\lambda x\}, \,\,\, \lambda &gt; 0, \, \mathcal X = \mathbb R_+
\]</span></p>
<p>The cumulative distribution function is</p>
<p><span class="math display">\[
\text{cdf}(x) = \int^x_0 \lambda e^{-\lambda t} \, dt = 1 - e^{-\lambda x}
\]</span></p>
<p>and its inverse:</p>
<p><span class="math display">\[
\text{cdf}^{-1}(u) = - \frac{1}{\lambda} \log(1-u)
\]</span></p>
<p>Since <span class="math inline">\(1-u \sim \mathcal U(0,1)\)</span> if <span class="math inline">\(u \sim \mathcal U(0,1)\)</span>, we can generate exponentially distributed random variables as follows:</p>
<p><span class="math display">\[
x^{(s)} = - \frac{\log u^{(s)}}{\lambda}, \,\,\, u^{(s)} \sim \mathcal U(0,1)
\]</span></p>
<p>Some more examples:</p>
<table class="table">
<thead>
<tr class="header">
<th>name</th>
<th>pdf <span class="math inline">\(p(x)\)</span></th>
<th>cdf <span class="math inline">\(P(x)\)</span></th>
<th>inversion</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="https://en.wikipedia.org/wiki/Exponential_distribution">Exponential</a></td>
<td><span class="math inline">\(\lambda e^{-\lambda x}\)</span></td>
<td><span class="math inline">\(1 - e^{-\lambda x}\)</span></td>
<td><span class="math inline">\(-\log(u)/\lambda\)</span></td>
</tr>
<tr class="even">
<td><a href="https://en.wikipedia.org/wiki/Cauchy_distribution">Cauchy</a></td>
<td><span class="math inline">\(\frac{\sigma}{\pi(x^2 + \sigma^2)}\)</span></td>
<td><span class="math inline">\(\frac{1}{2} + \frac{1}{\pi} \arctan(x/\sigma)\)</span></td>
<td><span class="math inline">\(-\sigma\tan(\pi(u-0.5))\)</span></td>
</tr>
<tr class="odd">
<td><a href="https://en.wikipedia.org/wiki/Rayleigh_distribution">Rayleigh</a></td>
<td><span class="math inline">\(\frac{x}{\sigma^2} e^{-x^2/2\sigma^2}\)</span></td>
<td><span class="math inline">\(1- e^{-x^2/2\sigma^2}\)</span></td>
<td><span class="math inline">\(\sigma\,\sqrt{-2\log u}\)</span></td>
</tr>
<tr class="even">
<td>Triangular</td>
<td><span class="math inline">\(2 (1 - x/a)/a, \, x\in[0,a]\)</span></td>
<td><span class="math inline">\(2 (x - x^2/2a)\)</span></td>
<td><span class="math inline">\(a(1-\sqrt{u})\)</span></td>
</tr>
<tr class="odd">
<td><a href="https://en.wikipedia.org/wiki/Pareto_distribution">Pareto</a></td>
<td><span class="math inline">\(a\,b^a / x^{a+1}, \, x\ge b\)</span></td>
<td><span class="math inline">\(1-(b/x)^a\)</span></td>
<td><span class="math inline">\(b\, u^{-1/a}\)</span></td>
</tr>
</tbody>
</table>
<div class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co"># some examples</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> PDF:</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, <span class="op">**</span>params):</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> name, value <span class="kw">in</span> params.items():</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>            <span class="bu">setattr</span>(<span class="va">self</span>, name, <span class="bu">float</span>(value))</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> sample(<span class="va">self</span>, n<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>        u <span class="op">=</span> np.random.random(<span class="bu">int</span>(n))</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>._invert(u)</span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(<span class="va">self</span>):</span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">pass</span></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _invert(<span class="va">self</span>, u):</span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">pass</span></span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Exponential(PDF):</span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, _lambda<span class="op">=</span><span class="fl">1.</span>):</span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>(_lambda<span class="op">=</span>_lambda)</span>
<span id="cb23-24"><a href="#cb23-24" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb23-25"><a href="#cb23-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(<span class="va">self</span>, x):</span>
<span id="cb23-26"><a href="#cb23-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>._lambda <span class="op">*</span> np.exp(<span class="op">-</span><span class="va">self</span>._lambda<span class="op">*</span>x)</span>
<span id="cb23-27"><a href="#cb23-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb23-28"><a href="#cb23-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _invert(<span class="va">self</span>, u):</span>
<span id="cb23-29"><a href="#cb23-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">-</span>np.log(u)<span class="op">/</span><span class="va">self</span>._lambda</span>
<span id="cb23-30"><a href="#cb23-30" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb23-31"><a href="#cb23-31" aria-hidden="true" tabindex="-1"></a>    <span class="at">@property</span></span>
<span id="cb23-32"><a href="#cb23-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> support(<span class="va">self</span>):</span>
<span id="cb23-33"><a href="#cb23-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="fl">0.</span>, <span class="dv">5</span> <span class="op">/</span> <span class="va">self</span>._lambda</span>
<span id="cb23-34"><a href="#cb23-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-35"><a href="#cb23-35" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb23-36"><a href="#cb23-36" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Cauchy(PDF):</span>
<span id="cb23-37"><a href="#cb23-37" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb23-38"><a href="#cb23-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, sigma<span class="op">=</span><span class="fl">1.</span>):</span>
<span id="cb23-39"><a href="#cb23-39" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>(sigma<span class="op">=</span>sigma)</span>
<span id="cb23-40"><a href="#cb23-40" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb23-41"><a href="#cb23-41" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(<span class="va">self</span>, x):</span>
<span id="cb23-42"><a href="#cb23-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.sigma <span class="op">/</span> np.pi <span class="op">/</span> (x<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> <span class="va">self</span>.sigma<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb23-43"><a href="#cb23-43" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb23-44"><a href="#cb23-44" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _invert(<span class="va">self</span>, u):</span>
<span id="cb23-45"><a href="#cb23-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.sigma <span class="op">*</span> np.tan(np.pi<span class="op">*</span>(u<span class="op">-</span><span class="fl">0.5</span>))</span>
<span id="cb23-46"><a href="#cb23-46" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb23-47"><a href="#cb23-47" aria-hidden="true" tabindex="-1"></a>    <span class="at">@property</span></span>
<span id="cb23-48"><a href="#cb23-48" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> support(<span class="va">self</span>):</span>
<span id="cb23-49"><a href="#cb23-49" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">-</span><span class="fl">10.</span>, <span class="op">+</span><span class="fl">10.</span></span>
<span id="cb23-50"><a href="#cb23-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-51"><a href="#cb23-51" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb23-52"><a href="#cb23-52" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Rayleigh(PDF):</span>
<span id="cb23-53"><a href="#cb23-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-54"><a href="#cb23-54" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, sigma<span class="op">=</span><span class="fl">1.</span>):</span>
<span id="cb23-55"><a href="#cb23-55" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>(sigma<span class="op">=</span>sigma)</span>
<span id="cb23-56"><a href="#cb23-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-57"><a href="#cb23-57" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(<span class="va">self</span>, x):</span>
<span id="cb23-58"><a href="#cb23-58" aria-hidden="true" tabindex="-1"></a>        t <span class="op">=</span> (x<span class="op">/</span><span class="va">self</span>.sigma)</span>
<span id="cb23-59"><a href="#cb23-59" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> t <span class="op">*</span> np.exp(<span class="op">-</span><span class="fl">0.5</span><span class="op">*</span>t<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> <span class="va">self</span>.sigma</span>
<span id="cb23-60"><a href="#cb23-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-61"><a href="#cb23-61" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _invert(<span class="va">self</span>, u):</span>
<span id="cb23-62"><a href="#cb23-62" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.sigma <span class="op">*</span> np.sqrt(<span class="op">-</span><span class="dv">2</span><span class="op">*</span>np.log(u))</span>
<span id="cb23-63"><a href="#cb23-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-64"><a href="#cb23-64" aria-hidden="true" tabindex="-1"></a>    <span class="at">@property</span></span>
<span id="cb23-65"><a href="#cb23-65" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> support(<span class="va">self</span>):</span>
<span id="cb23-66"><a href="#cb23-66" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="fl">0.</span>, <span class="dv">5</span> <span class="op">*</span> <span class="va">self</span>.sigma</span>
<span id="cb23-67"><a href="#cb23-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-68"><a href="#cb23-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-69"><a href="#cb23-69" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Triangular(PDF):</span>
<span id="cb23-70"><a href="#cb23-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-71"><a href="#cb23-71" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, a<span class="op">=</span><span class="fl">1.</span>):</span>
<span id="cb23-72"><a href="#cb23-72" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>(a<span class="op">=</span>a)</span>
<span id="cb23-73"><a href="#cb23-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-74"><a href="#cb23-74" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(<span class="va">self</span>, x):</span>
<span id="cb23-75"><a href="#cb23-75" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">2</span> <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> x<span class="op">/</span><span class="va">self</span>.a) <span class="op">/</span> <span class="va">self</span>.a</span>
<span id="cb23-76"><a href="#cb23-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-77"><a href="#cb23-77" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _invert(<span class="va">self</span>, u):</span>
<span id="cb23-78"><a href="#cb23-78" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.a <span class="op">*</span> (<span class="dv">1</span><span class="op">-</span>np.sqrt(u))</span>
<span id="cb23-79"><a href="#cb23-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-80"><a href="#cb23-80" aria-hidden="true" tabindex="-1"></a>    <span class="at">@property</span></span>
<span id="cb23-81"><a href="#cb23-81" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> support(<span class="va">self</span>):</span>
<span id="cb23-82"><a href="#cb23-82" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="fl">0.</span>, <span class="va">self</span>.a</span>
<span id="cb23-83"><a href="#cb23-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-84"><a href="#cb23-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-85"><a href="#cb23-85" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Pareto(PDF):</span>
<span id="cb23-86"><a href="#cb23-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-87"><a href="#cb23-87" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, a<span class="op">=</span><span class="fl">1.</span>, b<span class="op">=</span><span class="fl">1.</span>):</span>
<span id="cb23-88"><a href="#cb23-88" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>(a<span class="op">=</span>a, b<span class="op">=</span>b)</span>
<span id="cb23-89"><a href="#cb23-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-90"><a href="#cb23-90" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(<span class="va">self</span>, x):</span>
<span id="cb23-91"><a href="#cb23-91" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.a <span class="op">*</span> <span class="va">self</span>.b<span class="op">**</span><span class="va">self</span>.a <span class="op">/</span> (x<span class="op">**</span>(<span class="va">self</span>.a<span class="op">+</span><span class="dv">1</span>) <span class="op">+</span> <span class="fl">1e-100</span>) <span class="op">*</span> (x<span class="op">&gt;=</span><span class="va">self</span>.b)</span>
<span id="cb23-92"><a href="#cb23-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-93"><a href="#cb23-93" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _invert(<span class="va">self</span>, u):</span>
<span id="cb23-94"><a href="#cb23-94" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.b <span class="op">/</span> u<span class="op">**</span>(<span class="dv">1</span><span class="op">/</span><span class="va">self</span>.a)</span>
<span id="cb23-95"><a href="#cb23-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-96"><a href="#cb23-96" aria-hidden="true" tabindex="-1"></a>    <span class="at">@property</span></span>
<span id="cb23-97"><a href="#cb23-97" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> support(<span class="va">self</span>):</span>
<span id="cb23-98"><a href="#cb23-98" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="fl">0.</span>, <span class="dv">10</span> <span class="op">*</span> <span class="va">self</span>.b</span>
<span id="cb23-99"><a href="#cb23-99" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.b, <span class="dv">10</span> <span class="op">*</span> <span class="va">self</span>.b</span>
<span id="cb23-100"><a href="#cb23-100" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb23-101"><a href="#cb23-101" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb23-102"><a href="#cb23-102" aria-hidden="true" tabindex="-1"></a>pdfs <span class="op">=</span> [Exponential(_lambda<span class="op">=</span><span class="fl">0.5</span>), Cauchy(), Rayleigh(sigma<span class="op">=</span><span class="fl">2.</span>),</span>
<span id="cb23-103"><a href="#cb23-103" aria-hidden="true" tabindex="-1"></a>        Triangular(a<span class="op">=</span><span class="fl">2.</span>), Pareto()]</span>
<span id="cb23-104"><a href="#cb23-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-105"><a href="#cb23-105" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> <span class="bu">int</span>(<span class="fl">1e4</span>)</span>
<span id="cb23-106"><a href="#cb23-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-107"><a href="#cb23-107" aria-hidden="true" tabindex="-1"></a>kw <span class="op">=</span> <span class="bu">dict</span>(bins<span class="op">=</span><span class="dv">20</span>, color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.1</span>, density<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb23-108"><a href="#cb23-108" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="bu">len</span>(pdfs), figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">3</span>))</span>
<span id="cb23-109"><a href="#cb23-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-110"><a href="#cb23-110" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> a, pdf <span class="kw">in</span> <span class="bu">zip</span>(ax, pdfs):</span>
<span id="cb23-111"><a href="#cb23-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-112"><a href="#cb23-112" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> np.linspace(<span class="op">*</span>(pdf.support <span class="op">+</span> (<span class="dv">1000</span>,)))</span>
<span id="cb23-113"><a href="#cb23-113" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> pdf.sample(S)</span>
<span id="cb23-114"><a href="#cb23-114" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> y[(y <span class="op">&gt;</span> x.<span class="bu">min</span>()) <span class="op">&amp;</span> (y <span class="op">&lt;</span> x.<span class="bu">max</span>())]</span>
<span id="cb23-115"><a href="#cb23-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-116"><a href="#cb23-116" aria-hidden="true" tabindex="-1"></a>    a.set_title(pdf.__class__.<span class="va">__name__</span>)</span>
<span id="cb23-117"><a href="#cb23-117" aria-hidden="true" tabindex="-1"></a>    a.plot(x, pdf(x), lw<span class="op">=</span><span class="dv">2</span>, color<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb23-118"><a href="#cb23-118" aria-hidden="true" tabindex="-1"></a>    a.hist(y, <span class="op">**</span>kw)</span>
<span id="cb23-119"><a href="#cb23-119" aria-hidden="true" tabindex="-1"></a>    a.set_xlim(<span class="op">*</span>pdf.support)</span>
<span id="cb23-120"><a href="#cb23-120" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb23-121"><a href="#cb23-121" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-20-output-1.png" width="1148" height="278"></p>
</div>
</div>
<p>In principle, the inverse transformation approach (Eq. <a href="#eq-inversion_method">Equation&nbsp;19</a>) generalizes to multiple dimensions (see, for example, Murray Rosenblatt: <a href="https://www.jstor.org/stable/2236692?seq=1#metadata_info_tab_contents">Remarks on a Multivariate Transformation</a>):</p>
<p><span id="eq-multivariate_transform"><span class="math display">\[
%
\begin{aligned}
    P_1(x_1') &amp;= \Pr(x_1 &lt; x_1') = \int \mathbb 1(x_1 \le x_1')\, p(x_1, \ldots, x_D)\, dx_1 \cdots dx_D \\
    %
    P_2(x_2'\mid{}x_1) &amp;= \Pr(x_2 &lt; x_2' \mid{}x_1) = \int \mathbb 1(x_2 \le x_2')\, p(x_2, \ldots, x_D\mid{}x_1)\, dx_2 \cdots dx_D \\
    &amp;\vdots  \\
    P_D(x_D'\mid{}x_{D-1}, \ldots, x_{1}) &amp;= \Pr(x_D &lt; x_D'\mid{}x_{D-1}, \ldots, x_{1}) = \int \mathbb 1(x_D \le x_D')\, p(x_D\mid{}x_{D-1}, \ldots, x_{1})\, dx_D
\end{aligned}
\tag{20}\]</span></span></p>
<p>However, only in very rare cases is it possible to compute the multivariate cumulative distribution function in higher dimensional spaces, let alone invert it in closed form.</p>
<p>So this expression is mostly of theoretical interest to us. Nevertheless, it is curious to see that multivariate pdfs can in principle be mapped to a uniform distributions over the hypercube:</p>
<p><span class="math display">\[
u_i = P_i(x_i\mid{}x_{i-1}, \ldots x_{1}), \,\,\, i=1, \ldots, D
\]</span></p>
<p>By construction <span class="math inline">\(u=(u_1, \ldots, u_D) \in [0, 1]^D\)</span>, and the pdf of <span class="math inline">\(u\)</span> is</p>
<p><span class="math display">\[
p_u(u) = p_x(x(u)) \prod_i \biggl|\frac{d u_i}{d x_i}\biggr|^{-1} = 1
\]</span></p>
<p>since the Jacobian matrix is triagonal (so its determinant is just a product over the diagonal elements) and</p>
<p><span class="math display">\[
p(x_1, \ldots, x_D) = p(x_D \mid{} x_{D-1}, \ldots, x_{1}) \cdots p(x_2\mid{}x_1) \, p(x_1)
\]</span></p>
</section>
<section id="variable-transformation-method" class="level3">
<h3 class="anchored" data-anchor-id="variable-transformation-method">Variable transformation method</h3>
<p>Sometimes one can find a transformation of the sample space such that the new distribution is easier to sample. A specific example is the <a href="https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform">Box-Muller method</a> for generating samples from a standard Gaussian distribution:</p>
<p><span class="math display">\[
p(x) = \frac{1}{\sqrt{2\pi}} \exp\bigl\{-x^2/2\bigr\}
\]</span></p>
<p>where <span class="math inline">\(x \in \mathbb R\)</span>. The first trick is to make the problem seemingly more complicated by transforming it to a two-dimensional distribution by introducing <span class="math inline">\(y\)</span> which also follows a standard Gaussian distribution. That is,</p>
<p><span class="math display">\[
p(x,y) = \frac{1}{2\pi} \exp\bigl\{-(x^2+y^2)/2 \bigr\}\, .
\]</span></p>
<p>Because <span class="math inline">\(p(x, y)\)</span> depends on <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> only through their distance from the origin <span class="math inline">\(r = \sqrt{x^2 + y^2}\)</span>, it makes sense to transform <span class="math inline">\((x, y)\)</span> to <a href="https://en.wikipedia.org/wiki/Polar_coordinate_system">polar coordinates</a>:</p>
<p><span class="math display">\[
\begin{pmatrix} x \\ y \end{pmatrix} =
\begin{pmatrix} r\cos\varphi \\ r\sin\varphi \end{pmatrix}
\]</span></p>
<p>with the new sample space <span class="math inline">\([0, \infty) \times [0, 2\pi]\)</span>. The Jacobian of the parameter transformation is</p>
<p><span class="math display">\[
\frac{\partial (x, y)}{\partial (r, \varphi)} =
\begin{pmatrix}
    \cos\varphi &amp; -r\sin\varphi \\
    \sin\varphi &amp; r\cos\varphi \\
\end{pmatrix}
\]</span></p>
<p>with determinant <span class="math display">\[
\left|\frac{\partial (x, y)}{\partial (r, \varphi)}\right| = r
\]</span></p>
<p>Therefore,</p>
<p><span class="math display">\[
p(r, \varphi) = \frac{r}{2\pi} e^{-r^2/2} = p(r)\, p(\varphi)
\]</span></p>
<p>with <span class="math inline">\(p(\varphi) = \frac{1}{2\pi} \mathbb 1\bigl(\varphi\in[0, 2\pi]\bigr)\)</span>.</p>
<p>The cdf of <span class="math inline">\(p(r)\)</span> is <span class="math display">\[
\int_0^r t e^{-t^2/2}\, dt = e^{-t^2/2} \biggl|_r^0 \biggr. = 1 - e^{-r^2/2}
\]</span></p>
<p>We can obtain a random sample from <span class="math inline">\(p(x, y)\)</span> by first generating two uniform random numbers <span class="math inline">\(u, v \in \mathcal U(0,1)\)</span> and then letting <span class="math inline">\(r = \sqrt{-2\log(1 - u)}\)</span> and <span class="math inline">\(\varphi=2\pi v\)</span> from which we obtain:</p>
<p><span class="math display">\[
x = \sqrt{-2\log(u)}\cos(2\pi v),\,\,\,
y = \sqrt{-2\log(u)}\sin(2\pi v)
\]</span></p>
<p>where we used the fact that <span class="math inline">\(1-u \in\mathcal U(0,1)\)</span> if <span class="math inline">\(u\in \mathcal U(0,1)\)</span>.</p>
<div class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Box Muller method</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sample_gaussian(S):</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Sample standard Gaussian distribution using Box-Muller </span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    u, v <span class="op">=</span> np.random.random(size<span class="op">=</span>(<span class="dv">2</span>, <span class="bu">int</span>(S)))</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> np.sqrt(<span class="op">-</span><span class="dv">2</span><span class="op">*</span>np.log(u))</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>    phi <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> np.pi <span class="op">*</span> v</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> r <span class="op">*</span> np.cos(phi), r <span class="op">*</span> np.sin(phi)</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> <span class="fl">1e4</span></span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>x, y <span class="op">=</span> sample_gaussian(S)</span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.linspace(<span class="op">-</span><span class="fl">1.</span>, <span class="fl">1.</span>, <span class="dv">1000</span>) <span class="op">*</span> <span class="dv">5</span></span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> np.exp(<span class="op">-</span><span class="fl">0.5</span><span class="op">*</span>t<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> np.sqrt(<span class="dv">2</span><span class="op">*</span>np.pi)</span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a>kw <span class="op">=</span> <span class="bu">dict</span>(bins<span class="op">=</span><span class="dv">100</span>, color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.2</span>, density<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">4</span>), </span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true" tabindex="-1"></a>                       subplot_kw<span class="op">=</span><span class="bu">dict</span>(yticks<span class="op">=</span>[<span class="fl">0.</span>, <span class="fl">0.1</span>, <span class="fl">0.2</span>, <span class="fl">0.3</span>, <span class="fl">0.4</span>]))</span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].hist(x, <span class="op">**</span>kw)</span>
<span id="cb24-23"><a href="#cb24-23" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_xlabel(<span class="vs">r'$x$'</span>)</span>
<span id="cb24-24"><a href="#cb24-24" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].hist(y, <span class="op">**</span>kw)</span>
<span id="cb24-25"><a href="#cb24-25" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlabel(<span class="vs">r'$y$'</span>)</span>
<span id="cb24-26"><a href="#cb24-26" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> a <span class="kw">in</span> ax:</span>
<span id="cb24-27"><a href="#cb24-27" aria-hidden="true" tabindex="-1"></a>    a.plot(t, p, lw<span class="op">=</span><span class="dv">3</span>, alpha<span class="op">=</span><span class="fl">0.5</span>, color<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb24-28"><a href="#cb24-28" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-21-output-1.png" width="758" height="373"></p>
</div>
</div>
</section>
<section id="multivariate-gaussians" class="level3">
<h3 class="anchored" data-anchor-id="multivariate-gaussians">Multivariate Gaussians</h3>
<p>By using a variable transformation, we can use samples from univariate standard Gaussians to generate samples from general multivariate Gaussians:</p>
<p><span class="math display">\[
x \sim \mathcal N(\mu, \Sigma) = \frac{1}{|2\pi\Sigma|^{1/2}} \exp\left\{-\frac{1}{2} (x-\mu)^T\Sigma^{-1} (x-\mu) \right\}
\]</span></p>
<p>where the covariance matrix <span class="math inline">\(\Sigma\)</span> is positive definite and therefore has a <a href="https://en.wikipedia.org/wiki/Cholesky_decomposition">Cholesky decomposition</a> <span class="math inline">\(\Sigma=LL^T\)</span> with a lower triangular matrix <span class="math inline">\(L\)</span>.</p>
<p>Now consider <span class="math inline">\(y\sim \mathcal N(0, I)\)</span> (these can be generated with the Box-Muller method) and the linear transformation</p>
<p><span class="math display">\[
x = \mu + L y\,\,\, \Rightarrow \,\,\, y = L^{-1} (x-\mu).
\]</span></p>
<p>The Jacobian of this transform is <span class="math inline">\(L\)</span> with determinant <span class="math inline">\(|L| = \sqrt{|\Sigma|}\)</span>. Thus the distribution of <span class="math inline">\(x\)</span> is</p>
<p><span class="math display">\[
p_x(x) = (2\pi)^{-D/2} \exp\left\{-\frac{1}{2} (x-\mu)^T (L^{-1})^T L^{-1} (x-\mu) \right\} / \sqrt{|\Sigma|} = \mathcal N(\mu, \Sigma)
\]</span></p>
<p>since <span class="math inline">\((L^{-1})^T L^{-1} = (L^T)^{-1} L^{-1} = (LL^T)^{-1} = \Sigma^{-1}\)</span>.</p>
<div class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 2d example</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="co"># parameters of a 2d Gaussian</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>sigma1, sigma2, rho <span class="op">=</span> <span class="fl">1.</span>, <span class="fl">3.</span>, <span class="fl">0.7</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>Sigma <span class="op">=</span> np.array([[sigma1<span class="op">**</span><span class="dv">2</span>, rho <span class="op">*</span>sigma1 <span class="op">*</span> sigma2],</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>                  [rho <span class="op">*</span> sigma1 <span class="op">*</span> sigma2, sigma2<span class="op">**</span><span class="dv">2</span>]])</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>L <span class="op">=</span> np.linalg.cholesky(Sigma)</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>mu <span class="op">=</span> np.array([<span class="fl">1.</span>, <span class="op">-</span><span class="fl">1.</span>])</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a><span class="co"># transformation of the grid</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>grid1 <span class="op">=</span> np.reshape(np.mgrid[<span class="op">-</span><span class="fl">1.</span>:<span class="fl">1.</span>:<span class="ot">10j</span>,<span class="op">-</span><span class="dv">1</span>:<span class="op">+</span><span class="fl">1.</span>:<span class="ot">10j</span>], (<span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span>)).T</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>limits <span class="op">=</span> (<span class="op">-</span><span class="fl">5.</span>, <span class="fl">5.</span>)</span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> plt.cm.viridis(np.linspace(<span class="fl">0.</span>, <span class="fl">1.</span>, <span class="bu">len</span>(grid1)))</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a><span class="co"># sampling using a linear transformation</span></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> <span class="bu">int</span>(<span class="fl">1e3</span>)</span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.random.standard_normal((S, <span class="dv">2</span>))</span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> x.dot(L.T) <span class="op">+</span> mu</span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a><span class="co"># evaluate 2d Gaussian on a grid</span></span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>axes <span class="op">=</span> [np.linspace(yy.<span class="bu">min</span>(), yy.<span class="bu">max</span>(), <span class="dv">100</span>) <span class="cf">for</span> yy <span class="kw">in</span> y.T]</span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> np.reshape(np.meshgrid(<span class="op">*</span>axes), (<span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span>)).T</span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a>prob <span class="op">=</span> np.exp(<span class="op">-</span><span class="fl">0.5</span> <span class="op">*</span> np.<span class="bu">sum</span>(np.square((grid<span class="op">-</span>mu).dot(np.linalg.inv(L).T)), <span class="dv">1</span>))</span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a>prob <span class="op">=</span> prob.reshape(<span class="bu">len</span>(axes[<span class="dv">0</span>]), <span class="bu">len</span>(axes[<span class="dv">1</span>]))</span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a><span class="co"># show initial distributions and its transformed version</span></span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true" tabindex="-1"></a>kw <span class="op">=</span> <span class="bu">dict</span>(s<span class="op">=</span><span class="dv">20</span>, color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.2</span>)</span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">8</span>), sharex<span class="op">=</span><span class="st">'all'</span>, sharey<span class="op">=</span><span class="st">'all'</span>)</span>
<span id="cb25-29"><a href="#cb25-29" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>, <span class="dv">0</span>].scatter(<span class="op">*</span>grid1.T, c<span class="op">=</span>c)</span>
<span id="cb25-30"><a href="#cb25-30" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>, <span class="dv">1</span>].scatter(<span class="op">*</span>(grid1.dot(L.T) <span class="op">+</span> mu).T, c<span class="op">=</span>c)</span>
<span id="cb25-31"><a href="#cb25-31" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>, <span class="dv">0</span>].scatter(<span class="op">*</span>x.T, <span class="op">**</span>kw)</span>
<span id="cb25-32"><a href="#cb25-32" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>, <span class="dv">1</span>].scatter(<span class="op">*</span>y.T, <span class="op">**</span>kw)</span>
<span id="cb25-33"><a href="#cb25-33" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>, <span class="dv">1</span>].scatter(<span class="op">*</span>mu, s<span class="op">=</span><span class="dv">100</span>, color<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb25-34"><a href="#cb25-34" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>, <span class="dv">1</span>].contour(axes[<span class="dv">0</span>], axes[<span class="dv">1</span>], prob)</span>
<span id="cb25-35"><a href="#cb25-35" aria-hidden="true" tabindex="-1"></a>xmax <span class="op">=</span> <span class="dv">7</span></span>
<span id="cb25-36"><a href="#cb25-36" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> a <span class="kw">in</span> ax.flat:</span>
<span id="cb25-37"><a href="#cb25-37" aria-hidden="true" tabindex="-1"></a>    a.set_xlim(<span class="op">-</span>xmax, xmax)</span>
<span id="cb25-38"><a href="#cb25-38" aria-hidden="true" tabindex="-1"></a>    a.set_ylim(<span class="op">-</span>xmax, xmax)</span>
<span id="cb25-39"><a href="#cb25-39" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-22-output-1.png" width="758" height="758"></p>
</div>
</div>
</section>
</section>
</section>
<section id="lecture-3-rejection-and-importance-sampling-1" class="level1">
<h1>Lecture 3: Rejection and Importance Sampling</h1>
<section id="outline-2" class="level2">
<h2 class="anchored" data-anchor-id="outline-2">Outline</h2>
<ul>
<li>More direct sampling methods</li>
<li>Rejection sampling</li>
<li>Importance sampling</li>
</ul>
<section id="recap" class="level3">
<h3 class="anchored" data-anchor-id="recap">Recap</h3>
<ul>
<li><p>Our goal is to compute <span class="math inline">\(\mathbb E_p[f]\)</span> for some probabilistic model <span class="math inline">\(p\)</span>. Most inference tasks can be reduced to such sums or integrals</p></li>
<li><p>Monte Carlo approximation: <span class="math inline">\(\mathbb E_p[f] \approx \hat f_S = \frac{1}{S} \sum_{s=1}^S f(x^{(s)})\)</span> where <span class="math inline">\(x^{(s)} \sim p(x)\)</span>.</p></li>
<li><p>Properties: unbiased (<span class="math inline">\(\mathbb E[\hat f_S] = \mathbb E_p[f]\)</span>) and <span class="math inline">\(\text{var}[\hat f_S] = \frac{\text{var}[f]}{S}\)</span></p></li>
<li><p>Monte Carlo errors shrink with <span class="math inline">\(1/\sqrt{S}\)</span>, no dependence on dimension <span class="math inline">\(D\)</span>, but factor <span class="math inline">\(\text{var}[f]\)</span> can depend on <span class="math inline">\(D\)</span> in an unfavorable fashion (hypersphere example)</p></li>
<li><p>Correct sampling means that approximate probability <span class="math inline">\(\hat p_S(x) = \frac{1}{S} \sum_s \delta(x - x^{(s)}) \to p(x)\)</span> for <span class="math inline">\(S\to\infty\)</span> (“histogram over samples approximates true model”). But how to sample?</p></li>
<li><p>Uniformly distributed samples can be generated with pseudo-random number generators such as the linear congruential generator. These have their own subtleties…</p></li>
<li><p>Direct sampling is possible via variable transformation methods that utilize the transformation rule: <span class="math inline">\(p_y(y) = p_x(h^{-1}(y)) / |\nabla h(h^{-1}(y))|\)</span></p></li>
<li><p>Inversion method: <span class="math inline">\(h(x) = P(x) = \int_{-\infty}^x p(x')\, dx'\)</span> (cumulative distribution function)</p></li>
<li><p>Some examples of transformation methods: Box-Muller <span class="math inline">\((x, y) = r (\cos\varphi, \sin\varphi)\)</span>, multivariate Gaussians</p></li>
</ul>
<section id="sampling-uniformly-from-the-hypersphere" class="level4">
<h4 class="anchored" data-anchor-id="sampling-uniformly-from-the-hypersphere">Sampling uniformly from the hypersphere</h4>
<p>The <span class="math inline">\(D\)</span>-dimensional standard Gaussian distribution <span class="math inline">\(\mathcal N(0, I)\)</span> can be used to sample from the <a href="https://en.wikipedia.org/wiki/N-sphere">hypersphere</a> in <span class="math inline">\(D\)</span>-dimensional space <span class="math inline">\(\mathbb S^{D-1} = \{ x \in \mathbb R^D : \|x\| = 1\}\)</span>. To see this, consider</p>
<p><span class="math display">\[
\mathcal N(0, I) = (2\pi)^{-D/2} \exp\bigl\{-\|x\|^2/2 \bigr\} \to (2\pi)^{-D/2}\, r^{D-1} e^{-r^2/2} \mathbb 1(\|x\| = 1)
\]</span></p>
<p>That is, the <span class="math inline">\(D\)</span>-dimensional standard Gaussian distribution is spherically symmetric and therefore</p>
<p><span class="math display">\[
x/\|x\| \sim \mathcal U(\mathbb S^{D-1})\,\,\, \text{where}\,\,\, x \sim \mathcal N(0, I)
\]</span></p>
<div class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co"># sampling from the hypersphere</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pylab <span class="im">as</span> plt</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sample_sphere(S, D<span class="op">=</span><span class="dv">2</span>):</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a><span class="co">    S : number of samples</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a><span class="co">    D : dimension of embedding space</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> np.random.standard_normal((D, S))</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (x<span class="op">/</span>np.linalg.norm(x, axis<span class="op">=</span><span class="dv">0</span>)).T</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> sample_sphere(<span class="dv">10000</span>)</span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>angle <span class="op">=</span> np.arctan2(x[:,<span class="dv">1</span>], x[:,<span class="dv">0</span>])</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>kw <span class="op">=</span> <span class="bu">dict</span>(color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.2</span>, s<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">4</span>))</span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].scatter(<span class="op">*</span>x[:<span class="dv">200</span>].T, <span class="op">**</span>kw)</span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].hist(angle, bins<span class="op">=</span><span class="dv">30</span>, density<span class="op">=</span><span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.2</span>, color<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlabel(<span class="st">'angle'</span>)</span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-23-output-1.png" width="758" height="374"></p>
</div>
</div>
</section>
<section id="sampling-from-the-unit-ball" class="level4">
<h4 class="anchored" data-anchor-id="sampling-from-the-unit-ball">Sampling from the unit ball</h4>
<p>Using samples from the <span class="math inline">\((D-1)\)</span>-sphere we can also easily sample from the <a href="https://en.wikipedia.org/wiki/Ball_(mathematics)"><span class="math inline">\(D\)</span>-dimensional unit ball</a> <span class="math inline">\(\mathbb B^D = \{x\in\mathbb R^D : \|x\| \le 1\}\)</span>. Every element in <span class="math inline">\(\mathbb B^D\)</span> can be decomposed into</p>
<p><span class="math display">\[
x = r\, u \in \mathbb B^D\,\,\,\text{where}\,\,\, u\in\mathbb S^{D-1},\, r\in[0, 1]
\]</span></p>
<p>The distribution of <span class="math inline">\(r\)</span> follows from the surface area of <span class="math inline">\(\mathbb S^{D-1}\)</span> which scales with <span class="math inline">\(r^{D-1}\)</span>, therefore:</p>
<p><span class="math display">\[
p(r, u) = D\, r^{D-1}\, \mathbb 1(\|u\| = 1)
\]</span></p>
<p>The cdf of the radial component is <span class="math inline">\(r^D\)</span> and we obtain the following sampling rule:</p>
<ol type="1">
<li><p><span class="math inline">\(u^{(s)}=x^{(s)}/\|x^{(s)}\|\)</span> where <span class="math inline">\(x^{(s)} \sim \mathcal N(0, I_D)\)</span></p></li>
<li><p><span class="math inline">\(r^{(s)} = (v^{(s)})^{1/D}\)</span> where <span class="math inline">\(v^{(s)} \sim \mathcal U(0, 1)\)</span></p></li>
<li><p>then <span class="math inline">\(r^{(s)} u^{(s)} \sim \mathcal U(\mathbb B^D)\)</span></p></li>
</ol>
<div class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co"># sampling from the unit ball</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sample_ball(S, D<span class="op">=</span><span class="dv">2</span>):</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Sampling from the D-ball</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a><span class="co">    S : number of samples</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a><span class="co">    D : dimension of embedding space</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># sample from hypersphere</span></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> np.random.standard_normal((D, <span class="bu">int</span>(S)))</span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>    u <span class="op">=</span> x <span class="op">/</span> np.linalg.norm(x, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># sample radius</span></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> np.random.random(<span class="bu">int</span>(S))<span class="op">**</span>(<span class="dv">1</span><span class="op">/</span>D)</span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (u<span class="op">*</span>r).T</span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a>                                                                            </span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> sample_ball(<span class="dv">10000</span>)</span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a>angle <span class="op">=</span> np.arctan2(x[:,<span class="dv">1</span>], x[:,<span class="dv">0</span>])</span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a>kw <span class="op">=</span> <span class="bu">dict</span>(color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.2</span>, s<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">4</span>))</span>
<span id="cb27-20"><a href="#cb27-20" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].scatter(<span class="op">*</span>x[:<span class="dv">1000</span>].T, <span class="op">**</span>kw)</span>
<span id="cb27-21"><a href="#cb27-21" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].hist(angle, bins<span class="op">=</span><span class="dv">30</span>, density<span class="op">=</span><span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.2</span>, color<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb27-22"><a href="#cb27-22" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlabel(<span class="st">'angle'</span>)</span>
<span id="cb27-23"><a href="#cb27-23" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-24-output-1.png" width="758" height="374"></p>
</div>
</div>
</section>
<section id="sampling-from-a-radially-symmetric-distribution" class="level4">
<h4 class="anchored" data-anchor-id="sampling-from-a-radially-symmetric-distribution">Sampling from a radially symmetric distribution</h4>
<p>It is straightforward to generalize sampling from a unit ball to any spherically symmetric distribution. A spherically symmetric distribution over <span class="math inline">\(D\)</span> continuous variables has the form:</p>
<p><span class="math display">\[
    p(x) \propto f(\|x\|)
\]</span></p>
<p>where <span class="math inline">\(f(r)\)</span> is defined for <span class="math inline">\(r\in\mathbb R_+\)</span>. A convenient parameterization are spherical coordinates, resulting in the distribution</p>
<p><span class="math display">\[
p(x) \to r^{D-1}f(r)\, \mathcal{U}(\mathbb S^{D-1})
\]</span></p>
<p>We know how to generate uniform samples from <span class="math inline">\(\mathcal U(\mathbb S^{D-1})\)</span>. The remaining problem is to sample from</p>
<p><span class="math display">\[
p(r) \propto r^{D-1} f(r),\,\,\, r\ge 0
\]</span></p>
<p>So we have reduced a <span class="math inline">\(D\)</span>-dimensional sampling problem to a one-dimensional problem.</p>
</section>
<section id="sampling-from-an-elliptically-symmetric-distribution" class="level4">
<h4 class="anchored" data-anchor-id="sampling-from-an-elliptically-symmetric-distribution">Sampling from an elliptically symmetric distribution</h4>
<p>A similar technique can be used to generalize sampling from spherically symmetric distributions to elliptically symmetric distributions of the form</p>
<p><span class="math display">\[
p(x) \propto f\bigl((x-b)^T\!\!A(x-b)\bigr)
\]</span></p>
<p>where <span class="math inline">\(x, b \in \mathbb R^D\)</span> and <span class="math inline">\(A\in\mathbb R^{D\times D}\)</span> is positive definite; <span class="math inline">\(f(r)\ge 0\)</span> is an (unnormalized) radial pdf defined for <span class="math inline">\(r\in\mathbb R_+\)</span>.</p>
</section>
</section>
<section id="using-known-relations-between-probability-distributions-for-sampling" class="level3">
<h3 class="anchored" data-anchor-id="using-known-relations-between-probability-distributions-for-sampling">Using known relations between probability distributions for sampling</h3>
<p>The <a href="https://en.wikipedia.org/wiki/Erlang_distribution">Erlang distribution</a>, a special version of the <a href="https://en.wikipedia.org/wiki/Gamma_distribution">Gamma distribution</a>, has the functional form</p>
<p><span id="eq-erlang"><span class="math display">\[
    p(x\mid{}k, \lambda) = \frac{\lambda^k}{\Gamma(k)} x^{k - 1} e^{-\lambda x}, \, k \in \mathbb N, \, x &gt; 0,\, \lambda &gt; 0
\tag{21}\]</span></span></p>
<p>We can use exponentially distributed random variables <span class="math inline">\(z_i \sim \lambda e^{-\lambda z_i}, i=1, \ldots, k\)</span> to produce an Erlang variate. Define <span class="math inline">\(z_i = x y_i\)</span> with <span class="math inline">\(y_i\in[0, 1]\)</span> for <span class="math inline">\(1 \le i \le k-1\)</span> and <span class="math inline">\(z_k = x \bigl(1-\sum_{i=1}^{k-1} y_i\bigr)\)</span>, then <span class="math inline">\(x = \sum_i z_i\)</span>. The Jacobian of the parameter transform is</p>
<p><span class="math display">\[
\frac{\partial (z_1, \ldots, z_k)}{\partial (x, y_1, \ldots, y_{k-1})} =
\begin{pmatrix}
y_1 &amp; x &amp; 0 &amp; \cdots &amp; 0 \\
y_2 &amp; 0 &amp; x &amp; \cdots &amp; 0 \\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
y_{k-1} &amp; 0 &amp; 0 &amp; \cdots &amp; x \\
1- \sum_i y_{i} &amp; -x &amp; -x &amp; \cdots &amp; -x \\
\end{pmatrix}
\]</span></p>
<p>with determinant</p>
<p><span class="math display">\[
\left|\frac{\partial (z_1, \ldots, z_k)}{\partial (x, y_1, \ldots, y_{k-1})}\right| \propto x^{k-1}
\]</span></p>
<p>Therefore:</p>
<p><span class="math display">\[
x \sim x^{k-1} e^{-\lambda x}
\]</span></p>
<div class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co"># sampling from Erlang</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.special <span class="im">import</span> gammaln</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sample_erlang(S, k<span class="op">=</span><span class="dv">1</span>, beta<span class="op">=</span><span class="fl">1.</span>):</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>    u <span class="op">=</span> np.random.random((<span class="bu">int</span>(S), k))</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>    z <span class="op">=</span> <span class="op">-</span> np.log(u) <span class="op">/</span> beta</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> z.<span class="bu">sum</span>(<span class="dv">1</span>)</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>beta <span class="op">=</span> <span class="fl">2.</span></span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> <span class="fl">1e4</span></span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> sample_erlang(S, k<span class="op">=</span>k, beta<span class="op">=</span>beta)</span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.linspace(<span class="fl">0.</span>, x.<span class="bu">max</span>(), <span class="dv">1000</span>)</span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> k <span class="op">*</span> np.log(beta) <span class="op">+</span> (k<span class="op">-</span><span class="dv">1</span>) <span class="op">*</span> np.log(t<span class="op">+</span><span class="fl">1e-100</span>) <span class="op">-</span> beta <span class="op">*</span> t <span class="op">-</span> gammaln(k)</span>
<span id="cb28-22"><a href="#cb28-22" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> np.exp(p)</span>
<span id="cb28-23"><a href="#cb28-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-24"><a href="#cb28-24" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">5</span>, <span class="dv">5</span>))</span>
<span id="cb28-25"><a href="#cb28-25" aria-hidden="true" tabindex="-1"></a>ax.plot(t, p, color<span class="op">=</span><span class="st">'r'</span>, lw<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb28-26"><a href="#cb28-26" aria-hidden="true" tabindex="-1"></a>ax.hist(x, bins<span class="op">=</span><span class="dv">50</span>, color<span class="op">=</span><span class="st">'lightgrey'</span>, density<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb28-27"><a href="#cb28-27" aria-hidden="true" tabindex="-1"></a>fig.tight_layout() </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-25-output-1.png" width="470" height="470"></p>
</div>
</div>
<p>There are many more relationships between standard univariate probability distributions that can be exploited for sampling (an interactive version of the following Figure can be found at <a href="http://www.math.wm.edu/~leemis/chart/UDR/UDR.html">Leemis &amp; Mc Queston: Univariate Distribution RelationShips</a>):</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<figure class="figure">
<img src="images/UnivariateDistributionRelationships.png" title="Relationshipts between univariate pdfs" class="img-fluid figure-img">
</figure>
<p></p><figcaption class="figure-caption">Relationships between pdfs</figcaption><p></p>
</figure>
</div>
</section>
<section id="further-reading" class="level3">
<h3 class="anchored" data-anchor-id="further-reading">Further reading</h3>
<p>Donald Knuth: <a href="https://en.wikipedia.org/wiki/The_Art_of_Computer_Programming">The Art of Computer Programming, Vol. 2, Chap. 1</a></p>
<p>Luc Devroye: <a href="https://link.springer.com/book/10.1007/978-1-4613-8643-8">Non-Uniform Random Variate Generation</a></p>
</section>
</section>
<section id="rejection-sampling" class="level2">
<h2 class="anchored" data-anchor-id="rejection-sampling">Rejection sampling</h2>
<p>Direct sampling methods are specifically designed for particular target distributions. For complex probabilistic models such as the Ising model, it will not be possible to use these methods. We will now discuss methods that can be applied to more general probabilistic models.</p>
<p><a href="https://en.wikipedia.org/wiki/Rejection_sampling"><em>Rejection sampling</em></a> is an early sampling approach that has been developed by von Neumann. The idea is to use a helper distribution <span class="math inline">\(q\)</span> from which we can sample easily in order to sample from a more complicated model <span class="math inline">\(p\)</span>. To be a valid proposal distribution, <span class="math inline">\(q\)</span> must satisfy</p>
<p><span id="eq-rejection_proposal"><span class="math display">\[
    p(x) \le M q(x)
\tag{22}\]</span></span></p>
<p>for a constant <span class="math inline">\(M\)</span> which implies <span class="math inline">\(M\ge 1\)</span>, since <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> are normalized pdfs. Moreover, the support of <span class="math inline">\(p\)</span> should be contained in the support of the proposal distribution <span class="math inline">\(q\)</span>. Let’s define the ratio</p>
<p><span id="eq-rejection_accprob"><span class="math display">\[
    r(x) := \frac{p(x)}{M q(x)}
\tag{23}\]</span></span></p>
<p>which is smaller than or equal to 1 for all <span class="math inline">\(x\)</span> with <span class="math inline">\(q(x)&gt;0\)</span>, otherwise we set <span class="math inline">\(r(x) = 1\)</span>.</p>
<section id="algorithm-rejection-sampling" class="level3">
<h3 class="anchored" data-anchor-id="algorithm-rejection-sampling">Algorithm: Rejection sampling</h3>
<p>The algorithm produces random samples <span class="math inline">\(x^{(s)}\)</span> by iterating over the following steps until the desired number of samples <span class="math inline">\(S\)</span> has been generated:</p>
<ol type="1">
<li><p>Draw <span class="math inline">\(x \sim q(x)\)</span></p></li>
<li><p>Draw <span class="math inline">\(u \sim \mathcal U(0, 1)\)</span></p></li>
<li><p><span class="math inline">\(r \gets \frac{p(x)}{Mq(x)}\)</span></p></li>
<li><p>If <span class="math inline">\(u &lt; r\)</span>, then</p>
<ul>
<li><span class="math inline">\(x^{(s)} \gets x\)</span></li>
<li><span class="math inline">\(s \gets s+1\)</span>.</li>
</ul></li>
<li><p>If <span class="math inline">\(s &lt; S\)</span>, go to 1.</p></li>
</ol>
<section id="example-sampling-a-gaussian-with-a-cauchy-proposal" class="level4">
<h4 class="anchored" data-anchor-id="example-sampling-a-gaussian-with-a-cauchy-proposal">Example: Sampling a Gaussian with a Cauchy proposal</h4>
<p>The standard Gaussian distribution is</p>
<p><span class="math display">\[
p(x) = \frac{1}{\sqrt{2\pi}}\, e^{-x^2/2}
\]</span></p>
<p>and the Cauchy distribution</p>
<p><span class="math display">\[
q(x) = \frac{1}{\pi} \frac{1}{1 + x^2}\, .
\]</span></p>
<p>The Cauchy distribution can be sampled with the inversion method: <span class="math inline">\(x^{(s)} = -\tan(\pi u^{(s)}), \, u^{(s)} \sim \mathcal U(0, 1)\)</span> (see table above).</p>
<p>To show that the Cauchy distribution is a valid proposal distribution, we first have to bound the ratio</p>
<p><span class="math display">\[
f(x) = \frac{p(x)}{q(x)} = \sqrt{\frac{\pi}{2}}\, (1 + x^2)\, e^{-x^2/2}\, .
\]</span></p>
<p>The first derivative is <span class="math display">\[
f'(x)  = \sqrt{\frac{\pi}{2}}\, x\, (1 - x^2)\, e^{-x^2/2}
\]</span> with zeros <span class="math inline">\(x=-1, 0, 1\)</span>. The second derivative <span class="math inline">\(f''(x) = \sqrt{\frac{\pi}{2}}\, (x^4 - 4x^2 +1)\, e^{-x^2/2}\)</span> is positive at <span class="math inline">\(x=0\)</span> and negative at <span class="math inline">\(x=\pm 1\)</span>. Therefore, <span class="math inline">\(x=\pm 1\)</span> are the locations of the maxima of <span class="math inline">\(f\)</span>, and the upper bound is <span class="math inline">\(M := f(1) = \sqrt{2\pi/e} \approx 1.52\)</span>.</p>
<div class="cell" data-execution_count="25">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sample_cauchy(S):</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    u <span class="op">=</span> np.random.random(<span class="bu">int</span>(S))</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span>np.tan(np.pi <span class="op">*</span> u)</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calc_ratio(t):</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fl">0.5</span> <span class="op">*</span> (<span class="dv">1</span> <span class="op">+</span> t<span class="op">**</span><span class="dv">2</span>) <span class="op">*</span> np.exp(<span class="op">-</span><span class="fl">0.5</span> <span class="op">*</span> t<span class="op">**</span><span class="dv">2</span>) <span class="op">*</span> np.sqrt(np.e)</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> <span class="bu">int</span>(<span class="fl">1e3</span>)</span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>M <span class="op">=</span> np.sqrt(<span class="dv">2</span><span class="op">*</span>np.pi<span class="op">/</span>np.e)</span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> sample_cauchy(M<span class="op">*</span>S)</span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> calc_ratio(y)</span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> np.random.random(y.shape)</span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a>Mq <span class="op">=</span> M <span class="op">/</span> (<span class="dv">1</span> <span class="op">+</span> y<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> np.pi</span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.linspace(<span class="op">-</span><span class="fl">1.</span>, <span class="fl">1.</span>, <span class="dv">1000</span>) <span class="op">*</span> <span class="dv">5</span></span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true" tabindex="-1"></a>q <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> (<span class="dv">1</span> <span class="op">+</span> t<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> np.pi</span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> np.exp(<span class="op">-</span><span class="fl">0.5</span> <span class="op">*</span> t<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> np.sqrt(<span class="dv">2</span><span class="op">*</span>np.pi)</span>
<span id="cb29-20"><a href="#cb29-20" aria-hidden="true" tabindex="-1"></a>M</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="25">
<pre><code>1.520346901066281</code></pre>
</div>
</div>
<div class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">4</span>), sharex<span class="op">=</span><span class="va">True</span>, </span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>                       sharey<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].fill_between(t, t<span class="op">*</span><span class="fl">0.</span>, M<span class="op">*</span>q, color<span class="op">=</span><span class="st">'b'</span>, alpha<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].plot(t, M<span class="op">*</span>q, color<span class="op">=</span><span class="st">'b'</span>, lw<span class="op">=</span><span class="dv">2</span>, ls<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="vs">r'scaled Cauchy $Mq$'</span>)</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].plot(t, p, color<span class="op">=</span><span class="st">'r'</span>, lw<span class="op">=</span><span class="dv">2</span>, ls<span class="op">=</span><span class="st">'-'</span>, label<span class="op">=</span><span class="vs">r'Gaussian $p$'</span>)</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].legend(loc<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].fill_between(t, t<span class="op">*</span><span class="fl">0.</span>, M<span class="op">*</span>q, color<span class="op">=</span><span class="st">'b'</span>, alpha<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].scatter(y[u<span class="op">&lt;</span>r], (Mq<span class="op">*</span>u)[u<span class="op">&lt;</span>r], color<span class="op">=</span><span class="st">'r'</span>, s<span class="op">=</span><span class="dv">10</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].scatter(y[u<span class="op">&gt;=</span>r], (Mq<span class="op">*</span>u)[u<span class="op">&gt;=</span>r], color<span class="op">=</span><span class="st">'b'</span>, s<span class="op">=</span><span class="dv">10</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].plot(t, M<span class="op">*</span>q, color<span class="op">=</span><span class="st">'b'</span>, lw<span class="op">=</span><span class="dv">2</span>, ls<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="vs">r'scaled Cauchy $Mq$'</span>)</span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].plot(t, p, color<span class="op">=</span><span class="st">'r'</span>, lw<span class="op">=</span><span class="dv">2</span>, ls<span class="op">=</span><span class="st">'-'</span>, label<span class="op">=</span><span class="vs">r'Gaussian $p$'</span>)</span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].hist(y[u<span class="op">&lt;</span>r], bins<span class="op">=</span><span class="dv">50</span>, color<span class="op">=</span><span class="st">'lightgrey'</span>, density<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].plot(t, p, color<span class="op">=</span><span class="st">'r'</span>, lw<span class="op">=</span><span class="dv">2</span>, ls<span class="op">=</span><span class="st">'-'</span>)</span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].set_xlim(<span class="op">-</span><span class="fl">5.</span>, <span class="dv">5</span>)</span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].set_ylim(<span class="fl">0.</span>, <span class="fl">0.5</span>)</span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-21"><a href="#cb31-21" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-27-output-1.png" width="1142" height="374"></p>
</div>
</div>
</section>
</section>
<section id="why-does-rejection-sampling-work" class="level3">
<h3 class="anchored" data-anchor-id="why-does-rejection-sampling-work">Why does rejection sampling work?</h3>
<p>Let’s formalize the rejection sampling algorithm. To this end, we introduce a binary random variable <span class="math inline">\(a\in\{0, 1\}\)</span> indicating if a proposal <span class="math inline">\(x \sim q(x)\)</span> has been accepted or not. The probability of being accepted, <span class="math inline">\(a=1\)</span>, or rejected, <span class="math inline">\(a=0\)</span>, is</p>
<p><span class="math display">\[
p(a=1\mid{}x) = r(x), \,\,\ p(a=0\mid{}x) = 1 - r(x)\, .
\]</span></p>
<p>This means that <span class="math inline">\(a\)</span> is a <a href="https://en.wikipedia.org/wiki/Bernoulli_distribution">Bernoulli variable</a>:</p>
<p><span class="math display">\[
p(a\mid{}x) = \bigl[r(x)\bigr]^a \bigl[1-r(x)\bigr]^{1-a}, \,\,\, a\in\{0, 1\}\, .
\]</span></p>
<p>The joint distribution of <span class="math inline">\(x\)</span> and <span class="math inline">\(a\)</span> is</p>
<p><span class="math display">\[
p(a, x) = p(a\mid{}x)\, q(x)
\]</span></p>
<p>since <span class="math inline">\(x\sim q\)</span>. The accepted samples are those for which <span class="math inline">\(a=1\)</span>. These samples follow the <em>conditional</em> distribution <span class="math inline">\(p(x\mid{}a=1)\)</span>. That is</p>
<p><span class="math display">\[
x^{(s)} \sim p(x\mid{}a=1)\, .
\]</span></p>
<p>It is straight forward to compute this distribution. We have <span class="math inline">\(p(x\mid{}a=1) = p(x, a=1)\, /\, p(a=1)\)</span>. We need to compute the marginal probability <span class="math inline">\(p(a=1)\)</span>:</p>
<p><span id="eq-rs-acceptance"><span class="math display">\[
p(a=1) = \int p(x, a=1)\, dx = \int q(x)\, r(x)\, dx = \int q(x)\, \frac{p(x)}{Mq(x)}\, dx = \frac{1}{M}
\tag{24}\]</span></span></p>
<p>since <span class="math inline">\(p\)</span> is normalized. Equation (<a href="#eq-rs-acceptance">Equation&nbsp;24</a>) tells us that the average probability to propose an acceptable sample is <span class="math inline">\(M^{-1}\)</span>. We can now compute the desired conditional distribution <span class="math inline">\(p(x\mid{}a=1)\)</span>:</p>
<p><span class="math display">\[
p(x\mid{}a=1) = \frac{p(x, a=1)}{p(a=1)} = M q(x)\, r(x) = M q(x)\, \frac{p(x)}{M q(x)} = p(x)\, .
\]</span></p>
<section id="waiting-time-before-acceptance" class="level4">
<h4 class="anchored" data-anchor-id="waiting-time-before-acceptance">Waiting time before acceptance</h4>
<p>We can also compute the number of attempts it needs to generate an acceptable proposal. Let’s call this number <span class="math inline">\(T\)</span>. The probability that a proposal is accepted after <span class="math inline">\(T-1\)</span> unsuccessful trials is</p>
<p><span class="math display">\[
\Pr(T) = [p(a=0)]^{T-1} p(a=1) = [1-M^{-1}]^{T-1} M^{-1}, \,\,\, T\in \{1, 2, 3, \ldots \}
\]</span></p>
<p>which is the probability that the first <span class="math inline">\(T-1\)</span> samples are rejected (<span class="math inline">\(a^{(t)}=0, \, t&lt;T\)</span>) and the last sample is accepted <span class="math inline">\(a^{(T)}=1\)</span>. This distribution is a <a href="https://en.wikipedia.org/wiki/Geometric_distribution">geometric distribution</a> and normalized since</p>
<p><span class="math display">\[
\sum_{T\ge 1} \Pr(T) = \sum_{T\ge 1} [1-M^{-1}]^{T-1}\, M^{-1} = M^{-1} \sum_{T\ge 0} [1-M^{-1}]^{T} = \frac{M^{-1}}{1 - (1 - M^{-1})} = 1
\]</span></p>
<p>using the summation rules for <a href="https://en.wikipedia.org/wiki/Geometric_progression">geometric progressions</a> and <a href="https://en.wikipedia.org/wiki/Geometric_series">geometric series</a>.</p>
<p>The expected time one has to wait until an acceptable sample is proposed is</p>
<p><span class="math display">\[
\mathbb E[T] = \sum_{T\ge 1} T\, \Pr(T) = M^{-1} \sum_{T\ge 1} T\, [1-M^{-1}]^{T-1} = 1 + M^{-1} \sum_{T \ge 0} T \, [1-M^{-1}]^T\, .
\]</span></p>
<p>To compute the last series, let us rewrite it as <span class="math inline">\(\sum_{T\ge 0} T e^{-\lambda T}\)</span> where <span class="math inline">\(\lambda = - \log(1-M^{-1}) &gt; 0\)</span>:</p>
<p><span class="math display">\[
\sum_{T\ge 0} T e^{-\lambda T} = - \sum_{T\ge 0} \frac{d}{d\lambda} e^{-\lambda T} = - \frac{d}{d\lambda} \sum_{T\ge 0} e^{-\lambda T} = - \frac{d}{d\lambda} \frac{1}{1 - e^{-\lambda}} = \frac{e^{-\lambda}}{(1 - e^{-\lambda})^2}\, .
\]</span></p>
<p>By substituting <span class="math inline">\(e^{-\lambda} = 1-M^{-1}\)</span> we obtain</p>
<p><span class="math display">\[
\mathbb E[T] = 1 + M^{-1} \frac{1-M^{-1}}{(1 -(1-M^{-1}))^2} = 1 + M^{-1} \frac{1-M^{-1}}{M^{-2}} = M\, .
\]</span></p>
<p>The larger <span class="math inline">\(M\)</span>, the longer is the average time that we have to wait until a sample is accepted. Therefore, we should try to design an envelope <span class="math inline">\(Mq(x)&gt;p(x)\)</span> that is as tight as possible.</p>
<p>Let us modify the above code for sampling a Gaussian using Cauchy proposals by allowing <span class="math inline">\(M\)</span> to be greater than the tightest upper bound <span class="math inline">\(\sqrt{2\pi/e}\)</span> and investigate the effect on the waiting time:</p>
<div class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="co"># tightest bound</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>M_opt <span class="op">=</span> (<span class="dv">2</span><span class="op">*</span>np.pi<span class="op">/</span>np.e)<span class="op">**</span>(<span class="dv">1</span><span class="op">/</span><span class="dv">2</span>)</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calc_ratio(t, M<span class="op">=</span>M_opt):</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fl">0.5</span> <span class="op">*</span> (<span class="dv">1</span> <span class="op">+</span> t<span class="op">**</span><span class="dv">2</span>) <span class="op">*</span> np.exp(<span class="op">-</span><span class="fl">0.5</span> <span class="op">*</span> t<span class="op">**</span><span class="dv">2</span>) <span class="op">*</span> np.sqrt(np.e) <span class="op">*</span> (M_opt<span class="op">/</span>M)</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a><span class="co"># evaluate Gaussian and Cauchy distribution</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.linspace(<span class="op">-</span><span class="fl">1.</span>, <span class="fl">1.</span>, <span class="dv">1000</span>) <span class="op">*</span> <span class="dv">5</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>q <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> (<span class="dv">1</span> <span class="op">+</span> t<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> np.pi</span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> np.exp(<span class="op">-</span><span class="fl">0.5</span> <span class="op">*</span> t<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> np.sqrt(<span class="dv">2</span><span class="op">*</span>np.pi)</span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a><span class="co"># rejection sampling</span></span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> <span class="bu">int</span>(<span class="fl">2e4</span>)</span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">8</span>), sharex<span class="op">=</span><span class="st">'col'</span>)</span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a><span class="co"># M = factor * M_opt</span></span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, factor <span class="kw">in</span> <span class="bu">enumerate</span>([<span class="dv">2</span>, <span class="dv">4</span>]):</span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a>    M <span class="op">=</span> factor <span class="op">*</span> M_opt</span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> sample_cauchy(S)</span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> calc_ratio(y, M)</span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true" tabindex="-1"></a>    u <span class="op">=</span> np.random.random(y.shape)</span>
<span id="cb32-24"><a href="#cb32-24" aria-hidden="true" tabindex="-1"></a>    Mq <span class="op">=</span> M <span class="op">/</span> (<span class="dv">1</span> <span class="op">+</span> y<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> np.pi</span>
<span id="cb32-25"><a href="#cb32-25" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb32-26"><a href="#cb32-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># waiting times</span></span>
<span id="cb32-27"><a href="#cb32-27" aria-hidden="true" tabindex="-1"></a>    T <span class="op">=</span> np.diff(np.nonzero(u<span class="op">&lt;</span>r)[<span class="dv">0</span>])</span>
<span id="cb32-28"><a href="#cb32-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-29"><a href="#cb32-29" aria-hidden="true" tabindex="-1"></a>    ax[i,<span class="dv">0</span>].set_title(<span class="vs">r'$M=</span><span class="sc">{0}</span><span class="vs">\, \sqrt</span><span class="sc">{{</span><span class="vs">2\pi/e</span><span class="sc">}}</span><span class="vs">$'</span>.<span class="bu">format</span>(factor))</span>
<span id="cb32-30"><a href="#cb32-30" aria-hidden="true" tabindex="-1"></a>    ax[i,<span class="dv">0</span>].fill_between(t, t<span class="op">*</span><span class="fl">0.</span>, M<span class="op">*</span>q, color<span class="op">=</span><span class="st">'b'</span>, alpha<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb32-31"><a href="#cb32-31" aria-hidden="true" tabindex="-1"></a>    ax[i,<span class="dv">0</span>].plot(t, M<span class="op">*</span>q, color<span class="op">=</span><span class="st">'b'</span>, lw<span class="op">=</span><span class="dv">2</span>, ls<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="vs">r'scaled Cauchy $Mq$'</span>)</span>
<span id="cb32-32"><a href="#cb32-32" aria-hidden="true" tabindex="-1"></a>    ax[i,<span class="dv">0</span>].plot(t, p, color<span class="op">=</span><span class="st">'r'</span>, lw<span class="op">=</span><span class="dv">2</span>, ls<span class="op">=</span><span class="st">'-'</span>, label<span class="op">=</span><span class="vs">r'Gaussian $p$'</span>)</span>
<span id="cb32-33"><a href="#cb32-33" aria-hidden="true" tabindex="-1"></a>    ax[i,<span class="dv">0</span>].legend()</span>
<span id="cb32-34"><a href="#cb32-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">#</span></span>
<span id="cb32-35"><a href="#cb32-35" aria-hidden="true" tabindex="-1"></a>    ax[i,<span class="dv">1</span>].set_title(<span class="vs">r'$M=</span><span class="sc">{0}</span><span class="vs">\, \sqrt</span><span class="sc">{{</span><span class="vs">2\pi/e</span><span class="sc">}}</span><span class="vs">$'</span>.<span class="bu">format</span>(factor))</span>
<span id="cb32-36"><a href="#cb32-36" aria-hidden="true" tabindex="-1"></a>    ax[i,<span class="dv">1</span>].fill_between(t, t<span class="op">*</span><span class="fl">0.</span>, M<span class="op">*</span>q, color<span class="op">=</span><span class="st">'b'</span>, alpha<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb32-37"><a href="#cb32-37" aria-hidden="true" tabindex="-1"></a>    ax[i,<span class="dv">1</span>].scatter(y[u<span class="op">&lt;</span>r], (Mq<span class="op">*</span>u)[u<span class="op">&lt;</span>r], color<span class="op">=</span><span class="st">'r'</span>, s<span class="op">=</span><span class="dv">1</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb32-38"><a href="#cb32-38" aria-hidden="true" tabindex="-1"></a>    ax[i,<span class="dv">1</span>].scatter(y[u<span class="op">&gt;=</span>r], (Mq<span class="op">*</span>u)[u<span class="op">&gt;=</span>r], color<span class="op">=</span><span class="st">'b'</span>, s<span class="op">=</span><span class="dv">1</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb32-39"><a href="#cb32-39" aria-hidden="true" tabindex="-1"></a>    ax[i,<span class="dv">1</span>].plot(t, M<span class="op">*</span>q, color<span class="op">=</span><span class="st">'b'</span>, lw<span class="op">=</span><span class="dv">2</span>, ls<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="vs">r'scaled Cauchy $Mq$'</span>)</span>
<span id="cb32-40"><a href="#cb32-40" aria-hidden="true" tabindex="-1"></a>    ax[i,<span class="dv">1</span>].plot(t, p, color<span class="op">=</span><span class="st">'r'</span>, lw<span class="op">=</span><span class="dv">2</span>, ls<span class="op">=</span><span class="st">'-'</span>, label<span class="op">=</span><span class="vs">r'Gaussian $p$'</span>)</span>
<span id="cb32-41"><a href="#cb32-41" aria-hidden="true" tabindex="-1"></a>    <span class="co">#</span></span>
<span id="cb32-42"><a href="#cb32-42" aria-hidden="true" tabindex="-1"></a>    times, counts <span class="op">=</span> np.unique(T, return_counts<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb32-43"><a href="#cb32-43" aria-hidden="true" tabindex="-1"></a>    ax[i,<span class="dv">2</span>].bar(times, counts, color<span class="op">=</span><span class="st">'lightgrey'</span>)</span>
<span id="cb32-44"><a href="#cb32-44" aria-hidden="true" tabindex="-1"></a>    ax[i,<span class="dv">2</span>].set_xlim(<span class="dv">0</span>, times.<span class="bu">max</span>()<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb32-45"><a href="#cb32-45" aria-hidden="true" tabindex="-1"></a>    ax[i,<span class="dv">2</span>].set_ylim(<span class="dv">10</span>, counts.<span class="bu">max</span>()<span class="op">*</span><span class="fl">1.1</span>)</span>
<span id="cb32-46"><a href="#cb32-46" aria-hidden="true" tabindex="-1"></a>    ax[i,<span class="dv">2</span>].set_xlabel(<span class="vs">r'waiting time $T$'</span>)</span>
<span id="cb32-47"><a href="#cb32-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-48"><a href="#cb32-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> a <span class="kw">in</span> ax[i,:<span class="dv">2</span>]:</span>
<span id="cb32-49"><a href="#cb32-49" aria-hidden="true" tabindex="-1"></a>        a.set_xlim(<span class="op">-</span><span class="dv">5</span>, <span class="fl">5.</span>)</span>
<span id="cb32-50"><a href="#cb32-50" aria-hidden="true" tabindex="-1"></a>        a.set_ylim(<span class="fl">0.</span>, factor<span class="op">/</span><span class="dv">2</span>)</span>
<span id="cb32-51"><a href="#cb32-51" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb32-52"><a href="#cb32-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> a <span class="kw">in</span> ax[:,<span class="dv">2</span>]:</span>
<span id="cb32-53"><a href="#cb32-53" aria-hidden="true" tabindex="-1"></a>        a.set_xlim(<span class="dv">0</span>, times.<span class="bu">max</span>()<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb32-54"><a href="#cb32-54" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-28-output-1.png" width="1142" height="754"></p>
</div>
</div>
</section>
</section>
<section id="geometric-interpretation" class="level3">
<h3 class="anchored" data-anchor-id="geometric-interpretation">Geometric interpretation</h3>
<p>A geometric interpretation of rejection sampling is that we generate points <span class="math inline">\((x,y)\)</span> under the graph of <span class="math inline">\(Mq(x)\)</span> in the following fashion: The <span class="math inline">\(x\)</span> coordinate is drawn from <span class="math inline">\(q\)</span>, and the <span class="math inline">\(y\)</span> coordinate from a uniform distribution <span class="math inline">\(y=M q(x) u\)</span> where <span class="math inline">\(u\sim \mathcal U(0, 1)\)</span>:</p>
<p><span class="math display">\[
(x, y) \sim q(x)\, \mathbb 1\bigl(y &lt; Mq(x)\bigr)
\]</span></p>
<p><span class="math inline">\((x,y)\)</span> is accepted if <span class="math inline">\(y &lt; p(x)\)</span> otherwise it is rejected. Therefore, the area under <span class="math inline">\(Mq\)</span> can be separated into an <em>acceptance region</em> and a <em>rejection region</em>. The value of <span class="math inline">\(M\)</span> determines the relative size of the rejection and acceptance regions.</p>
<div class="cell" data-execution_count="28">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.ndimage <span class="im">import</span> gaussian_filter</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.linspace(<span class="op">-</span><span class="fl">1.</span>, <span class="fl">1.</span>, <span class="dv">1000</span>) <span class="op">*</span> <span class="dv">10</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>mu <span class="op">=</span> np.array([<span class="op">-</span><span class="dv">2</span>,  <span class="fl">5.</span> ])</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>sigma <span class="op">=</span> np.array([<span class="fl">90.</span>, <span class="fl">120.</span> ])</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>w <span class="op">=</span> np.array([<span class="fl">0.7</span>, <span class="fl">0.3</span>])</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> <span class="fl">0.</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(mu)):</span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> t <span class="op">*</span> <span class="fl">0.</span></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>    y[np.argmin(np.fabs(mu[k]<span class="op">-</span>t))] <span class="op">=</span> <span class="fl">1.</span></span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>    p <span class="op">+=</span> gaussian_filter(y, sigma<span class="op">=</span>sigma[k]) <span class="op">*</span> w[k]</span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a>p <span class="op">/=</span> p.<span class="bu">sum</span>()</span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a>q <span class="op">=</span> np.exp(<span class="op">-</span><span class="fl">0.5</span> <span class="op">*</span> t<span class="op">**</span><span class="dv">2</span> <span class="op">/</span> <span class="dv">16</span>) <span class="op">+</span> <span class="fl">0.1</span></span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a>q <span class="op">/=</span> q.<span class="bu">sum</span>()</span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true" tabindex="-1"></a>M <span class="op">=</span> np.<span class="bu">max</span>(p<span class="op">/</span>q) <span class="op">*</span> <span class="fl">1.1</span></span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-20"><a href="#cb33-20" aria-hidden="true" tabindex="-1"></a>fs <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb33-21"><a href="#cb33-21" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(subplot_kw<span class="op">=</span><span class="bu">dict</span>(xticks<span class="op">=</span>[], yticks<span class="op">=</span>[]))</span>
<span id="cb33-22"><a href="#cb33-22" aria-hidden="true" tabindex="-1"></a>ax.fill_between(t, p, q<span class="op">*</span>M, color<span class="op">=</span><span class="st">'r'</span>, alpha<span class="op">=</span><span class="fl">0.2</span>)</span>
<span id="cb33-23"><a href="#cb33-23" aria-hidden="true" tabindex="-1"></a>ax.plot(t, q<span class="op">*</span>M, color<span class="op">=</span><span class="st">'r'</span>, lw<span class="op">=</span><span class="dv">3</span>, label<span class="op">=</span><span class="vs">r'$Mq$'</span>)</span>
<span id="cb33-24"><a href="#cb33-24" aria-hidden="true" tabindex="-1"></a>ax.fill_between(t, p<span class="op">*</span><span class="dv">0</span>, p, color<span class="op">=</span><span class="st">'b'</span>, alpha<span class="op">=</span><span class="fl">0.2</span>)</span>
<span id="cb33-25"><a href="#cb33-25" aria-hidden="true" tabindex="-1"></a>ax.plot(t, p, color<span class="op">=</span><span class="st">'b'</span>, lw<span class="op">=</span><span class="dv">3</span>, label<span class="op">=</span><span class="vs">r'$p$'</span>)</span>
<span id="cb33-26"><a href="#cb33-26" aria-hidden="true" tabindex="-1"></a>ax.annotate(<span class="st">'accept'</span>, (<span class="fl">0.32</span>, <span class="fl">0.2</span>), xycoords<span class="op">=</span><span class="st">'axes fraction'</span>, color<span class="op">=</span><span class="st">'b'</span>, fontsize<span class="op">=</span>fs)</span>
<span id="cb33-27"><a href="#cb33-27" aria-hidden="true" tabindex="-1"></a>ax.annotate(<span class="st">'reject'</span>, (<span class="fl">0.55</span>, <span class="fl">0.4</span>), xycoords<span class="op">=</span><span class="st">'axes fraction'</span>, color<span class="op">=</span><span class="st">'r'</span>, fontsize<span class="op">=</span>fs)</span>
<span id="cb33-28"><a href="#cb33-28" aria-hidden="true" tabindex="-1"></a>ax.legend(fontsize<span class="op">=</span>fs)</span>
<span id="cb33-29"><a href="#cb33-29" aria-hidden="true" tabindex="-1"></a>ax.set_frame_on(<span class="va">False</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-29-output-1.png" width="540" height="389"></p>
</div>
</div>
<p>There are multiple factors that influence <span class="math inline">\(M\)</span>. The size of the support of <span class="math inline">\(q\)</span> has a direct impact on <span class="math inline">\(M\)</span>: The larger the support of <span class="math inline">\(q\)</span>, the larger we have to choose <span class="math inline">\(M\)</span> to still satisfy the condition <span class="math inline">\(p(x) \le Mq(x)\)</span>, because the probability mass of the proposal distribution is distributed over a larger region and the density <span class="math inline">\(q\)</span> is scaled down. The tightest <span class="math inline">\(M\)</span> can be found by maximizing the ratio <span class="math inline">\(p(x)/q(x)\)</span> over the sample space. In general, this will be a hard optimization problem. But even if we find the tightest value of <span class="math inline">\(M\)</span>, the size of the rejection region will grow exponentially with dimension <span class="math inline">\(D\)</span>.</p>
</section>
<section id="rejection-sampling-scales-badly-with-dimension" class="level3">
<h3 class="anchored" data-anchor-id="rejection-sampling-scales-badly-with-dimension">Rejection sampling scales badly with dimension</h3>
<p>Finding tight bounds in high dimensions is very difficult. Moreover, the volume of the rejection region will scale exponentially with dimension. For example, if we sample a <span class="math inline">\(D\)</span> dimensional Gaussian by using <span class="math inline">\(D\)</span> Cauchy variates, than each dimension contributes a factor of <span class="math inline">\(\sqrt{2\pi/e} \approx 1.5\)</span> such that the overall <span class="math inline">\(M\)</span> scales as <span class="math inline">\(1.5^D\)</span>. As a consequence, the waiting time will scale exponentially with dimension and using rejection sampling will become increasingly inefficient as the size of our probabilistic model grows.</p>
</section>
<section id="unnormalized-target-and-proposal-distribution" class="level3">
<h3 class="anchored" data-anchor-id="unnormalized-target-and-proposal-distribution">Unnormalized target and proposal distribution</h3>
<p>Often, it is not possible to normalize a probabilistic model. So we only know <span class="math inline">\(p^*(x)\)</span> and <span class="math inline">\(q^*(x)\)</span> with</p>
<p><span class="math display">\[
\begin{aligned}
    p(x) &amp;= \frac{p^*(x)}{Z_p}\,\,\,\text{with}\,\,\, Z_p = \int_{\mathcal X} p^*(x)\, dx &lt; \infty\\
    q(x) &amp;= \frac{q^*(x)}{Z_q}\,\,\,\text{with}\,\,\, Z_q = \int_{\mathcal X} q^*(x)\, dx &lt; \infty\, .
\end{aligned}
\]</span></p>
<p>The condition that has to be satisfied is now</p>
<p><span class="math display">\[
p^*(x) \le M q^*(x)\,\,\, \Rightarrow M \ge Z_p/Z_q\, .
\]</span></p>
<p>In analogy to Eq. (<a href="#eq-rejection_accprob">Equation&nbsp;23</a>), the acceptance probability changes to</p>
<p><span class="math display">\[
r(x) = \frac{p^*(x)}{M q^*(x)} \le 1
\]</span></p>
<p>Otherwise the sampling procedure and the proof of its validity work in the same fashion:</p>
<p><span class="math display">\[
p(x, a=1) = q(x)\, r(x) = \frac{q^*(x)}{Z_q} \frac{p^*(x)}{M q^*(x)} = \frac{p^*(x)}{MZ_q}
\]</span></p>
<p>and</p>
<p><span class="math display">\[
p(a=1) = \int_{\mathcal X} p(x, a=1)\, dx = \frac{Z_p}{MZ_q}\, .
\]</span></p>
<p>So <span class="math display">\[
x^{(s)} \sim \frac{p(x, a=1)}{p(a=1)} = \frac{p^*(x)}{MZ_q}\, \frac{MZ_q}{Z_p} = \frac{p^*(x)}{Z_p} = p(x)\, .
\]</span></p>
</section>
</section>
<section id="importance-sampling" class="level2">
<h2 class="anchored" data-anchor-id="importance-sampling">Importance sampling</h2>
<p>Rejection sampling becomes very inefficient as soon as no tight bound can be found and most samples are rejected. We saw a drastic version of this problem in our attempt to estimate the volume of the <span class="math inline">\(D\)</span>-ball by accepting or rejecting samples from a hypercube: The acceptance probability is the ratio of the volumes of the <span class="math inline">\(D\)</span>-ball and the <span class="math inline">\(D\)</span>-cube and drops to zero with a rate that is exponential in <span class="math inline">\(D\)</span>.</p>
<p><a href="https://en.wikipedia.org/wiki/Importance_sampling"><em>Importance sampling</em></a> tries to overcome some of these problems by using a strategy that does not reject samples, but weighs them thereby avoiding to “waste” any samples. Otherwise the idea of importance sampling is very similar to rejection sampling: A helper distribution <span class="math inline">\(q\)</span> (from which we can sample easily) is used to generate samples that are now reweighted rather than accepted or rejected. The weights are chosen such that samples from <span class="math inline">\(q\)</span> can be used to compute expectations under the target model <span class="math inline">\(p\)</span>.</p>
<p>To derive importance sampling, let us look at the expectation</p>
<p><span class="math display">\[
\mathbb E_p[f] = \int_{\mathcal X} f(x)\, p(x)\, dx = \int_{\mathcal X} f(x)\, \frac{p(x)}{q(x)}\, q(x)\, dx = \int_{\mathcal X} f(x)\, w(x)\, q(x)\, dx = \mathbb E_q[wf]\, .
\]</span></p>
<p>So expectations with respect to <span class="math inline">\(p\)</span> can be expressed as expectations with respect to <span class="math inline">\(q\)</span>, if samples <span class="math inline">\(x\)</span> are weighted with <span class="math inline">\(w(x) = \frac{p(x)}{q(x)}\)</span>. The only requirement is</p>
<p><span class="math display">\[
q(x) = 0\,\,\, \Rightarrow\,\,\, f(x)p(x) = 0
\]</span></p>
<p>which is easier to satisfy than the requirements for rejection sampling.</p>
<section id="algorithm-importance-sampling" class="level3">
<h3 class="anchored" data-anchor-id="algorithm-importance-sampling">Algorithm: Importance sampling</h3>
<p>The algorithm produces random samples <span class="math inline">\(x^{(s)}\)</span> and (importance) weights <span class="math inline">\(w^{(s)}\)</span>:</p>
<ol type="1">
<li><p>Sample <span class="math inline">\(x^{(s)} \sim q(x)\)</span> for <span class="math inline">\(s=1,\ldots, S\)</span>.</p></li>
<li><p>Compute weights <span class="math inline">\(w^{(s)} = \frac{p(x^{(s)})}{q(x^{(s)})}\)</span></p></li>
</ol>
<p>Expectation values are then approximated by</p>
<p><span id="eq-IS"><span class="math display">\[
    \mathbb E_p[f] \approx \hat f_{\text{IS}} := \frac{1}{S} \sum_{s=1}^S w^{(s)} \, f(x^{(s)})
\tag{25}\]</span></span></p>
<p>The right hand side can be interpreted as the expectation of <span class="math inline">\(f\)</span> under the approximate density</p>
<p><span id="eq-is-approximation"><span class="math display">\[
    \hat p_S(x) = \frac{1}{S} \sum_{s=1}^S w^{(s)} \delta\bigl(x - x^{(s)}\bigr)\, .
\tag{26}\]</span></span></p>
<p>This is a generalization of the approximate density introduced earlier in Eq. (<a href="#eq-approximate_pdf">Equation&nbsp;5</a>).</p>
<p>Let us again use a Gaussian target and a Cauchy proposal to illustrate the sampling algorithm:</p>
<div class="cell" data-execution_count="29">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sample_cauchy(S, lower<span class="op">=-</span><span class="dv">10</span>, upper<span class="op">=</span><span class="dv">10</span>):</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>    u <span class="op">=</span> np.random.random(<span class="dv">2</span><span class="op">*</span><span class="bu">int</span>(S))</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> <span class="op">-</span>np.tan(np.pi <span class="op">*</span> u)</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> (x <span class="op">&gt;=</span> lower) <span class="op">&amp;</span> (x <span class="op">&lt;=</span> upper)</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x[m][:<span class="bu">int</span>(S)]</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> pdf_gaussian(x):</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.exp(<span class="op">-</span><span class="fl">0.5</span><span class="op">*</span>x<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> np.sqrt(<span class="dv">2</span><span class="op">*</span>np.pi)</span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> pdf_cauchy(x):</span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.pi <span class="op">/</span> (<span class="dv">1</span> <span class="op">+</span> x<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> <span class="bu">int</span>(<span class="fl">5e3</span>)</span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.linspace(<span class="op">-</span><span class="fl">1.</span>, <span class="fl">1.</span>, <span class="dv">1000</span>) <span class="op">*</span> <span class="dv">5</span></span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> pdf_gaussian(t)</span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true" tabindex="-1"></a>q <span class="op">=</span> pdf_cauchy(t)</span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> sample_cauchy(S, <span class="op">-</span><span class="dv">20</span>, <span class="dv">20</span>)</span>
<span id="cb34-22"><a href="#cb34-22" aria-hidden="true" tabindex="-1"></a>w <span class="op">=</span> pdf_gaussian(x) <span class="op">/</span> pdf_cauchy(x)</span>
<span id="cb34-23"><a href="#cb34-23" aria-hidden="true" tabindex="-1"></a>kw <span class="op">=</span> <span class="bu">dict</span>(xlim <span class="op">=</span> (<span class="op">-</span><span class="dv">8</span>, <span class="dv">8</span>), xlabel <span class="op">=</span> <span class="vs">r'$x$'</span>)</span>
<span id="cb34-24"><a href="#cb34-24" aria-hidden="true" tabindex="-1"></a>kw_hist <span class="op">=</span> <span class="bu">dict</span>(bins<span class="op">=</span><span class="dv">100</span>, density<span class="op">=</span><span class="va">True</span>, color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.2</span>)</span>
<span id="cb34-25"><a href="#cb34-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-26"><a href="#cb34-26" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">4</span>), sharex<span class="op">=</span><span class="va">True</span>, subplot_kw<span class="op">=</span>kw)</span>
<span id="cb34-27"><a href="#cb34-27" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb34-28"><a href="#cb34-28" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_title(<span class="vs">r'weight $w(x) = p(x) / q(x)$'</span>)</span>
<span id="cb34-29"><a href="#cb34-29" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].plot(t, p <span class="op">/</span> q, color<span class="op">=</span><span class="st">'k'</span>, lw<span class="op">=</span><span class="dv">3</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb34-30"><a href="#cb34-30" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_ylabel(<span class="vs">r'$w(x)$'</span>)</span>
<span id="cb34-31"><a href="#cb34-31" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb34-32"><a href="#cb34-32" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_title(<span class="st">'without importance weights'</span>)</span>
<span id="cb34-33"><a href="#cb34-33" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].hist(x, <span class="op">**</span>kw_hist)</span>
<span id="cb34-34"><a href="#cb34-34" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb34-35"><a href="#cb34-35" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].set_title(<span class="st">'with importance weights'</span>)</span>
<span id="cb34-36"><a href="#cb34-36" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].hist(x, weights<span class="op">=</span>w<span class="op">/</span>S, <span class="op">**</span>kw_hist)</span>
<span id="cb34-37"><a href="#cb34-37" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb34-38"><a href="#cb34-38" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> a <span class="kw">in</span> ax[<span class="dv">1</span>:]:</span>
<span id="cb34-39"><a href="#cb34-39" aria-hidden="true" tabindex="-1"></a>    a.plot(t, p, color<span class="op">=</span><span class="st">'r'</span>, lw<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="vs">r'target $p$'</span>)</span>
<span id="cb34-40"><a href="#cb34-40" aria-hidden="true" tabindex="-1"></a>    a.legend()</span>
<span id="cb34-41"><a href="#cb34-41" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb34-42"><a href="#cb34-42" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-30-output-1.png" width="1142" height="373"></p>
</div>
</div>
</section>
<section id="properties-of-importance-sampling" class="level3">
<h3 class="anchored" data-anchor-id="properties-of-importance-sampling">Properties of importance sampling</h3>
<p>The importance sampling estimator (Eq. <a href="#eq-IS">Equation&nbsp;25</a>) is unbiased: The <span class="math inline">\(S\)</span> samples follow the joint distribution <span class="math inline">\(q_S(x^{(1)}, \ldots, x^{(S)}) = \prod_s q(x^{(s)})\)</span>, and the expectation of the importance sampling estimator is</p>
<p><span class="math display">\[
\mathbb E_{q_S}[\hat f_{\text{IS}}]
= \frac{1}{S} \mathbb E_{q_S}\biggl[\sum_s f(x^{(s)}) p(x^{(s)})/q(x^{(s)})\biggr]
= \frac{1}{S} \sum_s \underbrace{\mathbb E_{q_S}\biggl[f(x^{(s)}) p(x^{(s)})/q(x^{(s)})\biggr]}_{\mathbb E_p[f]}
= \mathbb E_p[f]\, .
\]</span></p>
<p>The law of large numbers guarantees that <span class="math inline">\(\hat f_{\text{IS}} \to \mathbb E_p[f]\)</span> for <span class="math inline">\(S\to\infty\)</span>.</p>
<p>Since the importance sampling (IS) estimator <span class="math inline">\(\hat f_{\text{IS}}\)</span> is simply the Monte Carlo estimator for <span class="math inline">\(w(x)f(x)\)</span> and sampling distribution <span class="math inline">\(q\)</span>, also the variance is readily available from Eq. (<a href="#eq-MCvariance">Equation&nbsp;9</a>):</p>
<p><span class="math display">\[
\text{var}[\hat f_{\text{IS}}] = \frac{1}{S} \text{var}_q[wf] \, .
\]</span></p>
<p>Using <span class="math inline">\(\text{var}[f] = \mathbb E[f^2] - (\mathbb E[f])^2\)</span>, we obtain</p>
<p><span class="math display">\[
\text{var}_q[wf] = \underbrace{\mathbb E_q[(wf)^2]}_{\mathbb E_p[wf^2]} - \bigl(\underbrace{\mathbb E_q[wf]}_{\mathbb E_p[f]}\bigr)^2 = \mathbb E_p[wf^2] - \bigl( \mathbb E_p[f] \bigr)^2
\]</span></p>
<p><span id="eq-ISvariance"><span class="math display">\[
    \text{var}[\hat f_{\text{IS}}] = \frac{1}{S} \biggl( \mathbb E_p[wf^2] - \bigl( \mathbb E_p[f] \bigr)^2 \biggr)\, .
\tag{27}\]</span></span></p>
<p>Like the error of the standard Monte Carlo approximation, the error of the IS estimator shrinks with <span class="math inline">\(1/\sqrt{S}\)</span>. We can also minimize the variance of the IS estimator as a functional of the proposal distribution (subject to the constraint <span class="math inline">\(\int q(x)\, dx = 1\)</span>), which can be achieved by minimizing the Lagrangian <span class="math inline">\(\mathbb E_p[p/q\, f^2] + \lambda (1-\int q(x) dx)\)</span> resulting in the optimal IS proposal:</p>
<p><span class="math display">\[
q_{\text{opt}}(x) \propto |f(x)|\, p(x)\, .
\]</span></p>
<p>This estimator achieves minimum variance <span class="math display">\[
\left(\mathbb E_p[|f|] \right)^2 - \left(\mathbb E_p[f] \right)^2
\]</span></p>
<p>which can approach zero if <span class="math inline">\(f(x) \ge 0\)</span>. However, this result is mostly of theoretical interest.</p>
</section>
<section id="comparison-between-classical-monte-carlo-and-importance-sampling" class="level3">
<h3 class="anchored" data-anchor-id="comparison-between-classical-monte-carlo-and-importance-sampling">Comparison between classical Monte Carlo and importance sampling</h3>
<ul>
<li><p>Importance sampling should be used when we cannot sample efficiently from the target model <span class="math inline">\(p\)</span></p></li>
<li><p>A reason to use importance sampling can be to reduce the variance over the classical Monte Carlo estimator</p></li>
<li><p>Importance sampling can be used if rejection sampling is not applicable (because we cannot find an upper bound for the ratio <span class="math inline">\(p(x)/q(x)\)</span>)</p></li>
</ul>
</section>
<section id="self-normalized-importance-sampling" class="level3">
<h3 class="anchored" data-anchor-id="self-normalized-importance-sampling">Self-normalized importance sampling</h3>
<p>In case of complex, high-dimensional probabilistic models the normalizing constants are often missing:</p>
<p><span class="math display">\[
p(x) = \frac{p^*(x)}{Z_p}, \, q(x) = \frac{q^*(x)}{Z_q}
\]</span></p>
<p>with <span class="math inline">\(Z_p = \int p^*(x)\, dx\)</span> and <span class="math inline">\(Z_q = \int q^*(x)\, dx\)</span>.</p>
<p>In this case the importance weights</p>
<p><span class="math display">\[
w(x) = \frac{p(x)}{q(x)} = \frac{Z_q}{Z_p} \frac{p^*(x)}{q^*(x)}
\]</span></p>
<p>are not readily available, because the ratio of normalizing constants <span class="math inline">\(Z_q/Z_p\)</span> is unknown.</p>
<p>However, we can use importance sampling to estimate this unknown ratio:</p>
<p><span class="math display">\[
\frac{Z_p}{Z_q} = \frac{\int p^*(x)\, dx}{Z_q} = \frac{\int \frac{p^*(x)}{q^*(x)}\, q^*(x)\, dx}{Z_q} = \int \frac{p^*(x)}{q^*(x)} \, q(x)\, dx = \mathbb E_q[p^*/q^*]
\]</span></p>
<p>The IS estimator for the ratio of normalizing constants is</p>
<p><span id="eq-ISratio"><span class="math display">\[
    (\widehat{Z_p/Z_q})_{\text{IS}} = \frac{1}{S} \sum_{s=1}^S \frac{p^*(x^{(s)})}{q^*(x^{(s)})} \, .
\tag{28}\]</span></span></p>
<p>Plugging this estimator into standard IS estimator (Eq. <a href="#eq-IS">Equation&nbsp;25</a>) yields the <em>self-normalized</em> importance sampling (NIS) estimator</p>
<p><span id="eq-ISselfnormalized"><span class="math display">\[
\hat f_{\text{NIS}} = \frac{\sum_{s=1}^S \frac{p^*(x^{(s)})}{q^*(x^{(s)})}\, f(x^{(s)})}{ \sum_{s=1}^S \frac{p^*(x^{(s)})}{q^*(x^{(s)})}} = \frac{\sum_{s=1}^S w^{(s)}\, f(x^{(s)})}{ \sum_{s=1}^S w^{(s)}}
\tag{29}\]</span></span></p>
<p>In contrast to <span class="math inline">\(\hat f_{\text{IS}}\)</span>, the self-normalized IS estimator <span class="math inline">\(\hat f_{\text{NIS}}\)</span> is biased, but strongly consistent, meaning that for <span class="math inline">\(S\to\infty\)</span> the NIS estimator converges to the correct estimate: <span class="math inline">\(\hat f_{\text{NIS}} \to \mathbb E_p[f]\)</span>. The asymptotic variance of the estimator can be approximated by</p>
<p><span id="eq-NISvar"><span class="math display">\[
\text{var}_{\text{as}}[\hat f_{\text{NIS}}] =  \frac{\frac{1}{S} \sum_s [w^{(s)}]^2 \bigl(f(x^{(s)}) - \hat f_{\text{NIS}}\bigr)^2}{\bigl[\frac{1}{S} \sum_s w^{(s)}\bigr]^2}\, .   
\tag{30}\]</span></span></p>
</section>
<section id="effective-sample-size" class="level3">
<h3 class="anchored" data-anchor-id="effective-sample-size">Effective sample size</h3>
<p>The <a href="https://en.wikipedia.org/wiki/Effective_sample_size">effective sample size (ESS)</a> is the number of <em>independent</em> samples <span class="math inline">\(S_{\text{eff}}\)</span> that would result in the same variance as the NIS estimator (Eq. <a href="#eq-NISvar">Equation&nbsp;30</a>). To compute ESS, we match the asymptotic variance of <span class="math inline">\(\hat f_{\text{NIS}}\)</span> with the variance resulting from <span class="math inline">\(S_{\text{eff}}\)</span>:</p>
<p><span class="math display">\[
\frac{1}{S} \text{var}_{\text{as}}[\hat f_{\text{NIS}}] = \frac{\sum_s \bigl[w^{(s)}\bigr]^2 \bigl(f(x^{(s)}) - \hat f_{\text{NIS}} \bigr)^2}{\bigl[\sum_s w^{(s)}\bigr]^2} = \frac{\sigma^2}{S_{\text{eff}}}
\]</span></p>
<p>where <span class="math inline">\(\sigma^2 = \text{var}_p[f]\)</span>. For <span class="math inline">\(f(x^{(s)}) - \hat f_{\text{NIS}} \approx \sigma\)</span>, we obtain:</p>
<p><span id="eq-ESS"><span class="math display">\[
S_{\text{eff}} = \frac{\bigl[\sum_s w^{(s)}\bigr]^2}{\sum_s \bigr[w^{(s)}\bigl]^2}
\tag{31}\]</span></span></p>
<p>The two extreme cases are:</p>
<ol type="1">
<li><p>All importance weights are the same, <span class="math inline">\(w^{(s)} = 1/S\)</span>, in which case <span class="math inline">\(S_{\text{eff}} = S\)</span>.</p></li>
<li><p>All but one weight are zero, <span class="math inline">\(w^{(1)} = 1\)</span> and <span class="math inline">\(w^{(s)} = 0\)</span> for <span class="math inline">\(s\ge 2\)</span>, in which case <span class="math inline">\(S_{\text{eff}} = 1\)</span>.</p></li>
</ol>
<p>ESS can be used as a diagnostic for the performance of importance sampling. The larger ESS, the more reliable are the estimates.</p>
</section>
</section>
<section id="drawbacks-of-importance-and-rejection-sampling" class="level2">
<h2 class="anchored" data-anchor-id="drawbacks-of-importance-and-rejection-sampling">Drawbacks of importance and rejection sampling</h2>
<p>Both rejection and importance sampling in <em>high dimensions</em> <span class="math inline">\(D\)</span> often suffer from various difficulties. High-dimensional probabilities tend to concentrate around a <a href="https://en.wikipedia.org/wiki/Typical_set"><em>typical set</em></a>. This is a general feature of high-dimensional probabilistic models, also known as <a href="https://en.wikipedia.org/wiki/Concentration_of_measure"><em>concentration of measure</em></a>. The most likely sets need <strong>not</strong> be members of the typical set, which can be counter-intuitive. In case of a <span class="math inline">\(D\)</span>-dimensional standard Gaussian <span class="math inline">\(\mathcal N(0, I_D)\)</span> (where <span class="math inline">\(I_D\)</span> is the <span class="math inline">\(D\)</span>-dimensional identity matrix) we have:</p>
<p><span class="math display">\[
\mathbb E[\|x\|^2] = \text{tr}I_D = D\, .
\]</span></p>
<p>This means that most states will have a distance of <span class="math inline">\(\sqrt{D}\)</span> from the origin, whereas the most likely state, <span class="math inline">\(x=0\)</span>, has zero distance. This phenomenon has been described as <a href="https://www.inference.vc/high-dimensional-gaussian-distributions-are-soap-bubble/">“high-dimensional Gaussian are soap bubbles”</a>.</p>
<p>To understand the implications for rejection and importance sampling, let us look at a toy example with Gaussian target and proposal in <span class="math inline">\(D\)</span> dimensions:</p>
<p><span class="math display">\[
p(x) = \mathcal N\bigl(0, I_D\bigr),\,\,\, q(x) = \mathcal N\bigl(0, \sigma^2 I_D\bigr), \,\,\, \sigma\ge 1\, .
\]</span></p>
<p>The ratio of both distributions is</p>
<p><span class="math display">\[
w(x) = \sigma^D \exp\left\{-\frac{\|x\|^2}{2} \bigl(1 - \sigma^{-2}\bigr)  \right\} \le \sigma^D = M\, .
\]</span></p>
<p>An implication for rejection sampling is that the acceptance probability <span class="math inline">\(p(a=1) = \sigma^{-D}\)</span> decays exponentially in <span class="math inline">\(D\)</span>, likewise the time we have to wait to generate a sample that can be accepted increases exponentially in <span class="math inline">\(D\)</span>.</p>
<p>The implications for importance sampling are similarly bad: The average importance weight is</p>
<p><span class="math display">\[
\mathbb E_q[w] = 1
\]</span></p>
<p>independent of <span class="math inline">\(D\)</span>, but the variance</p>
<p><span class="math display">\[
\text{var}[w] = \mathbb E_q[w^2] - \bigl(\mathbb E_q[w]\bigr)^2 = \left(\frac{\sigma^4}{2\sigma^2-1}\right)^{D/2} - 1
\]</span></p>
<p>grows exponentially in <span class="math inline">\(D\)</span>, since</p>
<p><span class="math display">\[
\frac{\sigma^4}{2\sigma^2 -1} \ge 1
\]</span></p>
<p>for <span class="math inline">\(\sigma &gt; 1\)</span>.</p>
<p>(To see the previous inequality: <span class="math inline">\(0 \le (\sigma^2 - 1)^2 = \sigma^4 - 2\sigma^2 + 1 \,\,\Rightarrow\,\, \sigma^4 &gt; 2\sigma^2 - 1\)</span>. If <span class="math inline">\(\sigma&gt;1\)</span>, then <span class="math inline">\(2\sigma^2 - 1 &gt; 0\)</span> and we can divide the last inequality by this factor without changing the direction.)</p>
<div class="cell" data-execution_count="30">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>sigma <span class="op">=</span> np.linspace(<span class="fl">1.</span>, <span class="fl">5.</span>, <span class="dv">100</span>) </span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>w2 <span class="op">=</span> sigma<span class="op">**</span><span class="dv">4</span> <span class="op">/</span> (<span class="fl">2.</span><span class="op">*</span>sigma<span class="op">**</span><span class="dv">2</span> <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>ax.plot(sigma, w2, color<span class="op">=</span><span class="st">'k'</span>, lw<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>ax.axhline(<span class="fl">1.</span>, ls<span class="op">=</span><span class="st">'--'</span>, color<span class="op">=</span><span class="st">'r'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="vs">r'$\sigma$'</span>)</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="vs">r'$E_q[w^2]$'</span>)</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>ax.set_ylim(<span class="fl">0.</span>, <span class="va">None</span>)</span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-31-output-1.png" width="660" height="470"></p>
</div>
</div>
<p>The effective sample size is</p>
<p><span class="math display">\[
ESS = \frac{\bigl(\mathbb E_q[w]\bigr)^2}{\mathbb E_q[w^2]} = \left(\frac{\sigma^4}{2\sigma^2-1}\right)^{-D/2}
\]</span></p>
<p>and decays with <span class="math inline">\(D\)</span>.</p>
<p>To see this more directly, let’s try to characterize the typical set of a Gaussian model <span class="math inline">\(\mathcal N\bigl(0, \sigma^2 I_D\bigr)\)</span>. Since the distribution is spherically symmetric, the distance from the center, <span class="math inline">\(r=\|x\|\)</span>, follows the distribution</p>
<p><span class="math display">\[
p(r) \propto r^{D-1} e^{-r^2/2\sigma^2}\, .
\]</span></p>
<p>This implies that the pdf of the squared distance <span class="math inline">\(r^2\)</span> is a <a href="https://en.wikipedia.org/wiki/Gamma_distribution">Gamma distribution</a> with shape parameter <span class="math inline">\(D/2\)</span> and scale <span class="math inline">\(2\sigma^2\)</span>, therefore</p>
<p><span class="math display">\[
\mathbb E[\|x\|^2] = D\sigma^2, \,\,\, \text{var}[\|x\|^2] = 2\sigma^4 D .
\]</span></p>
<p>The typical set is characterized by states with</p>
<p><span class="math display">\[
\|x\|^2 \approx \sigma^2 \bigl(D \pm \sqrt{2D}\bigr) = \sigma^2 D \bigl(1 \pm \sqrt{2/D}\bigr)\, .
\]</span></p>
<p>These states have an ever increasing distance from the origin, <span class="math inline">\(\sim \sigma\sqrt{D}\)</span>, and concentrate in spherical shells that become thinner and thinner as <span class="math inline">\(D\)</span> increases. It will therefore be increasingly difficult to match the typical sets of the proposal and target pdf. At the same time, weights will fluctuate by factors of <span class="math inline">\(\exp\{\pm\sqrt{2D}\}\)</span>, resulting in only a few dominant states and an effective sample size that drops to one.</p>
<p>If we compare the probability of the maximum probability state <span class="math inline">\(x_{\max} = 0\)</span> with the probability of an element <span class="math inline">\(x_{\text{typical}}\)</span> of the typical set, we get:</p>
<p><span class="math display">\[
\frac{p(x_{\text{typical}})}{p(x_{\max})} \simeq \exp\left\{-\frac{1}{2}(D \pm \sqrt{2D}) \right\}
\]</span></p>
<p>In summary, the two major problems of importance sampling are:</p>
<ul>
<li><p>Finding a good proposal <span class="math inline">\(q\)</span> whose typical set (region of states <span class="math inline">\(x\)</span> that are representative of <span class="math inline">\(q\)</span>) overlaps with the typical set of the target <span class="math inline">\(p\)</span></p></li>
<li><p>Weights are likely to vary by large factors, because the probabilities of points in a typical set, although similar to each other, still differ by factors of order <span class="math inline">\(\exp(\sqrt{D})\)</span>, so the weights will too, unless <span class="math inline">\(q\)</span> is a near-perfect approximation to <span class="math inline">\(p\)</span></p></li>
</ul>
</section>
</section>
<section id="lecture-4-markov-chain-monte-carlo" class="level1">
<h1>Lecture 4: Markov chain Monte Carlo</h1>
<section id="outline-3" class="level2">
<h2 class="anchored" data-anchor-id="outline-3">Outline</h2>
<ul>
<li>Markov chains</li>
</ul>
</section>
<section id="where-do-we-stand" class="level2">
<h2 class="anchored" data-anchor-id="where-do-we-stand">Where do we stand?</h2>
<ul>
<li><p>Monte Carlo approximation: use stochastic simulations to estimate deterministic quantities. Only stochastic and asymptotic guarantees.</p></li>
<li><p>We can design special purpose solutions using variable transformation methods, but these are not broadly applicable. Examples: inversion of cdf, Cartesian to polar coordinates (Box-Muller), affine transformation for general multivariate Gaussians</p></li>
<li><p>We tried to overcome special purpose approaches by using a <em>helper</em> or <em>proposal</em> distribution (rejection and importance sampling)</p></li>
<li><p>Although these approaches are more versatile, we encountered several challenges: Finding a good proposal distribution in the first place. Depending on the method, guarantee that all requirements are met. For example, rejection sampling needs an upper bound on the ratio of target and proposal distribution.</p></li>
<li><p>Major challenges in high dimensions for both rejection and importance sampling</p></li>
</ul>
</section>
<section id="markov-chains" class="level2">
<h2 class="anchored" data-anchor-id="markov-chains">Markov chains</h2>
<p>Up to this point, we have only considered sampling approaches based on identically and independently distributed samples: all <span class="math inline">\(x^{(s)}\)</span> are generated from the same distribution independent of each other, either by drawing from</p>
<p><span class="math display">\[
x^{(s)}\sim p(x)
\]</span></p>
<p>where <span class="math inline">\(p(x)\)</span> is the target distribution, or by drawing from</p>
<p><span class="math display">\[
x^{(s)}\sim q(x)
\]</span></p>
<p>where <span class="math inline">\(q(x)\)</span> is a proposal or helper distribution.</p>
<p>The idea of <a href="https://en.wikipedia.org/wiki/Markov_chain_Monte_Carlo"><strong>Markov chain Monte Carlo (MCMC)</strong></a> methods is to give up the <em>independence</em> of successive samples and generate sequences of states where <span class="math inline">\(x^{(s)}\)</span> depends on the previous sample <span class="math inline">\(x^{(s-1)}\)</span>. Our hope is that also when introducing these correlations, the Monte Carlo approximation</p>
<p><span id="eq-MCapproximation"><span class="math display">\[
\frac{1}{S} \sum_{s=1}^S f\bigl(x^{(s)}\bigr) \approx \mathbb E_p[f]
\tag{32}\]</span></span></p>
<p>is still valid. This is justified by our intuition that as long as we run the simulation long enough correlations between two states <span class="math inline">\(x^{(s')}\)</span> and <span class="math inline">\(x^{(s)}\)</span> will vanish with large <span class="math inline">\(|s'-s|\)</span>, and the samples <span class="math inline">\(x^{(s)}\)</span> will approximately follow <span class="math inline">\(p(x)\)</span> for large <span class="math inline">\(s\)</span></p>
<p>In the following, we will restrict ourselves to <em>discrete</em> sample spaces <span class="math inline">\(\mathcal X\)</span> (finite or countably infinite). Markov chains defined on continuous sample spaces can be treated in a similar, yet mathematically much more involved fashion (measure theory, etc.).</p>
<section id="definition-of-markov-chains" class="level3">
<h3 class="anchored" data-anchor-id="definition-of-markov-chains">Definition of Markov chains</h3>
<p>Markov chains are models for dynamical systems with possibly uncertain transitions between various system states. In our context, the state space of the stochastic dynamics is the sample space <span class="math inline">\(\mathcal X\)</span>.</p>
<p>A (first order) <a href="https://en.wikipedia.org/wiki/Markov_chain"><em>Markov chain</em></a> is a <em>memoryless</em> stochastic process <span class="math inline">\(\left(x^{(s)}\right)_{s\ge 0}\)</span> that has the following <a href="https://en.wikipedia.org/wiki/Markov_property">property</a></p>
<p><span id="eq-MarkovChain"><span class="math display">\[
\Pr\bigl(x^{(s+1)} \mid x^{(s)}, \ldots, x^{(1)}\bigr) = \Pr\bigl(x^{(s+1)} \mid x^{(s)}\bigr)
\tag{33}\]</span></span></p>
<p>with <span class="math inline">\(x^{(s)} \in \mathcal X\)</span>. That is, the probability of finding the system in state <span class="math inline">\(x^{(s+1)}\)</span> only depends on the <em>last</em> state <span class="math inline">\(x^{(s)}\)</span>, not on the previous states before the last state. In this sense, Markov chains have no memory. A Markov chain is uniquely characterized by</p>
<ol type="1">
<li><p>the <em>distribution of the initial state</em> <span class="math inline">\(x^{(0)} \sim p^{(0)}\)</span> and</p></li>
<li><p>the <em>transition probabilities</em> <span class="math inline">\(\Pr(y\mid x)\)</span> for all <span class="math inline">\(x, y \in \mathcal X\)</span>.</p></li>
</ol>
<p>Note that we are dealing with <em>time-homogeneous</em> Markov chains whose transition probabilities do not depend on <span class="math inline">\(s\)</span>.</p>
<p><em>Remark:</em> I am here sticking to our convention of using the superscript <span class="math inline">\((\cdot)^{(s)}\)</span> to denote samples, because we will later use Markov chains to generate samples from a probabilistic model. However, at this point we should think of <span class="math inline">\(s\)</span> as a discrete time.</p>
</section>
<section id="graph-representation" class="level3">
<h3 class="anchored" data-anchor-id="graph-representation">Graph representation</h3>
<p>Due to its simple structure, Markov chains can be represented as directed graphs where the nodes of the graph represent the different states in <span class="math inline">\(\mathcal X\)</span> and the edges transition probabilities between nodes <span class="math inline">\(y\)</span> and <span class="math inline">\(x\)</span> that are greater than zero, i.e.&nbsp;if <span class="math inline">\(\Pr(x\mid y) &gt; 0\)</span>, then we introduce an arrow between <span class="math inline">\(y\)</span> and <span class="math inline">\(x\)</span>. These graphs are called <em>transition graphs</em>.</p>
<p>For example the two-state Markov chain with transition probabilities <span class="math inline">\(\Pr(x_2\mid x_1) = \alpha\)</span> and <span class="math inline">\(\Pr(x_1\mid x_2)=\beta\)</span> can be represented by the transition graph:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<figure class="figure">
<img src="images/twostate.png" title="Two-state Markov model" class="img-fluid figure-img">
</figure>
<p></p><figcaption class="figure-caption">Two-state model</figcaption><p></p>
</figure>
</div>
</section>
<section id="transition-matrix" class="level3">
<h3 class="anchored" data-anchor-id="transition-matrix">Transition matrix</h3>
<p>Since the transition probability depends only on the last state, we can summarize all probabilities in a <em>transition matrix</em></p>
<p><span id="eq-transition-matrix"><span class="math display">\[
    P(x, y) = \Pr(x \mid y)
\tag{34}\]</span></span></p>
<p>For continuous sample spaces, the transition matrix becomes a transition operator or <a href="https://en.wikipedia.org/wiki/Markov_kernel">Markov kernel</a>. For the above two-state system we have</p>
<p><span id="eq-twostate"><span class="math display">\[
P(x, y) = \begin{pmatrix}
1 - \alpha &amp; \beta \\
\alpha &amp; 1 - \beta \\
\end{pmatrix}
\tag{35}\]</span></span></p>
<p>where <span class="math inline">\(\alpha, \beta \in [0, 1]\)</span>.</p>
<p>In discrete sample spaces, <span class="math inline">\(P(x, y)\)</span> is the probability that we jump from state <span class="math inline">\(y\in\mathcal X\)</span> to state <span class="math inline">\(x\in\mathcal X\)</span>. Because we are dealing with conditional probabilities, we have</p>
<p><span id="eq-transition-matrix2"><span class="math display">\[
\sum_{x\in\mathcal X} P(x, y) = 1, \,\,\, P(x, y) \ge 0\, .
\tag{36}\]</span></span></p>
<p>The first condition can be written in matrix-vector notation</p>
<p><span id="eq-leftstochastic"><span class="math display">\[
\mathbb 1^T\!P = \mathbb 1^T
\tag{37}\]</span></span></p>
<p>where</p>
<p><span id="eq-one"><span class="math display">\[
\mathbb 1 = \begin{pmatrix}
1 \\
\vdots\\
1\\
\end{pmatrix}
\tag{38}\]</span></span></p>
<p>is a column vector whose elements are all one, and <span class="math inline">\(P\)</span> is the transition matrix. Non-negative square matrices that satisfy condition (<a href="#eq-leftstochastic">Equation&nbsp;37</a>) are called <a href="https://en.wikipedia.org/wiki/Stochastic_matrix"><em>(left) stochastic</em></a> matrices. The qualifier “left” stems from the fact that the <em>columns</em> of <span class="math inline">\(P(x, y)\)</span> are probability vectors, so multiplication with <span class="math inline">\(\mathbb 1^T\)</span> from the left produces one for each column.</p>
<section id="left-versus-right-stochastic-matrices" class="level4">
<h4 class="anchored" data-anchor-id="left-versus-right-stochastic-matrices">Left versus right stochastic matrices</h4>
<ul>
<li><p>Beware that there are different conventions for how to define transition matrices. Mathematicians tend to use the convention <span class="math inline">\(P(x, y) = \Pr(y\mid x)\)</span>, whereas Physicists tend to use <span class="math inline">\(P(x, y) = \Pr(x\mid y)\)</span>. In the first case, the row sums are one, whereas in the second case the column sums are one.</p></li>
<li><p>Note that, as a consequence of the previous comment, in the mathematics literature, and probably also the computer science literature, transition matrices of first-order Markov processes are <em>right stochastic</em>. Here, we follow the physics convention of using <em>left stochastic</em> transition matrices to represent the transition probabilities of Markov processes. One reason is that in the left stochastic convention the position of the arguments in <span class="math inline">\(P(x, y)\)</span> directly reflects the dependence in the conditional probability <span class="math inline">\(\Pr(x\mid y)\)</span>. Another reason is that we will later see that some of the <em>right</em> eigenvectors of <span class="math inline">\(P\)</span> (in the left stochastic convention) play a crucial role (stationary distributions). Linear algebra packages typically compute right eigenvectors (so we don’t have to remember to transpose the matrix when we compute eigenvectors…)</p></li>
</ul>
</section>
</section>
<section id="eigenvalues-of-transition-matrices" class="level3">
<h3 class="anchored" data-anchor-id="eigenvalues-of-transition-matrices">Eigenvalues of transition matrices</h3>
<p>A direct consequence of the stochasticity of the transition matrix of a Markov chain is that the absolute value (<a href="https://en.wikipedia.org/wiki/Absolute_value">modulus</a>) of the (complex) eigenvalues <span class="math inline">\(\lambda\)</span> of <span class="math inline">\(P\)</span> are smaller than or equal to one.</p>
<p>This is straightforward to see: Let <span class="math inline">\(u\)</span> be a left eigenvector of <span class="math inline">\(P\)</span> with <span class="math inline">\(u^T\!P = \lambda u^T\)</span>. Therefore,</p>
<p><span class="math display">\[
\lambda u(x) = \sum_{y\in \mathcal X} P(y, x) u(y)\,\,\, \Rightarrow\,\,\, |\lambda|  = \left|\sum_{y\in \mathcal X} P(y, x) \frac{u(y)}{|u(x)|}\right|
\]</span></p>
<p>for all <span class="math inline">\(x\)</span> with <span class="math inline">\(|u(x)|&gt;0\)</span>. If we pick the element <span class="math inline">\(x\)</span> with the largest absolute value, then all ratios <span class="math inline">\(|u(y)/u(x)|\)</span> are smaller than or equal to one. Therefore, by applying the triangle inequality we get</p>
<p><span class="math display">\[
|\lambda| \le \sum_{y\in \mathcal X} |P(y, x)|\, |u(y)|/|u(x)| \le \sum_{y\in\mathcal X} P(y, x) = 1\, .
\]</span></p>
<p>We see that <span class="math inline">\(\mathbb 1\)</span> is a left eigenvector that attains the maximum (absolute) eigenvalue.</p>
<p>Since left and right eigenvectors have the same eigenvalues, the above upper limit is also valid for right eigenvalues (the <a href="https://en.wikipedia.org/wiki/Characteristic_polynomial">characteristic polynomials</a> of <span class="math inline">\(P\)</span> and <span class="math inline">\(P^T\)</span> are the identical).</p>
</section>
<section id="simulation-of-markov-chains" class="level3">
<h3 class="anchored" data-anchor-id="simulation-of-markov-chains">Simulation of Markov chains</h3>
<p>The algorithm for simulating a Markov chain is very simple:</p>
<ol type="1">
<li><p><span class="math inline">\(x^{(0)} \sim p^{(0)}(x)\)</span></p></li>
<li><p><span class="math inline">\(x^{(s+1)} \sim P\bigl(x, x^{(s)}\bigr)\)</span></p></li>
</ol>
<p>In the first step, <span class="math inline">\(p^{(0)}\)</span> is the initial distribution of states, for example a uniform distribution. In the second step, we simply pick the column vector corresponding to state <span class="math inline">\(x^{(s)}\)</span> and draw a random sample from it. This generates a random walk on the graph representing a Markov chain. We have previously discussed how to sample states according to a pmf by using uniformly distributed pseudo-random numbers:</p>
<div class="cell" data-execution_count="31">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pylab <span class="im">as</span> plt</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>plt.rc(<span class="st">'font'</span>, size<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> transition_matrix(alpha, beta):</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array([[<span class="dv">1</span><span class="op">-</span>alpha, beta], </span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>                     [alpha, <span class="dv">1</span><span class="op">-</span>beta]])</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sample_chain(S, alpha<span class="op">=</span><span class="fl">0.5</span>, beta<span class="op">=</span><span class="fl">0.5</span>, x0<span class="op">=</span><span class="dv">0</span>):</span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> [x0]</span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a>    P <span class="op">=</span> transition_matrix(alpha, beta)</span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="bu">len</span>(X) <span class="op">&lt;</span> S:</span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> P[:,X[<span class="op">-</span><span class="dv">1</span>]]</span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a>        X.append(np.random.multinomial(<span class="dv">1</span>, p).argmax())</span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array(X)</span>
<span id="cb36-17"><a href="#cb36-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-18"><a href="#cb36-18" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb36-19"><a href="#cb36-19" aria-hidden="true" tabindex="-1"></a>kw <span class="op">=</span> <span class="bu">dict</span>(yticks<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">1</span>], ylim<span class="op">=</span>[<span class="op">-</span><span class="fl">0.1</span>, <span class="fl">1.1</span>], yticklabels<span class="op">=</span>[<span class="st">'$x_1$'</span>, <span class="st">'$x_2$'</span>], xlabel<span class="op">=</span><span class="st">'$s$'</span>)</span>
<span id="cb36-20"><a href="#cb36-20" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">3</span>, <span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">9</span>), subplot_kw<span class="op">=</span>kw)</span>
<span id="cb36-21"><a href="#cb36-21" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> <span class="bu">list</span>(ax.flat)</span>
<span id="cb36-22"><a href="#cb36-22" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, (alpha, beta) <span class="kw">in</span> <span class="bu">enumerate</span>([(<span class="fl">0.5</span>, <span class="fl">0.5</span>), (<span class="fl">0.1</span>, <span class="fl">0.9</span>), (<span class="fl">1.</span>, <span class="fl">1.</span>)]):</span>
<span id="cb36-23"><a href="#cb36-23" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> sample_chain(S, alpha, beta)</span>
<span id="cb36-24"><a href="#cb36-24" aria-hidden="true" tabindex="-1"></a>    ax[i].set_title(<span class="vs">r'$\alpha=</span><span class="sc">{0:.1f}</span><span class="vs">$, $\beta=</span><span class="sc">{1:.1f}</span><span class="vs">$'</span>.<span class="bu">format</span>(alpha, beta))</span>
<span id="cb36-25"><a href="#cb36-25" aria-hidden="true" tabindex="-1"></a>    ax[i].plot(X, color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, marker<span class="op">=</span><span class="st">'o'</span>)<span class="op">;</span></span>
<span id="cb36-26"><a href="#cb36-26" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-32-output-1.png" width="921" height="824"></p>
</div>
</div>
</section>
<section id="distribution-propagation" class="level3">
<h3 class="anchored" data-anchor-id="distribution-propagation">Distribution propagation</h3>
<p>If the initial state <span class="math inline">\(x^{(0)}\)</span> follows <span class="math inline">\(p^{(0)}\)</span>, the marginal distribution of the next state <span class="math inline">\(x^{(1)}\)</span> is</p>
<p><span class="math display">\[
p^{(1)}(x) = \sum_{y\in\mathcal X} P(x, y)\, p^{(0)}(y)\, .
\]</span></p>
<p>The marginal distribution of the <span class="math inline">\((s+1)\)</span>-th state in a Markov chain follows the distribution</p>
<p><span id="eq-marginalMC"><span class="math display">\[
p^{(s+1)}(x) = \sum_{y\in\mathcal X} P(x, y)\, p^{(s)}(y)\, .
\tag{39}\]</span></span></p>
<p>Repeating the same argument for <span class="math inline">\(p^{(s)}\)</span>, we have</p>
<p><span id="eq-marginalMC2"><span class="math display">\[
p^{(s+1)}(x) = \sum_{y, z\in\mathcal X} P(x, y)\, P(y, z) \, p^{(s-1)}(z) =
\sum_{z\in\mathcal X} \left(\sum_{y\in\mathcal X} P(x, y)\, P(y, z) \right) \, p^{(s-1)}(z)\, .
\tag{40}\]</span></span></p>
<p>The expression in brackets, <span class="math inline">\(\sum_{y\in\mathcal X} P(x, y)\, P(y, z)\)</span>, is the transition matrix for making two successive transitions. By generalizing the argument, we obtain the <a href="https://en.wikipedia.org/wiki/Chapman%E2%80%93Kolmogorov_equation">Chapman-Kolmogorov equation</a>.</p>
<p>In matrix-vector notation, we have</p>
<p><span class="math display">\[
p^{(s+1)} = Pp^{(s)}
\]</span></p>
<p>where <span class="math inline">\(p^{(s)}\)</span> are now vectors in the <a href="https://en.wikipedia.org/wiki/Simplex#Probability">probability simplex</a> and <span class="math inline">\(P\)</span> is the transition matrix (always assuming the <em>left stochastic</em> convention in the context of this notebook!).</p>
<p>By applying the argument successively, we obtain a representation of the marginal distribution of the <span class="math inline">\(s\)</span>-th state in terms of <a href="https://mathworld.wolfram.com/MatrixPower.html">matrix powers</a> of the transition matrix:</p>
<p><span class="math display">\[
x^{(s)}\sim P^s p^{(0)}
\]</span></p>
<p>The matrix power <span class="math inline">\(P^s\)</span> is the matrix analog of the power of scalar quantities:</p>
<p><span id="eq-matrix_power"><span class="math display">\[
P^s = \underbrace{P \cdot P\cdots P}_{s\text{ terms}}
\tag{41}\]</span></span></p>
<p>where the dot “<span class="math inline">\(\cdot\)</span>” indicates matrix multiplication. It is straightforward to see that if <span class="math inline">\(P\)</span> is stochastic, then <span class="math inline">\(P^s\)</span> for <span class="math inline">\(s\ge 1\)</span> is also stochastic. The matrix power <span class="math inline">\(P^s\)</span> <em>propagates</em> the distribution of states by <span class="math inline">\(s\)</span> time steps.</p>
<p>Multiplication of the transition matrix <span class="math inline">\(P\)</span> from the right advances a distribution <span class="math inline">\(p^{(s)} \to p^{(s+1)}\)</span>, whereas multiplication from the left corresponds to computing the expectation of some function defined on sample space <span class="math inline">\(\mathcal X\)</span>:</p>
<p><span class="math display">\[
\mathbb E_{p^{(s)}}[f] = \sum_{x\in\mathcal X} f(x) p^{(s)}(x) = \sum_{x\in\mathcal X} f(x) \bigl(P p^{(s-1)}\bigr)(x) = \sum_{x,y\in\mathcal X} f(x) P(x, y) p^{(s-1)}(y) = f^T\!Pp^{(s-1)}
\]</span></p>
</section>
<section id="asymptotic-behavior" class="level3">
<h3 class="anchored" data-anchor-id="asymptotic-behavior">Asymptotic behavior</h3>
<p>What happens if we generate a very long Markov chain? To think about this question, let us represent <span class="math inline">\(P\)</span> using its <a href="https://en.wikipedia.org/wiki/Eigendecomposition_of_a_matrix">eigendecomposition</a>:</p>
<p><span class="math display">\[
P = U \Lambda U^{-1}
\]</span></p>
<p>where <span class="math inline">\(\Lambda\)</span> is a diagonal matrix with eigenvalues of <span class="math inline">\(P\)</span> on the diagonal, and <span class="math inline">\(U\)</span> is a square matrix whose columns are the right eigenvectors of <span class="math inline">\(P\)</span>: <span class="math inline">\(PU = U\Lambda\)</span>.</p>
<p>The marginal distribution of the <span class="math inline">\(S\)</span>-th state is then characterized by</p>
<p><span class="math display">\[
P^S = (U\Lambda U^{-1}) (U\Lambda U^{-1}) \cdots (U\Lambda U^{-1}) = U\Lambda^S U^{-1}\, .
\]</span></p>
<p>We know that the magnitude of the eigenvalues is smaller than or equal to one, <span class="math inline">\(|\lambda| \le 1\)</span>. Let us write <span class="math inline">\(\lambda = |\lambda| \exp(i\varphi)\)</span> with modulus <span class="math inline">\(|\lambda|\)</span> and phase <span class="math inline">\(\varphi\)</span>, then all eigenvalues whose magnitude is <em>strictly</em> smaller than one, will die out in the long run</p>
<p><span class="math display">\[
\lambda^S\overset{S\to\infty}{\,\,\,\,\,\,\longrightarrow\,\,\, 0}\,\,\, \text{if }  \,\,|\lambda| &lt; 1
\]</span></p>
<p>If we keep on taking powers of <span class="math inline">\(P\)</span>, the resulting matrix will converge to a low-rank matrix.</p>
</section>
<section id="stationary-distribution" class="level3">
<h3 class="anchored" data-anchor-id="stationary-distribution">Stationary distribution</h3>
<p>The states with <span class="math inline">\(|\lambda |=1\)</span> play a crucial role in the long term behavior of the Markov chain. The left stochasticity of <span class="math inline">\(P\)</span> is the requirement that <span class="math inline">\(\mathbb 1\)</span> is a left eigenvector with eigenvalue 1. Since left and right eigenvalues coincide, there is at least one <em>right</em> eigenvector <span class="math inline">\(\pi\)</span> with eigenvalue one:</p>
<p><span id="eq-stationary"><span class="math display">\[
P\pi = \pi
\tag{42}\]</span></span></p>
<p>If <span class="math inline">\(\pi\)</span> is normalized such that <span class="math inline">\(\mathbb 1^T\!\pi=1\)</span>, then <span class="math inline">\(\pi\)</span> is a <strong>stationary</strong> or <strong>invariant</strong> distribution of <span class="math inline">\(P\)</span>.</p>
<p>Thanks to the <a href="https://en.wikipedia.org/wiki/Perron%E2%80%93Frobenius_theorem">Perron-Frobenius theorem</a> the elements in <span class="math inline">\(\pi\)</span> all have the same sign. We choose the sign to be positive to obtain a valid probability distribution. Moreover, we normalize <span class="math inline">\(\pi\)</span> to one (remember that the standard normalization for eigenvectors is <span class="math inline">\(u^T\!u=1\)</span>).</p>
<p>The stationary distribution is a <em>fixed point</em> of the propagation dynamics generated by <span class="math inline">\(P\)</span>. If <span class="math inline">\(\pi\)</span> is unique, then it is also called the <em>equilibrium distribution</em> in a physical context.</p>
<p>In the simplest case, we have <span class="math inline">\(P=\pi\mathbb 1^T\)</span>. Simulation of this Markov chain boils down to standard Monte Carlo simulation of <span class="math inline">\(\pi\)</span> (i.e.&nbsp;directly drawing samples from <span class="math inline">\(\pi\)</span>):</p>
<p><span class="math display">\[
x^{(s+1)} \sim \Pr\bigl(x \mid x^{(s)}\bigr) = \pi(x)
\]</span></p>
<p>However, a Markov chain can have more than one stationary distribution. For example, if <span class="math inline">\(P=I\)</span> where <span class="math inline">\(I\)</span> is the identity matrix, then any probability distribution over <span class="math inline">\(\mathcal X\)</span> is stationary. A finite Markov chain always has at least one stationary distribution.</p>
<p>We know that at least one stationary distribution exists. What are the requirements that it is unique?</p>
</section>
<section id="irreducible-markov-chains" class="level3">
<h3 class="anchored" data-anchor-id="irreducible-markov-chains">Irreducible Markov chains</h3>
<p>There are multiple equivalent definitions of the <em>irreducibility</em> of a matrix. A matrix is irreducible, if no subspaces exist that are mapped to themselves under the action of the matrix. An intuitive definition for Markov chains is that the graph representing a Markov chain is fully connected. There are no disconnected components in which the Markov chain cycles without ever exiting into another subspace. If a transition matrix <span class="math inline">\(P\)</span> is reducible, then we can find a <a href="https://en.wikipedia.org/wiki/Permutation_matrix">permutation matrix</a> <span class="math inline">\(\Pi\)</span> that transforms the transition matrix into block lower triangular form:</p>
<p><span class="math display">\[
\Pi\, P\, \Pi^T \not= \begin{pmatrix}
    E &amp; 0 \\ F &amp; G \\
\end{pmatrix}
\]</span> where matrices <span class="math inline">\(E\)</span> and <span class="math inline">\(G\)</span> square matrices. A simple example of a reducible two-state transition matrix is (<span class="math inline">\(\alpha=1/2, \beta=0\)</span>):</p>
<p><span class="math display">\[
P = \begin{pmatrix}
\tfrac{1}{2} &amp; 0 \\
\tfrac{1}{2} &amp; 1 \\
\end{pmatrix}
\]</span></p>
<p>We have <span class="math inline">\(\Pr(x=x_2|y=x_2) = 1\)</span>, so the subspace <span class="math inline">\(\{x_2\}\)</span> is mapped to itself.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<figure class="figure">
<img src="images/twostate_reducible.png" title="Reducible two-state Markov model" class="img-fluid figure-img">
</figure>
<p></p><figcaption class="figure-caption">Reducible two-state model</figcaption><p></p>
</figure>
</div>
<p>This is also an example of an <a href="https://en.wikipedia.org/wiki/Absorbing_Markov_chain"><em>absorbing Markov chain</em></a>, since even if we start in <span class="math inline">\(x=x_1\)</span>, as soon as we enter the second state, we can never escape from that state again.</p>
<p>An alternative definition of an irreducible Markov chain goes as follows: For all pairs <span class="math inline">\(x, y \in \mathcal X\)</span> there exists <span class="math inline">\(s(x,y)\in \mathbb N\)</span> such that</p>
<p><span id="eq-irreducible"><span class="math display">\[
\Pr\bigl(x^{(s)}=x\mid x^{(0)} = y\bigr) = (P^s)(x, y) &gt; 0
\tag{43}\]</span></span></p>
<p>note that <span class="math inline">\(s(x,y)\)</span> is in general different for every pair of states <span class="math inline">\(x, y \in\mathcal X\)</span>. The intuition behind this notion of irreducibility is that “all states can be reached from all other states”. <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.24.9739&amp;rep=rep1&amp;type=pdf">Häggström</a> uses the following terminology: If two states satisfy the irreducibility condition (<a href="#eq-irreducible">Equation&nbsp;43</a>), then <span class="math inline">\(x\)</span> is said to <em>communicate</em> with <span class="math inline">\(y\)</span>, i.e.&nbsp;<span class="math inline">\(y\)</span> can be reached from <span class="math inline">\(x\)</span> in a finite time, which is symbolized by <span class="math inline">\(x\to y\)</span>. Two states <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> <em>intercommunicate</em>, if <span class="math inline">\(x\to y\)</span> and <span class="math inline">\(y\to x\)</span>, which is denoted by <span class="math inline">\(x\leftrightarrow y\)</span> (so there exists a path from <span class="math inline">\(x\)</span> to <span class="math inline">\(y\)</span> with non-vanishing probability, and likewise a path from <span class="math inline">\(y\)</span> back to <span class="math inline">\(x\)</span>). Using this terminology, a Markov chain is irreducible, if <span class="math inline">\(x \leftrightarrow y\)</span> for all <span class="math inline">\(x, y \in \mathcal X\)</span>. This gives us also a hint for verifying irreducibility by checking if the <em>transition graph</em> of a Markov chain is <a href="https://en.wikipedia.org/wiki/Strongly_connected_component">strongly connected</a>.</p>
<p>On the other hand, if a Markov chain is reducible, then the analysis of its long-term behavior can be reduced to the analysis of the long-term behavior of one or more Markov chains with smaller state space.</p>
<p>To illustrate the concept of irreducibility let us come back to the linear congruential generators that we discussed in the context of pseudo random number generation.</p>
<section id="example-lcg-with-bad-magic-numbers" class="level4">
<h4 class="anchored" data-anchor-id="example-lcg-with-bad-magic-numbers">Example: LCG with bad magic numbers</h4>
<p>In lecture 2, we studied linear congruential generators based on the recurrence relation</p>
<p><span id="eq-LCG"><span class="math display">\[
x^{(s+1)} = (a x^{(s)} + c)\, \text{mod}\, m
\tag{44}\]</span></span></p>
<p>with</p>
<ul>
<li><p><strong>modulus</strong> <span class="math inline">\(m &gt; 0\)</span></p></li>
<li><p><strong>multiplier</strong> <span class="math inline">\(a\)</span> where <span class="math inline">\(0 &lt; a &lt; m\)</span></p></li>
<li><p><strong>increment</strong> <span class="math inline">\(c\)</span> where <span class="math inline">\(0 \le c &lt; m\)</span></p></li>
<li><p><strong>seed</strong> <span class="math inline">\(x^{(0)}\)</span> where <span class="math inline">\(0 \le x^{(0)} &lt; m\)</span></p></li>
</ul>
<div class="cell" data-execution_count="32">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="co">"""</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="co">Pseudo random number generator</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="co">"""</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pylab <span class="im">as</span> plt</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> PRNG:</span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""PRNG</span></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a><span class="co">    Pseudo-random number generator implemented as iterator.  Using a linear </span></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a><span class="co">    congruential generator (LCG) to generate random numbers. Default settings</span></span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a><span class="co">    for modulus, multiplier and period are taken from Numerical Recipes. </span></span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a><span class="co">    Example</span></span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a><span class="co">    -------</span></span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true" tabindex="-1"></a><span class="co">    &gt;&gt;&gt; prng = PRNG(maximum=1e4)</span></span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true" tabindex="-1"></a><span class="co">    x = list(prng)</span></span>
<span id="cb37-19"><a href="#cb37-19" aria-hidden="true" tabindex="-1"></a><span class="co">    &gt;&gt;&gt; len(x)</span></span>
<span id="cb37-20"><a href="#cb37-20" aria-hidden="true" tabindex="-1"></a><span class="co">    10000</span></span>
<span id="cb37-21"><a href="#cb37-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-22"><a href="#cb37-22" aria-hidden="true" tabindex="-1"></a><span class="co">    Details:</span></span>
<span id="cb37-23"><a href="#cb37-23" aria-hidden="true" tabindex="-1"></a><span class="co">    * https://en.wikipedia.org/wiki/Linear_congruential_generator</span></span>
<span id="cb37-24"><a href="#cb37-24" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb37-25"><a href="#cb37-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, m<span class="op">=</span><span class="dv">2</span><span class="op">**</span><span class="dv">32</span>, a<span class="op">=</span><span class="dv">1664525</span>, c<span class="op">=</span><span class="dv">1013904223</span>, seed<span class="op">=</span><span class="dv">10</span>, maximum<span class="op">=</span><span class="fl">1e6</span>):</span>
<span id="cb37-26"><a href="#cb37-26" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb37-27"><a href="#cb37-27" aria-hidden="true" tabindex="-1"></a><span class="co">        Parameters</span></span>
<span id="cb37-28"><a href="#cb37-28" aria-hidden="true" tabindex="-1"></a><span class="co">        ----------</span></span>
<span id="cb37-29"><a href="#cb37-29" aria-hidden="true" tabindex="-1"></a><span class="co">        m : int &gt; 0</span></span>
<span id="cb37-30"><a href="#cb37-30" aria-hidden="true" tabindex="-1"></a><span class="co">          modulus or period</span></span>
<span id="cb37-31"><a href="#cb37-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-32"><a href="#cb37-32" aria-hidden="true" tabindex="-1"></a><span class="co">        a : int &gt; 0</span></span>
<span id="cb37-33"><a href="#cb37-33" aria-hidden="true" tabindex="-1"></a><span class="co">          multiplier (should be smaller than modulus)</span></span>
<span id="cb37-34"><a href="#cb37-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-35"><a href="#cb37-35" aria-hidden="true" tabindex="-1"></a><span class="co">        c : int &gt;= 0</span></span>
<span id="cb37-36"><a href="#cb37-36" aria-hidden="true" tabindex="-1"></a><span class="co">          increment (should be smaller than modulus)</span></span>
<span id="cb37-37"><a href="#cb37-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-38"><a href="#cb37-38" aria-hidden="true" tabindex="-1"></a><span class="co">        seed : int &gt;= 0</span></span>
<span id="cb37-39"><a href="#cb37-39" aria-hidden="true" tabindex="-1"></a><span class="co">          initial state (should be smaller than modulus)</span></span>
<span id="cb37-40"><a href="#cb37-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-41"><a href="#cb37-41" aria-hidden="true" tabindex="-1"></a><span class="co">        maximum : float or int</span></span>
<span id="cb37-42"><a href="#cb37-42" aria-hidden="true" tabindex="-1"></a><span class="co">          maximum number of random numbers to be generated by PRNG</span></span>
<span id="cb37-43"><a href="#cb37-43" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb37-44"><a href="#cb37-44" aria-hidden="true" tabindex="-1"></a>        <span class="kw">def</span> check_int(i, lower<span class="op">=</span><span class="dv">0</span>, upper<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb37-45"><a href="#cb37-45" aria-hidden="true" tabindex="-1"></a>            valid <span class="op">=</span> <span class="bu">type</span>(i) <span class="kw">is</span> <span class="bu">int</span> <span class="kw">and</span> i <span class="op">&gt;=</span> lower</span>
<span id="cb37-46"><a href="#cb37-46" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> upper <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb37-47"><a href="#cb37-47" aria-hidden="true" tabindex="-1"></a>                valid <span class="op">&amp;=</span> i <span class="op">&lt;</span> upper</span>
<span id="cb37-48"><a href="#cb37-48" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> valid</span>
<span id="cb37-49"><a href="#cb37-49" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb37-50"><a href="#cb37-50" aria-hidden="true" tabindex="-1"></a>        msg <span class="op">=</span> <span class="st">'"</span><span class="sc">{0}</span><span class="st">" must be int &gt;= </span><span class="sc">{1}</span><span class="st">'</span></span>
<span id="cb37-51"><a href="#cb37-51" aria-hidden="true" tabindex="-1"></a>        <span class="cf">assert</span> check_int(m, <span class="dv">1</span>), msg.<span class="bu">format</span>(<span class="st">'m'</span>, <span class="dv">1</span>)</span>
<span id="cb37-52"><a href="#cb37-52" aria-hidden="true" tabindex="-1"></a>        <span class="cf">assert</span> check_int(a, <span class="dv">1</span>, m), msg.<span class="bu">format</span>(<span class="st">'a'</span>, <span class="dv">1</span>)</span>
<span id="cb37-53"><a href="#cb37-53" aria-hidden="true" tabindex="-1"></a>        <span class="cf">assert</span> check_int(c, <span class="dv">0</span>, m), msg.<span class="bu">format</span>(<span class="st">'c'</span>, <span class="dv">0</span>)</span>
<span id="cb37-54"><a href="#cb37-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">assert</span> check_int(seed, <span class="dv">0</span>, m), msg.<span class="bu">format</span>(<span class="st">'seed'</span>, <span class="dv">0</span>)</span>
<span id="cb37-55"><a href="#cb37-55" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb37-56"><a href="#cb37-56" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.a, <span class="va">self</span>.c, <span class="va">self</span>.m, <span class="va">self</span>.seed <span class="op">=</span> a, c, m, seed</span>
<span id="cb37-57"><a href="#cb37-57" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._max <span class="op">=</span> <span class="bu">int</span>(maximum)</span>
<span id="cb37-58"><a href="#cb37-58" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb37-59"><a href="#cb37-59" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._reset()</span>
<span id="cb37-60"><a href="#cb37-60" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb37-61"><a href="#cb37-61" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _reset(<span class="va">self</span>):        </span>
<span id="cb37-62"><a href="#cb37-62" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.x <span class="op">=</span> <span class="va">self</span>.seed</span>
<span id="cb37-63"><a href="#cb37-63" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._counter <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb37-64"><a href="#cb37-64" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb37-65"><a href="#cb37-65" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__next__</span>(<span class="va">self</span>):</span>
<span id="cb37-66"><a href="#cb37-66" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb37-67"><a href="#cb37-67" aria-hidden="true" tabindex="-1"></a><span class="co">        Using recurrence relation </span></span>
<span id="cb37-68"><a href="#cb37-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-69"><a href="#cb37-69" aria-hidden="true" tabindex="-1"></a><span class="co">            X_{n+1} = (a X_n + c) mod m</span></span>
<span id="cb37-70"><a href="#cb37-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-71"><a href="#cb37-71" aria-hidden="true" tabindex="-1"></a><span class="co">        to generate new random number</span></span>
<span id="cb37-72"><a href="#cb37-72" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb37-73"><a href="#cb37-73" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>._counter <span class="op">&gt;=</span> <span class="va">self</span>._max:</span>
<span id="cb37-74"><a href="#cb37-74" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">StopIteration</span></span>
<span id="cb37-75"><a href="#cb37-75" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb37-76"><a href="#cb37-76" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.x <span class="op">=</span> (<span class="va">self</span>.a <span class="op">*</span> <span class="va">self</span>.x <span class="op">+</span> <span class="va">self</span>.c) <span class="op">%</span> <span class="va">self</span>.m</span>
<span id="cb37-77"><a href="#cb37-77" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._counter <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb37-78"><a href="#cb37-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-79"><a href="#cb37-79" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.x</span>
<span id="cb37-80"><a href="#cb37-80" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb37-81"><a href="#cb37-81" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__iter__</span>(<span class="va">self</span>):</span>
<span id="cb37-82"><a href="#cb37-82" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._reset()</span>
<span id="cb37-83"><a href="#cb37-83" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span></span>
<span id="cb37-84"><a href="#cb37-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-85"><a href="#cb37-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-86"><a href="#cb37-86" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Uniform(PRNG):</span>
<span id="cb37-87"><a href="#cb37-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-88"><a href="#cb37-88" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__next__</span>(<span class="va">self</span>):</span>
<span id="cb37-89"><a href="#cb37-89" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">super</span>().<span class="fu">__next__</span>() <span class="op">/</span> <span class="bu">float</span>(<span class="va">self</span>.m)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>For the choice <span class="math inline">\(a=40, c=0, m=181\)</span> (studied in lecture 2) we obtained a flawed LCG:</p>
<div class="cell" data-execution_count="33">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>prng <span class="op">=</span> PRNG(m<span class="op">=</span><span class="dv">181</span>, a<span class="op">=</span><span class="dv">40</span>, c<span class="op">=</span><span class="dv">0</span>, maximum<span class="op">=</span><span class="dv">1000</span>)</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.array(<span class="bu">list</span>(prng))</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> np.fft.fft(x)</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>kw <span class="op">=</span> <span class="bu">dict</span>(s<span class="op">=</span><span class="dv">40</span>, color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">4</span>))</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].scatter(np.arange(<span class="dv">100</span>), x[:<span class="dv">100</span>], <span class="op">**</span>kw)</span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].plot(x[:<span class="dv">100</span>], color<span class="op">=</span><span class="st">'k'</span>, lw<span class="op">=</span><span class="dv">2</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_xlabel(<span class="vs">r'iteration $s$'</span>)</span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_ylabel(<span class="vs">r'pseudo random number $x^{(s)}$'</span>)</span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].scatter(x[:<span class="dv">100</span>], x[<span class="dv">1</span>:<span class="dv">101</span>], <span class="op">**</span>kw)</span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlabel(<span class="vs">r'$x^{(s)}$'</span>)</span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_ylabel(<span class="vs">r'$x^{(s+1)}$'</span>)</span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].plot(np.<span class="bu">abs</span>(np.fft.fftshift(X))[<span class="dv">1</span>:<span class="bu">len</span>(x)<span class="op">//</span><span class="dv">2</span>], </span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a>                  lw<span class="op">=</span><span class="dv">3</span>, color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].set_xlabel(<span class="st">'spatial frequency'</span>)</span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].set_ylabel(<span class="vs">r'spectrum $|FT|$'</span>)</span>
<span id="cb38-18"><a href="#cb38-18" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-34-output-1.png" width="1125" height="342"></p>
</div>
</div>
<p>We can now analyze this LCG by using Markov chain methods. The recurrence relation (<a href="#eq-LCG">Equation&nbsp;44</a>) defines a Markov chain with deterministic transitions:</p>
<p><span class="math display">\[
P(x, y) = \left\{\begin{array}{c l}
1 \,\,;&amp;x = (a y + c) \, \text{mod}\, m\\
0 \,\,;&amp;\text{else}\\
\end{array}\right.
\]</span></p>
<p>By evaluation of this relation for all pairs of states <span class="math inline">\(x, y \in \{0, 1, \ldots, m-1\}\)</span> we obtain a permutation matrix as transition matrix. (Permutation matrices are special doubly stochastic matrices: they just shuffle states around in a deterministic fashion.)</p>
<div class="cell" data-execution_count="34">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>prng._reset()</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="co"># construct transition matrix</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>P <span class="op">=</span> np.zeros((prng.m, prng.m))</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(prng.m):</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>    prng.x <span class="op">=</span> j</span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>    P[<span class="bu">next</span>(prng), j] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a><span class="co"># P is a permutation matrix, therefore </span></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a><span class="co"># (see https://en.wikipedia.org/wiki/Permutation_matrix#Properties)</span></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a><span class="co"># 1. P has only entries in {0, 1}</span></span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> np.allclose(np.sort(np.unique(P)), [<span class="fl">0.</span>, <span class="fl">1.</span>])</span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a><span class="co"># 2. P is doubly stochastic</span></span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> np.allclose(P.<span class="bu">sum</span>(<span class="dv">0</span>), <span class="dv">1</span>)</span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> np.allclose(P.<span class="bu">sum</span>(<span class="dv">1</span>), <span class="dv">1</span>)</span>
<span id="cb39-18"><a href="#cb39-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-19"><a href="#cb39-19" aria-hidden="true" tabindex="-1"></a><span class="co"># 3. P is orthogonal</span></span>
<span id="cb39-20"><a href="#cb39-20" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> np.allclose(P.T <span class="op">@</span> P, np.eye(<span class="bu">len</span>(P)))</span>
<span id="cb39-21"><a href="#cb39-21" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> np.allclose(P <span class="op">@</span> P.T, np.eye(<span class="bu">len</span>(P)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="35">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Since P is a permutation matrix, all eigenvalues of P </span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="co"># are roots of one</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>v, U <span class="op">=</span> np.linalg.eig(P)</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> np.<span class="bu">all</span>(np.isclose(np.<span class="bu">abs</span>(v), <span class="dv">1</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="36">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="co"># There are four stationary distributions</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>indices <span class="op">=</span> np.where(np.isclose(v, <span class="fl">1.</span>))[<span class="dv">0</span>]</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'#eigenvalues close to one:'</span>, <span class="bu">len</span>(indices))</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>U <span class="op">=</span> U[:,indices].real</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>U <span class="op">/=</span> U.<span class="bu">sum</span>(<span class="dv">0</span>)</span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>U <span class="op">=</span> U.T</span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a><span class="co"># There is one trivially periodic state (x^{(0)}=0 with entropy 0)</span></span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a><span class="co"># and there are three equally large subspaces</span></span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'entropy of stationary distribution:'</span>, </span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a>      np.<span class="bu">round</span>([<span class="op">-</span> p <span class="op">@</span> np.log(p<span class="op">+</span><span class="fl">1e-100</span>) <span class="cf">for</span> p <span class="kw">in</span> U], <span class="dv">3</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>#eigenvalues close to one: 4
entropy of stationary distribution: [4.094 4.094 4.094 0.   ]</code></pre>
</div>
</div>
<div class="cell" data-execution_count="37">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>np.<span class="bu">sum</span>(U[<span class="dv">0</span>]<span class="op">&gt;</span><span class="dv">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="37">
<pre><code>60</code></pre>
</div>
</div>
<div class="cell" data-execution_count="38">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> [color[<span class="st">'color'</span>] <span class="cf">for</span> color <span class="kw">in</span> plt.rcParams[<span class="st">'axes.prop_cycle'</span>]]</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>orbits <span class="op">=</span> []</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>ticks <span class="op">=</span> (<span class="dv">0</span>, <span class="dv">50</span>, <span class="dv">100</span>, <span class="dv">150</span>)</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>limits <span class="op">=</span> (<span class="op">-</span><span class="dv">5</span>, prng.m<span class="op">+</span><span class="dv">4</span>)</span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">5</span>, figsize<span class="op">=</span>(<span class="dv">15</span>, <span class="fl">3.5</span>), sharex<span class="op">=</span><span class="va">True</span>, sharey<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, u <span class="kw">in</span> <span class="bu">enumerate</span>(U):</span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a>    prng.seed <span class="op">=</span> u.argmax()</span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> np.array(<span class="bu">list</span>(prng))</span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a>    orbits.append(<span class="bu">set</span>(x.tolist()))</span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">0</span>].scatter(x[:<span class="op">-</span><span class="dv">1</span>], x[<span class="dv">1</span>:], color<span class="op">=</span>colors[i])</span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true" tabindex="-1"></a>    ax[i<span class="op">+</span><span class="dv">1</span>].plot(x[:<span class="op">-</span><span class="dv">1</span>], x[<span class="dv">1</span>:], marker<span class="op">=</span><span class="st">'o'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>, lw<span class="op">=</span><span class="dv">2</span>, </span>
<span id="cb45-15"><a href="#cb45-15" aria-hidden="true" tabindex="-1"></a>                 color<span class="op">=</span>colors[i], ls<span class="op">=</span><span class="st">'--'</span>)</span>
<span id="cb45-16"><a href="#cb45-16" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_xticks(ticks)</span>
<span id="cb45-17"><a href="#cb45-17" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_yticks(ticks)</span>
<span id="cb45-18"><a href="#cb45-18" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_xlim(limits)</span>
<span id="cb45-19"><a href="#cb45-19" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_ylim(limits)</span>
<span id="cb45-20"><a href="#cb45-20" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-39-output-1.png" width="1402" height="298"></p>
</div>
</div>
</section>
</section>
<section id="aperiodic-markov-chains" class="level3">
<h3 class="anchored" data-anchor-id="aperiodic-markov-chains">Aperiodic Markov chains</h3>
<p>The period of a state <span class="math inline">\(x\in\mathcal X\)</span> is defined as</p>
<p><span id="eq-period"><span class="math display">\[
d(x) = \text{gcd}\left\{s \ge 1 : P^s(x, x) &gt; 0\right\}
\tag{45}\]</span></span></p>
<p>where <span class="math inline">\(\text{gcd}\{a_1, a_2, \ldots\}\)</span> is the <a href="https://en.wikipedia.org/wiki/Greatest_common_divisor">greatest common divisor</a> of the natural numbers <span class="math inline">\(a_1, a_2, \ldots \in \mathbb N\)</span>. The period of a state <span class="math inline">\(x\)</span> is the greatest common divisor of the times that the chain can return (i.e.&nbsp;has positive probability of returning) to <span class="math inline">\(x\)</span>, given that we start in <span class="math inline">\(x\)</span>.</p>
<p>A Markov chain is <em>aperiodic</em> if the periods of all states are one: <span class="math inline">\(d(x) = 1\)</span> for all <span class="math inline">\(x\in\mathcal X\)</span>.</p>
<p>So if a state is periodic, then the return times to <span class="math inline">\(x\)</span> are multiples of a factor greater than one, its period <span class="math inline">\(d(x)\)</span>.</p>
<p>Coming back to our two-state example, if we set <span class="math inline">\(\alpha=\beta=1\)</span> we have:</p>
<p><span class="math display">\[
P(x, y) = \begin{pmatrix}
0 &amp; 1 \\
1 &amp; 0\\
\end{pmatrix}
\]</span></p>
<p>For this Markov chain both states, <span class="math inline">\(x_1\)</span> and <span class="math inline">\(x_2\)</span>, have a period of two, since the state is visited again after an even number of steps.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<figure class="figure">
<img src="images/twostate_periodic.png" title="Periodic two-state Markov model" class="img-fluid figure-img">
</figure>
<p></p><figcaption class="figure-caption">Periodic two-state model</figcaption><p></p>
</figure>
</div>
<p><em>In summary:</em></p>
<ul>
<li><p>If a Markov chain is reducible, then it generates states only in a subspace of <span class="math inline">\(\mathcal X\)</span>; which subspace is selected depends on the initial state.</p></li>
<li><p>If a Markov chain is periodic, then it cycles between multiple stationary distributions.</p></li>
</ul>
<section id="illustration-using-the-two-state-system" class="level4">
<h4 class="anchored" data-anchor-id="illustration-using-the-two-state-system">Illustration using the two-state system</h4>
<p>We have</p>
<p><span id="eq-twostate2"><span class="math display">\[
P(x, y) = \begin{pmatrix}
1 - \alpha &amp; \beta \\
\alpha &amp; 1 - \beta \\
\end{pmatrix}
\tag{46}\]</span></span></p>
<p>with eigenvalues <span class="math inline">\(1\)</span> and <span class="math inline">\(1-\alpha-\beta\)</span> and corresponding (right) eigenvectors:</p>
<p><span id="eq-twostate-decomposition"><span class="math display">\[
\pi = \frac{1}{\alpha+\beta} \begin{pmatrix}
\beta \\ \alpha
\end{pmatrix}, \,\,\,
\text{and}\,\,\,  \begin{pmatrix}
1 \\ -1 \\
\end{pmatrix}
\tag{47}\]</span></span></p>
<p>assuming <span class="math inline">\(\alpha&gt;0\)</span> or <span class="math inline">\(\beta&gt;0\)</span>.</p>
<p>In case <span class="math inline">\(\alpha=\beta=0\)</span>:</p>
<p><span id="eq-twostate3"><span class="math display">\[
P(x, y) = \begin{pmatrix}
1  &amp; 0 \\
0 &amp; 1  \\
\end{pmatrix}
\tag{48}\]</span></span></p>
<p>all two state distributions are stationary with eigenvalue one. In particular, we have eigenvectors</p>
<p><span id="eq-decomposition2"><span class="math display">\[
\begin{pmatrix}
1 \\ 0
\end{pmatrix}, \,\,\,
\begin{pmatrix}
0 \\ 1 \\
\end{pmatrix}
\tag{49}\]</span></span></p>
<p>corresponding to two recurrent classes, and <span class="math inline">\(P\)</span> is reducible.</p>
<p>In case <span class="math inline">\(\alpha=\beta=1\)</span>:</p>
<p><span id="eq-twostate4"><span class="math display">\[
P(x, y) = \begin{pmatrix}
0  &amp; 1 \\
1 &amp; 0  \\
\end{pmatrix}
\tag{50}\]</span></span></p>
<p>the eigenvalues are <span class="math inline">\(1\)</span> and <span class="math inline">\(-1\)</span> with eigenvectors</p>
<p><span class="math display">\[
\begin{pmatrix}
1 \\ 1
\end{pmatrix}, \,\,\,
\begin{pmatrix}
1 \\ -1 \\
\end{pmatrix}
\]</span></p>
<p>and the chain is periodic: <span class="math inline">\(P^{2s} = I\)</span>, <span class="math inline">\(P^{2s+1} = P\)</span>.</p>
</section>
</section>
</section>
</section>
<section id="lecture-5-the-metropolis-hastings-algorithm-1" class="level1">
<h1>Lecture 5: The Metropolis-Hastings algorithm</h1>
<section id="outline-4" class="level2">
<h2 class="anchored" data-anchor-id="outline-4">Outline</h2>
<ul>
<li>Fundamental theorem of Markov chains</li>
<li>Metropolis-Hastings algorithm</li>
</ul>
</section>
<section id="recap-1" class="level2">
<h2 class="anchored" data-anchor-id="recap-1">Recap</h2>
<ul>
<li><p>Idea: improve on direct sampling by allowing for dependence of successive samples (Markov property)</p></li>
<li><p>Markov chains are defined by stochastic matrices; they have at least one stationary distribution</p></li>
</ul>
<div class="cell" data-execution_count="39">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pylab <span class="im">as</span> plt</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>plt.rc(<span class="st">'font'</span>, size<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a><span class="co"># transition matrix as defined in last lecture</span></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> transition_matrix(alpha, beta):</span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array([[<span class="dv">1</span><span class="op">-</span>alpha, beta], </span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>                     [alpha, <span class="dv">1</span><span class="op">-</span>beta]])</span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a><span class="co"># sampling method as defined in last lecture</span></span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sample_chain(S, alpha<span class="op">=</span><span class="fl">0.5</span>, beta<span class="op">=</span><span class="fl">0.5</span>, x0<span class="op">=</span><span class="dv">0</span>):</span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> [x0]</span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a>    P <span class="op">=</span> transition_matrix(alpha, beta)</span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="bu">len</span>(X) <span class="op">&lt;</span> S:</span>
<span id="cb46-16"><a href="#cb46-16" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> P[:,X[<span class="op">-</span><span class="dv">1</span>]]</span>
<span id="cb46-17"><a href="#cb46-17" aria-hidden="true" tabindex="-1"></a>        X.append(np.random.multinomial(<span class="dv">1</span>, p).argmax())</span>
<span id="cb46-18"><a href="#cb46-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array(X)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<ul>
<li>Reducible and periodic chains will not converge to a unique stationary distribution</li>
</ul>
<p>So only if the Markov is both <em>irreducible</em> and <em>aperiodic</em>, then we have a unique stationary distribution. This is detailed in the following theorems.</p>
</section>
<section id="fundamental-theorem-of-markov-chains" class="level2">
<h2 class="anchored" data-anchor-id="fundamental-theorem-of-markov-chains">Fundamental Theorem of Markov Chains</h2>
<p>Irreducibility and aperiodicity implies that <span class="math inline">\(\pi\)</span> is unique (see, for example, <a href="https://www.ams.org/journals/bull/2009-46-02/S0273-0979-08-01238-X/">Diaconis: The Markov Chain Monte Carlo Revolution</a>) and powers of <span class="math inline">\(P\)</span> converge to a rank one matrix</p>
<p><span id="eq-fundamental"><span class="math display">\[
P^S(x, y) \to \pi(x)
\tag{51}\]</span></span></p>
<p>for <span class="math inline">\(S\to\infty\)</span> and all <span class="math inline">\(x, y \in\mathcal X\)</span>. Equation (<a href="#eq-fundamental">Equation&nbsp;51</a>) means that we can start from any initial state <span class="math inline">\(y\in\mathcal X\)</span> with <span class="math inline">\(\pi(y) &gt; 0\)</span> and will eventually produce samples from the stationary distribution <span class="math inline">\(\pi\)</span>. Another way to express this <em>convergence in distribution</em> is:</p>
<p><span class="math display">\[
|P^S p - \pi| \to 0
\]</span></p>
<p>for <span class="math inline">\(S\to\infty\)</span> for any <span class="math inline">\(p\)</span>. That is, we can start from an arbitrary initial distribution and converge to the stationary distribution. In matrix-vector notation</p>
<p><span class="math display">\[
P^S \to \pi\mathbb 1^T\, .
\]</span></p>
<p>That is, if <span class="math inline">\(P\)</span> is irreducible and aperiodic, then matrix powers of <span class="math inline">\(P\)</span> converge to a rank-1 matrix.</p>
<p>The fundamental theorem for Markov chains follows from the <a href="https://en.wikipedia.org/wiki/Perron%E2%80%93Frobenius_theorem">Perron-Frobenius theorem</a> for non-negative matrices and the irreducibility of <span class="math inline">\(P\)</span>.</p>
<p>Why does theorem (<a href="#eq-fundamental">Equation&nbsp;51</a>) have implications for sampling? As we saw in the previous lectures, it might be difficult to sample a probabilistic model directly. Sometimes variable transformations allow us to sample a model directly, but this is only rarely the case for complex models. When resorting to rejection or importance sampling, it is generally difficult to find a good proposal distribution. On the other hand, simulation of a Markov chain is simple to implement (see algorithm above): we just have to move from <span class="math inline">\(x\)</span> to <span class="math inline">\(y\)</span> according to <span class="math inline">\(P(y, x)\)</span>. No matter where we start in sample space, the states that we produce by simulating a Markov chain will eventually follow the stationary distribution.</p>
<p>But there is still something missing in order to use the simulation of a Markov chain for probabilistic inference. In our setting, we are given a probabilistic model <span class="math inline">\(p\)</span> (our target distribution) rather than a transition matrix <span class="math inline">\(P\)</span>. So we are still facing the challenge of designing a suitable Markov chain that has the desired target as its stationary distribution. This problem has been solved in a very ingenious fashion by Metropolis et al., as we will see soon.</p>
<div class="cell" data-execution_count="40">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="co"># matrix power converges to rank-1 matrix</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_pi(alpha, beta):</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array([beta, alpha]) <span class="op">/</span> (alpha <span class="op">+</span> beta)</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> <span class="dv">50</span></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>chains <span class="op">=</span> [(<span class="fl">0.1</span>, <span class="fl">0.1</span>), (<span class="fl">0.1</span>, <span class="fl">0.</span>), (<span class="fl">1e-2</span>, <span class="fl">0.</span>), (<span class="fl">0.9</span>, <span class="fl">0.9</span>), (<span class="fl">0.99</span>, <span class="fl">0.99</span>), (<span class="fl">0.1</span>, <span class="fl">0.7</span>)]</span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>kw <span class="op">=</span> <span class="bu">dict</span>(ylim<span class="op">=</span>[<span class="op">-</span><span class="fl">0.1</span>, <span class="fl">2.1</span>], ylabel<span class="op">=</span><span class="vs">r'$|P^s-\pi\mathbb</span><span class="sc">{1}</span><span class="vs">^T|$'</span>, xlabel<span class="op">=</span><span class="st">'$s$'</span>)</span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">6</span>), sharex<span class="op">=</span><span class="st">'all'</span>, sharey<span class="op">=</span><span class="st">'all'</span>, subplot_kw<span class="op">=</span>kw)</span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> <span class="bu">list</span>(ax.flat)</span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, (alpha, beta) <span class="kw">in</span> <span class="bu">enumerate</span>(chains):</span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a>    P <span class="op">=</span> transition_matrix(alpha, beta)</span>
<span id="cb47-15"><a href="#cb47-15" aria-hidden="true" tabindex="-1"></a>    pi <span class="op">=</span> np.array([beta, alpha]) <span class="op">/</span> (alpha <span class="op">+</span> beta)</span>
<span id="cb47-16"><a href="#cb47-16" aria-hidden="true" tabindex="-1"></a>    P_inf <span class="op">=</span> np.multiply.outer(pi, np.ones(<span class="dv">2</span>))</span>
<span id="cb47-17"><a href="#cb47-17" aria-hidden="true" tabindex="-1"></a>    P_s <span class="op">=</span> P.copy()</span>
<span id="cb47-18"><a href="#cb47-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-19"><a href="#cb47-19" aria-hidden="true" tabindex="-1"></a>    d <span class="op">=</span> []</span>
<span id="cb47-20"><a href="#cb47-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="bu">len</span>(d)  <span class="op">&lt;</span> S:</span>
<span id="cb47-21"><a href="#cb47-21" aria-hidden="true" tabindex="-1"></a>        d.append(np.fabs(P_s <span class="op">-</span> P_inf).<span class="bu">sum</span>())</span>
<span id="cb47-22"><a href="#cb47-22" aria-hidden="true" tabindex="-1"></a>        P_s <span class="op">=</span> P_s.dot(P)</span>
<span id="cb47-23"><a href="#cb47-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-24"><a href="#cb47-24" aria-hidden="true" tabindex="-1"></a>    ax[i].set_title(<span class="vs">r'$\alpha=</span><span class="sc">{0:.3f}</span><span class="vs">$, $\beta=</span><span class="sc">{1:.3f}</span><span class="vs">$'</span>.<span class="bu">format</span>(alpha, beta),</span>
<span id="cb47-25"><a href="#cb47-25" aria-hidden="true" tabindex="-1"></a>                   fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb47-26"><a href="#cb47-26" aria-hidden="true" tabindex="-1"></a>    ax[i].plot(d, lw<span class="op">=</span><span class="dv">4</span>, alpha<span class="op">=</span><span class="fl">0.6</span>, color<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb47-27"><a href="#cb47-27" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-41-output-1.png" width="1110" height="537"></p>
</div>
</div>
<div class="cell" data-execution_count="41">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="co"># convergence in distribution</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> estimate_pi0(X):</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span><span class="op">-</span>np.add.accumulate(X) <span class="op">/</span> np.add.accumulate(np.ones(<span class="bu">len</span>(X)))</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>kw <span class="op">=</span> <span class="bu">dict</span>(ylim<span class="op">=</span>[<span class="op">-</span><span class="fl">0.1</span>, <span class="fl">1.1</span>], ylabel<span class="op">=</span><span class="vs">r'$p^{(s)}(x=x_1)$'</span>, xlabel<span class="op">=</span><span class="st">'$s$'</span>)</span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">6</span>), sharex<span class="op">=</span><span class="st">'all'</span>, sharey<span class="op">=</span><span class="st">'all'</span>, subplot_kw<span class="op">=</span>kw)</span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> <span class="bu">list</span>(ax.flat)</span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, (alpha, beta) <span class="kw">in</span> <span class="bu">enumerate</span>(chains):</span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> sample_chain(S, alpha, beta, x0<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb48-13"><a href="#cb48-13" aria-hidden="true" tabindex="-1"></a>    pi <span class="op">=</span> compute_pi(alpha, beta)</span>
<span id="cb48-14"><a href="#cb48-14" aria-hidden="true" tabindex="-1"></a>    pi_est <span class="op">=</span> estimate_pi0(X)</span>
<span id="cb48-15"><a href="#cb48-15" aria-hidden="true" tabindex="-1"></a>    ax[i].set_title(<span class="vs">r'$\alpha=</span><span class="sc">{0:.3f}</span><span class="vs">$, $\beta=</span><span class="sc">{1:.3f}</span><span class="vs">$'</span>.<span class="bu">format</span>(alpha, beta),</span>
<span id="cb48-16"><a href="#cb48-16" aria-hidden="true" tabindex="-1"></a>                   fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb48-17"><a href="#cb48-17" aria-hidden="true" tabindex="-1"></a>    ax[i].plot(pi_est, lw<span class="op">=</span><span class="dv">3</span>, color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.6</span>)</span>
<span id="cb48-18"><a href="#cb48-18" aria-hidden="true" tabindex="-1"></a>    ax[i].axhline(pi[<span class="dv">0</span>], ls<span class="op">=</span><span class="st">'--'</span>, color<span class="op">=</span><span class="st">'r'</span>, alpha<span class="op">=</span><span class="fl">0.8</span>)</span>
<span id="cb48-19"><a href="#cb48-19" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-42-output-1.png" width="1108" height="537"></p>
</div>
</div>
<section id="strong-law-of-large-numbers-lln-for-markov-chains" class="level3">
<h3 class="anchored" data-anchor-id="strong-law-of-large-numbers-lln-for-markov-chains">Strong law of large numbers (LLN) for Markov chains</h3>
<p>Before we explain the Metropolis algorithm, let us briefly state the convergence result for irreducible and aperiodic Markov chains in a fashion that is closer to the <em>Monte Carlo approximation</em> introduced in the first lecture.</p>
<p>Irreducibility and aperiodicity of a stochastic transition matrix implies a strong law of large numbers for Markov chains:</p>
<p><span id="eq-lln_markov"><span class="math display">\[
\frac{1}{S} \sum_{s=1}^S f\bigl(x^{(s)}\bigr) \to \mathbb E_{\pi}[f]
\tag{52}\]</span></span></p>
<p>where <span class="math inline">\(x^{(s)} \sim \Pr\bigl(x\mid x^{(s-1)}\bigr) = P\bigl(x, x^{(s-1)}\bigr)\)</span> is an irreducible, aperiodic Markov chain with stationary distribution <span class="math inline">\(\pi\)</span>. Therefore, simulating a Markov chain produces samples that can be used to approximate an expectation similar to the approximation in standard Monte Carlo or importance sampling.</p>
<p>Analogous to the standard Monte Carlo approximation, Markov chain Monte Carlo (MCMC) sampling produces estimates of expectations that coincide with the true expectation in the long run. Again, this is only a stochastic guarantee, and it will be generally difficult to know how close we are to the correct value. But nevertheless we have a guarantee that running a Markov chain longer should help.</p>
</section>
<section id="reversible-markov-chains" class="level3">
<h3 class="anchored" data-anchor-id="reversible-markov-chains">Reversible Markov chains</h3>
<p>A very important concept to verify stationarity of a Markov chain <span class="math inline">\(P\)</span> is <em>reversibility</em>. A Markov chain is <em><span class="math inline">\(\pi\)</span>-reversible</em> if the transition matrix satisfies the <em>detailed balance</em> equations</p>
<p><span id="eq-reversible"><span class="math display">\[
P(x, y)\, \pi(y) = P(y, x)\, \pi(x)
\tag{53}\]</span></span></p>
<p>for all <span class="math inline">\(x, y \in \mathcal X\)</span> for some distribution <span class="math inline">\(\pi\)</span>. From the point of view of probability flow across the transition graph, the detailed balance equations (<a href="#eq-reversible">Equation&nbsp;53</a>) state that “the amount of probability mass flowing from a source state <span class="math inline">\(x\)</span> to a sink <span class="math inline">\(y\)</span> via the directed edge with capacity <span class="math inline">\(P(y, x)\)</span> equals the probability mass flowing backwards.” So the dynamics across the transition graph is in a steady state. As a consequence, reversibility implies that <span class="math inline">\(\pi\)</span> is an invariant distribution:</p>
<p><span id="eq-reversible_invariance"><span class="math display">\[
\sum_{y\in\mathcal X} P(x, y)\pi(y) = \sum_{y\in\mathcal X} P(y, x) \pi(x) = \pi(x)\, .
\tag{54}\]</span></span></p>
<p>Therefore, to verify that a distribution of interest (our target distribution) is the invariant distribution of a Markov chain, we can simply check if the transition matrix satisfies detailed balance with respect to the target distribution.</p>
<p>The contrary to (<a href="#eq-reversible_invariance">Equation&nbsp;54</a>) is <strong>not</strong> true: The fact that <span class="math inline">\(\pi\)</span> is a stationary distribution of the transition matrix <span class="math inline">\(P\)</span> does not imply, that <span class="math inline">\(P\)</span> is <span class="math inline">\(\pi\)</span>-reversible.</p>
<p>If we start a Markov chain in the stationary distribution, <span class="math inline">\(p^{(0)} = \pi\)</span>, then <span id="eq-forward-backward"><span class="math display">\[
\begin{aligned}
    \Pr\bigl(x_S = x^{(S)}, \ldots x_0=x^{(0)}\bigr) &amp;=
    \prod_{s=1}^S P\bigl(x^{(s)}, x^{(s-1)}\bigr)\,  \pi\bigl(x^{(0)}\bigr)\\
    &amp;=
    \prod_{s=1}^S P\bigl(x^{(s-1)}, x^{(s)}\bigr)\, \pi\bigl(x^{(S)}\bigr) \\
    &amp;= \Pr\bigl(x_S = x^{(0)}, \ldots x_0=x^{(S)}\bigr)
\end{aligned}
\tag{55}\]</span></span></p>
<p>The probability of generating a Markov chain when starting in the stationary distribution is the same in forward and backward direction. This is why the Markov chain is called <em>reversible</em>.</p>
<p>If the transition matrix <span class="math inline">\(P\)</span> is symmetric, <span class="math inline">\(P^T=P\)</span>, then the uniform distribution is the stationary distribution because the detailed balance equations are satisfied for <span class="math inline">\(\pi(x) = 1/|\mathcal X|\)</span>.</p>
</section>
</section>
<section id="the-metropolis-hastings-algorithm" class="level2">
<h2 class="anchored" data-anchor-id="the-metropolis-hastings-algorithm">The Metropolis-Hastings Algorithm</h2>
<p>We are now ready to discuss the <a href="https://en.wikipedia.org/wiki/Metropolis%E2%80%93Hastings_algorithm"><strong>Metropolis-Hastings algorithm</strong></a> which solves the following fundamental problem:</p>
<section id="for-a-given-target-distribution-px-how-can-we-construct-an-irreducible-and-aperiodic-markov-chain-such-that-px-is-its-stationary-distribution" class="level3">
<h3 class="anchored" data-anchor-id="for-a-given-target-distribution-px-how-can-we-construct-an-irreducible-and-aperiodic-markov-chain-such-that-px-is-its-stationary-distribution">For a given target distribution <span class="math inline">\(p(x)\)</span>, how can we construct an irreducible and aperiodic Markov chain such that <span class="math inline">\(p(x)\)</span> is its stationary distribution?</h3>
<p>The Metropolis-Hastings algorithm solves this problem in a very elegant and simple fashion. Due to its simplicity, it is very widely applicable and ranks among the <a href="https://www.andrew.cmu.edu/course/15-355/misc/Top%20Ten%20Algorithms.html">top 10 algorithm of the 20th century</a>.</p>
</section>
<section id="algorithm-metropolis-hastings" class="level3">
<h3 class="anchored" data-anchor-id="algorithm-metropolis-hastings">Algorithm: Metropolis-Hastings</h3>
<p>Assume <span class="math inline">\(\mathcal X\)</span> is discrete and <span class="math inline">\(p\)</span> a pmf on <span class="math inline">\(\mathcal X\)</span>. Moreover, <span class="math inline">\(Q(y, x)\)</span> is a proposal Markov chain on <span class="math inline">\(\mathcal X\)</span>, that is <span class="math inline">\(Q(\cdot, x)\)</span> is a pmf on <span class="math inline">\(\mathcal X\)</span> that allows us to generate samples from a given state <span class="math inline">\(x\)</span>. The trick of the Metropolis-Hastings algorithm is to modify the Markov chain <span class="math inline">\(Q\)</span>, by auxiliary coin tossing, to a new transition kernel with stationary distribution <span class="math inline">\(p\)</span>.</p>
<p>The Metropolis-Hastings (MH) algorithm proceeds as follows:</p>
<p>Generate some initial <span class="math inline">\(x^{(0)} \sim p^{(0)}\)</span> and iterate for <span class="math inline">\(s=1, 2, \ldots\)</span>:</p>
<ol type="1">
<li><p>propose a new state by generating <span class="math inline">\(y \sim Q\bigl(\,\cdot\,, x^{(s-1)}\bigr)\)</span></p></li>
<li><p>generate a uniform random number <span class="math inline">\(u \sim \mathcal U(0, 1)\)</span>; if <span class="math inline">\(u \le A\bigl(y, x^{(s-1)}\bigr)\)</span> then <em>accept</em> and set <span class="math inline">\(x^{(s)} = y\)</span>, else <em>reject</em> and set <span class="math inline">\(x^{(s)} = x^{(s-1)}\)</span>. The acceptance probability is given by</p></li>
</ol>
<p><span id="eq-MHaccept"><span class="math display">\[
    A(y, x) = \min\left\{1, \frac{Q(x, y)}{Q(y, x)}\frac{p(y)}{p(x)} \right\}
\tag{56}\]</span></span></p>
<p>The MH algorithm is the first and most important Markov chain Monte Carlo (MCMC) algorithm. Most other MCMC algorithms are specialized versions of MH sampling.</p>
<p><em>Remarks</em></p>
<ol type="1">
<li><p>The distribution <span class="math inline">\(p\)</span> will turn out to be a stationary distribution of the Markov chain that is simulated with the MH algorithm; <span class="math inline">\(p\)</span> is called the <strong>target distribution</strong> or simply the <strong>target</strong></p></li>
<li><p>The Metropolis-Hastings algorithm is also valid in continuous sample spaces <span class="math inline">\(\mathcal X\)</span></p></li>
<li><p>It is crucial to reject, i.e.&nbsp;to really duplicate the current state and store it as a sample in case of a rejected proposal. Otherwise the statistics will be wrong!</p></li>
<li><p>We don’t need to build up and store the full transition matrix <span class="math inline">\(Q\)</span> of the proposal chain in memory. If <span class="math inline">\(Q\)</span> is symmetric, it suffices to be able to <em>simulate</em> <span class="math inline">\(Q\)</span> (this fact is used, for example, in Hamiltonian Monte Carlo where the proposal state is generated by solving a system of differential equations)</p></li>
<li><p>We don’t need to know the normalizing constants of the target distribution and the proposal chain, since the MH algorithm only involves <em>ratios</em> of the target distribution and the transition rates of the proposal chain. If the unnormalized target and proposal chain are denoted</p></li>
</ol>
<p><span id="eq-unnormalized"><span class="math display">\[
    p(x) = \frac{1}{Z_p} p^*(x), \,\,\, Q(x, y) = \frac{1}{Z_Q} Q^*(x, y)
\tag{57}\]</span></span></p>
<p>where <span class="math inline">\(p^*(x) \ge 0\)</span> and <span class="math inline">\(Z_p = \sum_x p^*(x)\)</span> etc., then the <em>acceptance ratio</em> is</p>
<p><span class="math display">\[
\frac{Q(x, y)}{Q(y, x)}\frac{p(y)}{p(x)} =
\frac{Q^*(x, y)}{Q^*(y, x)}\frac{Z_Q}{Z_Q}\, \frac{p^*(y)}{p^*(x)}\frac{Z_p}{Z_p}\, .
\]</span></p>
<p>This is <strong>very</strong> convenient!</p>
</section>
<section id="special-cases" class="level3">
<h3 class="anchored" data-anchor-id="special-cases">Special cases</h3>
<ul>
<li>Symmetric proposal distribution <span class="math inline">\(Q^T=Q\)</span> (i.e.&nbsp;the stationary distribution of <span class="math inline">\(Q\)</span> is uniform). This was assumed in the original publication by <a href="https://aip.scitation.org/doi/abs/10.1063/1.1699114">Metropolis <em>et al.</em></a>. The acceptance ratio simplifies to</li>
</ul>
<p><span class="math display">\[
\frac{Q(x,y)\, p(y)}{Q(y, x)\, p(x)} = \frac{p(y)}{p(x)}
\]</span></p>
<p>Physicists tend to work with energies, i.e.&nbsp;negative log probabilities, rather than probabilities. So the logarithm</p>
<p><span class="math display">\[
\Delta E = \log\{ p(x) / p(y) \}
\]</span></p>
<p>is the <em>energy difference</em> when jumping from state <span class="math inline">\(x\)</span> to the proposed state <span class="math inline">\(y\)</span>. The acceptance probability is then</p>
<p><span class="math display">\[
\min\left\{1, e^{-\Delta E} \right\}
\]</span></p>
<p>If the energy of the new state is lower than the energy of the current state, the proposal is always accepted. Otherwise the acceptance probability depends on the <a href="https://en.wikipedia.org/wiki/Boltzmann_distribution"><em>Boltzmann factor</em></a> <span class="math inline">\(\exp(-\Delta E)\)</span>.</p>
<ul>
<li>Independence sampler <span class="math inline">\(Q(y, x) = q(y)\)</span>. The acceptance ratio simplifies to</li>
</ul>
<p><span class="math display">\[
\frac{Q(x,y)\, p(y)}{Q(y, x)\, p(x)} = \frac{q(x)\, p(y)}{q(y)\, p(x)}
\]</span></p>
<p>If <span class="math inline">\(q(x)\)</span> is the target <span class="math inline">\(q=p\)</span>, then we always accept and we are back to direct sampling <span class="math inline">\(x\sim p\)</span>.</p>
<p>There is also a connection to importance and rejection sampling. The importance weight of some state <span class="math inline">\(x\)</span> is</p>
<p><span class="math display">\[
w(x) = \frac{p(x)}{q(x)}\, ,
\]</span></p>
<p>and the acceptance ratio of the independence sampler involves ratios of importance weights</p>
<p><span class="math display">\[
\frac{w(y)}{w(x)}
\]</span></p>
<p>If the proposal state <span class="math inline">\(y\)</span> has a higher importance weight than the current state <span class="math inline">\(x\)</span>, then we always accept. Otherwise the acceptance probability is <span class="math inline">\(\min\{1, w(y)/w(x)\}\)</span>. So Metropolis sampling with an independent proposal is a kind of hybrid of rejection and importance sampling. Still it has some advantages over rejection sampling, since we do not need to establish an upper bound <span class="math inline">\(M\)</span> such that <span class="math inline">\(p(x) \le Mq(x)\)</span>. In contrast to importance sampling, it has some built-in pruning because states that have a very small importance weight (relative to the current state) have only a small chance of being accepted.</p>
</section>
<section id="why-does-the-mh-algorithm-work" class="level3">
<h3 class="anchored" data-anchor-id="why-does-the-mh-algorithm-work">Why does the MH algorithm work?</h3>
<p>The MH algorithm works because of the validity of the following statements:</p>
<section id="transition-probabilities-of-the-mh-algorithm" class="level4">
<h4 class="anchored" data-anchor-id="transition-probabilities-of-the-mh-algorithm">Transition probabilities of the MH algorithm</h4>
<p>The MH algorithm generates a Markov chain on <span class="math inline">\(\mathcal X\)</span>. The transition probabilities of the Markov chain are given by</p>
<p><span id="eq-MHtransitions"><span class="math display">\[
P(y, x) = Q(y, x)\, A(y, x) + \delta(y,x)\, r(x)
\tag{58}\]</span></span></p>
<p>where the acceptance probability <span class="math inline">\(A(y, x)\)</span> is defined above, and the rejection probability is</p>
<p><span id="eq-MHrejection"><span class="math display">\[
r(x) = 1 - \sum_{y\in \mathcal X} Q(y, x)\, A(y, x)
\tag{59}\]</span></span></p>
<p>The transition probability of <span class="math inline">\(y\not= x\)</span> is <span class="math inline">\(A(y, x)\, Q(y, x)\)</span> by construction of the algorithm. The term for <span class="math inline">\(y=x\)</span> is obtained by subtracting the sum <span class="math inline">\(\sum_y A(y, x)\, Q(y, x)\)</span> from one, which is just <span class="math inline">\(r(x)\)</span>. In general, it holds that the diagonal entries of the transition matrix are fixed by column stochasticity:</p>
<p><span class="math display">\[
1 = \sum_y P(y, x) \,\,\,\Rightarrow\,\,\, P(x, x) = 1 - \sum_{y\not= x} P(y, x)\, .
\]</span></p>
<p>So it is sufficient to know the off-diagonal elements.</p>
</section>
<section id="stationarity-of-the-target-distribution" class="level4">
<h4 class="anchored" data-anchor-id="stationarity-of-the-target-distribution">Stationarity of the target distribution</h4>
<p>To show that the target distribution <span class="math inline">\(p(x)\)</span> is indeed the stationary distribution of the Markov chain generated by the MH algorithm, we check if the transition matrix (<a href="#eq-MHtransitions">Equation&nbsp;58</a>) is <span class="math inline">\(p\)</span>-reversible. For <span class="math inline">\(y\not= x\)</span> we have:</p>
<p><span id="eq-MHreversible"><span class="math display">\[
\begin{aligned}
    P(y, x)\, p(x)
    &amp;= Q(y, x)\, A(y, x)\, p(x) \\
    &amp;= Q(y, x)\, \min\left\{1, \frac{Q(x, y)}{Q(y, x)}\frac{p(y)}{p(x)} \right\}\, p(x) \\
    &amp;=\min\left\{ Q(y, x)\, p(x), Q(x, y)\, p(y) \right\}\\
    &amp;= Q(x, y)\, \min\left\{1, \frac{Q(y, x)}{Q(x, y)}\frac{p(x)}{p(y)} \right\}\, p(y) \\
    &amp;= Q(x, y)\, A(x, y)\, p(y) \\
    &amp;= P(x, y)\, p(y)
\end{aligned}
\tag{60}\]</span></span></p>
<p>The MH chain satisfies the detailed balance equations with regard to our target distribution. Therefore, <span class="math inline">\(p\)</span> is a stationary distribution and will be sampled in the long run.</p>
<p>To ensure that the simulation converges to <span class="math inline">\(p\)</span>, we have to ensure irreducibility by proper choice of the proposal chain <span class="math inline">\(Q(y, x)\)</span>. The proposal chain needs to be irreducible: every point <span class="math inline">\(y \in \mathcal X\)</span> is reachable from any <span class="math inline">\(x \in\mathcal X\)</span> in a finite number of steps.</p>
</section>
</section>
<section id="example-vihola-example-6.19" class="level3">
<h3 class="anchored" data-anchor-id="example-vihola-example-6.19">Example (Vihola, Example 6.19)</h3>
<p>Let’s run the MH algorithm on a simple staircase distribution with uniform proposals. The target distribution is</p>
<p><span class="math display">\[
p(x) = \frac{x}{Z}, \,\,\, x\in\{1, \ldots, m\}=:\mathcal X, \,\,\, Z=\sum_{x=1}^m x = m(m+1)/2
\]</span></p>
<p>To design an MH algorithm for simulating <span class="math inline">\(p\)</span>, we have to choose a suitable proposal distribution. A simple choice is to use a uniform distribution over <span class="math inline">\(\mathcal X\)</span>. That is, <span class="math inline">\(Q(y, x)\)</span> is independent of <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>: <span class="math inline">\(Q(y, x) = 1/m\)</span> for all <span class="math inline">\(x, y \in\mathcal X\)</span>.</p>
<p>The resulting MH chain is irreducible:</p>
<p><span class="math display">\[
\Pr(x_1=y| x_0=x) = Q(y, x) \min\left\{1, \frac{Q(x, y)}{Q(y, x)}\frac{p(y)}{p(x)} \right\} = \frac{1}{m} \min\left\{1, \frac{y}{x}\right\} &gt; 0
\]</span></p>
<p>for all <span class="math inline">\(x, y\in\mathcal X\)</span>. We can get from from any <span class="math inline">\(x\in \mathcal X\)</span> to any <span class="math inline">\(y\)</span> within one step (<span class="math inline">\(P(y,x) &gt; 0\)</span> for all <span class="math inline">\(x, y\)</span>).</p>
<p>The MH algorithm for this special case is very simple:</p>
<ol type="1">
<li><p>Pick <span class="math inline">\(x^{(0)}\)</span> uniformly in <span class="math inline">\(\{1, \ldots, m\}\)</span>, e.g.&nbsp;<span class="math inline">\(x^{(0)}=1\)</span></p></li>
<li><p>Generate proposal <span class="math inline">\(y \sim \mathcal U(\{1, \ldots, m\})\)</span></p></li>
<li><p>Generate <span class="math inline">\(u \sim \mathcal U(0, 1)\)</span> and if <span class="math inline">\(u \le \frac{y}{x^{(s-1)}}\)</span>, set <span class="math inline">\(x^{(s)} = y\)</span>, otherwise <span class="math inline">\(x^{(s)} = x^{(s-1)}\)</span></p></li>
</ol>
<div class="cell" data-execution_count="42">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Example 6.19 from Vihola's lecture notes</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a><span class="co"># size of sample space</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> <span class="dv">30</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a><span class="co"># sample space</span></span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> np.arange(m)</span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a><span class="co"># target distribution</span></span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> X <span class="op">+</span> <span class="fl">1.</span></span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a>p <span class="op">*=</span> <span class="dv">2</span> <span class="op">/</span> m <span class="op">/</span> (m<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true" tabindex="-1"></a><span class="co"># uniform proposal</span></span>
<span id="cb49-14"><a href="#cb49-14" aria-hidden="true" tabindex="-1"></a>Q <span class="op">=</span> <span class="kw">lambda</span> x<span class="op">=</span><span class="va">None</span>: np.random.choice(X)</span>
<span id="cb49-15"><a href="#cb49-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-16"><a href="#cb49-16" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> Q()</span>
<span id="cb49-17"><a href="#cb49-17" aria-hidden="true" tabindex="-1"></a>samples <span class="op">=</span> [x]</span>
<span id="cb49-18"><a href="#cb49-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-19"><a href="#cb49-19" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="bu">len</span>(samples) <span class="op">&lt;</span> <span class="fl">1e5</span>:</span>
<span id="cb49-20"><a href="#cb49-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-21"><a href="#cb49-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># proposal step</span></span>
<span id="cb49-22"><a href="#cb49-22" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> Q(x)</span>
<span id="cb49-23"><a href="#cb49-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb49-24"><a href="#cb49-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># acceptance probability</span></span>
<span id="cb49-25"><a href="#cb49-25" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> p[y] <span class="op">/</span> p[x]</span>
<span id="cb49-26"><a href="#cb49-26" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb49-27"><a href="#cb49-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># accept / reject?</span></span>
<span id="cb49-28"><a href="#cb49-28" aria-hidden="true" tabindex="-1"></a>    u <span class="op">=</span> np.random.uniform()</span>
<span id="cb49-29"><a href="#cb49-29" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> y <span class="cf">if</span> (u <span class="op">&lt;=</span> A) <span class="cf">else</span> x</span>
<span id="cb49-30"><a href="#cb49-30" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb49-31"><a href="#cb49-31" aria-hidden="true" tabindex="-1"></a>    samples.append(x)</span>
<span id="cb49-32"><a href="#cb49-32" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb49-33"><a href="#cb49-33" aria-hidden="true" tabindex="-1"></a>bins, counts <span class="op">=</span> np.unique(samples, return_counts<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb49-34"><a href="#cb49-34" aria-hidden="true" tabindex="-1"></a>counts <span class="op">=</span> counts <span class="op">/</span> <span class="bu">float</span>(counts.<span class="bu">sum</span>())</span>
<span id="cb49-35"><a href="#cb49-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-36"><a href="#cb49-36" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">4</span>))</span>
<span id="cb49-37"><a href="#cb49-37" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].bar(bins, counts, color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.2</span>)</span>
<span id="cb49-38"><a href="#cb49-38" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].step(np.append(<span class="op">-</span><span class="dv">1</span>,X) <span class="op">+</span> <span class="fl">0.5</span>, np.append(<span class="dv">0</span>,p), color<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb49-39"><a href="#cb49-39" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].plot(samples[<span class="op">-</span><span class="dv">500</span>:], color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.75</span>)</span>
<span id="cb49-40"><a href="#cb49-40" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-43-output-1.png" width="922" height="346"></p>
</div>
</div>
</section>
<section id="pros-and-cons-of-mcmc" class="level3">
<h3 class="anchored" data-anchor-id="pros-and-cons-of-mcmc">Pros and cons of MCMC</h3>
<p>Pros:</p>
<ul>
<li><p>Very versatile framework: the Metropolis-Hastings algorithm allows us to simulate a Markov chain with a desired stationary distribution in a highly flexible manner. The requirements are much easier to satisfy than the requirements for importance or rejection sampling</p></li>
<li><p>We introduce local correlations which allows the simulation to zoom into the relevant regions of sample space</p></li>
</ul>
<p>Cons:</p>
<ul>
<li><p>We sample locally and pay the price of introducing correlations between successive samples. Local sampling might get stuck and ergodicity might be hard to achieve.</p></li>
<li><p>We don’t know how far away we are from the stationary distribution and are only given statistical guarantees for convergence in the long run</p></li>
</ul>
</section>
<section id="geometric-interpretation-of-the-metropolis-hastings-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="geometric-interpretation-of-the-metropolis-hastings-algorithm">Geometric interpretation of the Metropolis-Hastings algorithm</h3>
<p>The MH algorithm takes a base chain <span class="math inline">\(Q\)</span>, the proposal chain, that does not yet have the desired target distribution <span class="math inline">\(p\)</span> and tweaks it in such a way that the new chain has the correct distribution. This is achieved by constructing a new chain <span class="math inline">\(P\)</span> that is <span class="math inline">\(p\)</span>-reversible:</p>
<p><span id="eq-p-reversible"><span class="math display">\[
    P(x, y)\, p(y) = P(y, x)\, p(x)
\tag{61}\]</span></span></p>
<p>The mapping from <span class="math inline">\(Q\)</span> to <span class="math inline">\(P\)</span> involves the acceptance ratio</p>
<p><span id="eq-acceptance-ratio"><span class="math display">\[
    R(y, x) = \frac{Q(x, y)\, p(y)}{Q(y, x)\, p(x)}
\tag{62}\]</span></span></p>
<p>and is defined as</p>
<p><span id="eq-metropolized"><span class="math display">\[
P(y, x) = \left\{
\begin{array}{c c}
Q(y, x)\, \min\{1, R(y, x)\} &amp; \text{ if } y\not= x \\
\sum_z Q(z, x) \bigl(1 - \min\{1, R(z, x)\}\bigr) &amp; \text{ if } y=x\\
\end{array}\right.
\tag{63}\]</span></span></p>
<p>If <span class="math inline">\(Q\)</span> is irreducible, then <span class="math inline">\(P\)</span> is also irreducible.</p>
<p>The acceptance ratio <span class="math inline">\(R(y, x)\)</span> (Eq. <a href="#eq-acceptance-ratio">Equation&nbsp;62</a>) assesses how unbalanced the proposal chain is, i.e.&nbsp;how strongly <span class="math inline">\(Q\)</span> deviates from <span class="math inline">\(p\)</span>-reversibility. If <span class="math inline">\(Q\)</span> were already <span class="math inline">\(p\)</span>-reversible, then the ratio <span class="math inline">\(R\)</span> would always be one, and the proposal would always be accepted. The larger <span class="math inline">\(R(y, x)\)</span> deviates from one, the more unbalanced is the proposal chain with regard to the target. Since <span class="math inline">\(R(x, y) = 1 / R(y, x)\)</span>, a strong flux of probability in one direction, results in a reduced flux of probability in the backwards direction.</p>
<p>To better understand how the mapping from some irreducible proposal chain <span class="math inline">\(Q\)</span> to a <span class="math inline">\(p\)</span>-reversible Metropolis chain <span class="math inline">\(P\)</span> works, let me try to explain a very nice paper by <a href="https://projecteuclid.org/euclid.ss/1015346318">Billera &amp; Diaconis: A Geometric Interpretation of the Metropolis-Hastings Algorithm</a>. This paper sets out to provide a global view on why the MH algorithm in some sense provides the optimal way of turning some arbitrary Markov chain <span class="math inline">\(Q\)</span> into a Markov chain with the desired stationary distribution.</p>
<p>First let us think of the space of all possible Markov chains indexed by states from the finite sample space <span class="math inline">\(\mathcal X\)</span>. This space is formed by left stochastic square matrices of size <span class="math inline">\(|\mathcal X|\)</span> and will be called <span class="math inline">\(\mathcal S(\mathcal X)\)</span>. <span class="math inline">\(\mathcal S(\mathcal X)\)</span> is convex, because the convex combination of two Markov matrices is again a stochastic matrix. The dimension of <span class="math inline">\(\mathcal S(\mathcal X)\)</span> is <span class="math inline">\(|\mathcal X|(|\mathcal X| -1 )\)</span>: there are <span class="math inline">\(|X|^2\)</span> non-negative entries in total from which we need to subtract <span class="math inline">\(|X|\)</span> diagonal entries that are fixed by column stochasticity (Eq. <a href="#eq-leftstochastic">Equation&nbsp;37</a>).</p>
<p>For a fixed target distribution <span class="math inline">\(p\)</span>, the subset <span class="math inline">\(\mathcal R(p)\)</span> of all Markov matrices that are <span class="math inline">\(p\)</span>-reversible <span id="eq-p-reversible-chains"><span class="math display">\[
\mathcal R(p) = \left\{ P \in \mathcal S(\mathcal X): P(x, y)\, p(y) = P(y, x)\, p(x) \right\}
\tag{64}\]</span></span> has dimension <span class="math inline">\(|\mathcal X|(|\mathcal X| - 1) / 2\)</span>, because <span class="math inline">\(p\)</span>-reversibility (Eq. <a href="#eq-p-reversible">Equation&nbsp;61</a>) fixes a triangular portion of the transition matrix</p>
<p><span class="math display">\[
P(y, x) = P(x, y) \frac{p(y)}{p(x)}
\]</span></p>
<p>We can either choose <span class="math inline">\(P(x, y)\)</span> upon which <span class="math inline">\(P(y, x)\)</span> is fixed, or vice versa. <span class="math inline">\(\mathcal R(p)\)</span> is a convex subspace of <span class="math inline">\(\mathcal S\)</span>: If <span class="math inline">\(P, P' \in \mathcal R(p)\)</span>, then <span class="math inline">\(\lambda P + (1-\lambda) P' \in \mathcal R(p)\)</span> for <span class="math inline">\(\lambda\in[0,1]\)</span>.</p>
<p>To get a visual impression, let us display the relevant matrix spaces for sample spaces with only two states (Eq. <a href="#eq-twostate">Equation&nbsp;35</a>). Due to the stochasticity constraints, 2-state Markov chains can be represented by points in a two-dimensional unit square. The axes of this space are spanned by <span class="math inline">\(\alpha = \Pr(x_2|x_1)\)</span> and <span class="math inline">\(\beta=\Pr(x_1|x_2)\)</span>. The <span class="math inline">\(p\)</span>-reversible chains form a one-dimensional subspace</p>
<p><span class="math display">\[
\mathcal R(p) = \left\{(\alpha, \beta) \in [0,1]^2 : \beta = \frac{p(x_1)}{p(x_2)}\,\alpha  \right\}
\]</span></p>
<p>a straight line segment through the origin with slope <span class="math inline">\(p(x_1)/p(x_2)\)</span>.</p>
<p>The following figure shows <span class="math inline">\(\mathcal{R}(p)\)</span> for <span class="math inline">\(p(x_1) = 0.4\)</span>, <span class="math inline">\(p(x_2) = 1-p(x_1) = 0.6\)</span>.</p>
<div class="cell" data-execution_count="43">
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 2D visualization</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> make_plot(p0<span class="op">=</span><span class="fl">0.4</span>, limits<span class="op">=</span>(<span class="op">-</span><span class="fl">0.05</span>, <span class="fl">1.05</span>), ax<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>    kw <span class="op">=</span> <span class="bu">dict</span>(xticks<span class="op">=</span>[<span class="fl">0.</span>,<span class="fl">0.5</span>, <span class="fl">1.0</span>], yticks<span class="op">=</span>[<span class="fl">0.</span>,<span class="fl">0.5</span>, <span class="fl">1.0</span>])</span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> ax <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a>        fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">5</span>, <span class="dv">5</span>), subplot_kw<span class="op">=</span>kw)</span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a>        fig <span class="op">=</span> <span class="va">None</span></span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a>    alpha <span class="op">=</span> beta <span class="op">=</span> np.linspace(<span class="fl">0.</span>, <span class="fl">1.</span>, <span class="dv">100</span>)</span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a>    ax.fill_between(alpha, beta<span class="op">*</span><span class="fl">0.</span>, beta<span class="op">*</span><span class="fl">0.</span><span class="op">+</span><span class="dv">1</span>, color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true" tabindex="-1"></a>    ax.axvline(<span class="fl">1.</span>, ls<span class="op">=</span><span class="st">'--'</span>, color<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb50-13"><a href="#cb50-13" aria-hidden="true" tabindex="-1"></a>    ax.axhline(<span class="fl">1.</span>, ls<span class="op">=</span><span class="st">'--'</span>, color<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb50-14"><a href="#cb50-14" aria-hidden="true" tabindex="-1"></a>    ax.axvline(<span class="fl">0.</span>, ls<span class="op">=</span><span class="st">'--'</span>, color<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb50-15"><a href="#cb50-15" aria-hidden="true" tabindex="-1"></a>    ax.axhline(<span class="fl">0.</span>, ls<span class="op">=</span><span class="st">'--'</span>, color<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb50-16"><a href="#cb50-16" aria-hidden="true" tabindex="-1"></a>    ax.plot(alpha, alpha<span class="op">*</span>p0<span class="op">/</span>(<span class="dv">1</span><span class="op">-</span>p0), lw<span class="op">=</span><span class="dv">3</span>, color<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb50-17"><a href="#cb50-17" aria-hidden="true" tabindex="-1"></a>    ax.annotate(<span class="vs">r'$\mathcal</span><span class="sc">{S}</span><span class="vs">(\mathcal</span><span class="sc">{X}</span><span class="vs">)$'</span>, (<span class="fl">.2</span>, <span class="fl">.8</span>), xycoords<span class="op">=</span><span class="st">'axes fraction'</span>, fontsize<span class="op">=</span><span class="dv">30</span>)</span>
<span id="cb50-18"><a href="#cb50-18" aria-hidden="true" tabindex="-1"></a>    ax.annotate(<span class="vs">r'$\mathcal</span><span class="sc">{R}</span><span class="vs">(p)$'</span>, (<span class="fl">.65</span>, <span class="fl">.36</span>), color<span class="op">=</span><span class="st">'r'</span>, xycoords<span class="op">=</span><span class="st">'axes fraction'</span>, fontsize<span class="op">=</span><span class="dv">30</span>)</span>
<span id="cb50-19"><a href="#cb50-19" aria-hidden="true" tabindex="-1"></a>    ax.set_xlim(<span class="op">*</span>limits)</span>
<span id="cb50-20"><a href="#cb50-20" aria-hidden="true" tabindex="-1"></a>    ax.set_ylim(<span class="op">*</span>limits)</span>
<span id="cb50-21"><a href="#cb50-21" aria-hidden="true" tabindex="-1"></a>    ax.set_xlabel(<span class="vs">r'$\alpha$'</span>)</span>
<span id="cb50-22"><a href="#cb50-22" aria-hidden="true" tabindex="-1"></a>    ax.set_ylabel(<span class="vs">r'$\beta$'</span>)</span>
<span id="cb50-23"><a href="#cb50-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> fig:</span>
<span id="cb50-24"><a href="#cb50-24" aria-hidden="true" tabindex="-1"></a>        fig.tight_layout()</span>
<span id="cb50-25"><a href="#cb50-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-26"><a href="#cb50-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> fig, ax</span>
<span id="cb50-27"><a href="#cb50-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-28"><a href="#cb50-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-29"><a href="#cb50-29" aria-hidden="true" tabindex="-1"></a>p0 <span class="op">=</span> <span class="fl">0.4</span></span>
<span id="cb50-30"><a href="#cb50-30" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> make_plot(p0)</span>
<span id="cb50-31"><a href="#cb50-31" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-44-output-1.png" width="440" height="442"></p>
</div>
</div>
<p>The Metropolis-Hastings algorithm maps an irreducible proposal chain <span class="math inline">\(Q\)</span> to <span class="math inline">\(\mathcal R(p)\)</span></p>
<p><span id="eq-Metropolis-map"><span class="math display">\[
M[Q](y, x) = \min\left\{Q(y, x), \frac{p(y)}{p(x)}\,Q(x, y) \right\}
\tag{65}\]</span></span></p>
<p>for <span class="math inline">\(y\not= x\)</span> (the diagonal entries are fixed by column stochasticity (Eq. <a href="#eq-leftstochastic">Equation&nbsp;37</a>)). The function <span class="math inline">\(M: \mathcal S(\mathcal X) \to \mathcal R(p)\)</span> is called <em>Metropolis map</em>. For a two-state system, the map is simply</p>
<p><span class="math display">\[
\begin{pmatrix}
\alpha \\ \beta
\end{pmatrix} \to
\min\bigl\{\alpha\, p(x_1), \beta\, (1-p(x_2)) \bigr\}
\begin{pmatrix}
1 / p(x_1) \\ 1 / p(x_2)
\end{pmatrix}
\]</span></p>
<p>Examples for the Metropolis map are shown in the following figure:</p>
<div class="cell" data-execution_count="44">
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> M(p0, alpha, beta):</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>    alpha_new <span class="op">=</span> <span class="bu">min</span>(alpha, (<span class="dv">1</span><span class="op">-</span>p0) <span class="op">*</span> beta <span class="op">/</span> p0) </span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>    beta_new <span class="op">=</span> <span class="bu">min</span>(beta, p0 <span class="op">*</span> alpha <span class="op">/</span> (<span class="dv">1</span><span class="op">-</span>p0))</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> alpha_new, beta_new</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> make_plot(p0)</span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> Q <span class="kw">in</span> [(<span class="fl">0.1</span>, <span class="fl">0.8</span>), (<span class="fl">0.8</span>, <span class="fl">0.2</span>), (<span class="fl">0.9</span>, <span class="fl">0.5</span>), (<span class="fl">0.9</span>, <span class="fl">0.9</span>), (<span class="fl">0.5</span>, <span class="fl">0.5</span>)]:</span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>    P <span class="op">=</span> M(p0, <span class="op">*</span>Q)</span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>    ax.plot([Q[<span class="dv">0</span>],P[<span class="dv">0</span>]],[Q[<span class="dv">1</span>],P[<span class="dv">1</span>]], ls<span class="op">=</span><span class="st">'--'</span>, marker<span class="op">=</span><span class="st">'o'</span>, markersize<span class="op">=</span><span class="dv">10</span>,</span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a>            markeredgecolor<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-45-output-1.png" width="440" height="442"></p>
</div>
</div>
<p>By construction, the off-diagonal entries in the Metropolis chain <span class="math inline">\(M[Q]\)</span> are <em>coordinate-wise decreasing</em>:</p>
<p><span id="eq-coordinatewise-decreasing"><span class="math display">\[
M[Q](y, x) \le Q(y, x)\,\,\,\text{for all}\,\, x, y \in \mathcal X \, .
\tag{66}\]</span></span></p>
<p>In the above figure, <span class="math inline">\(Q\)</span> is either shifted to the left along the <span class="math inline">\(\alpha\)</span> axis, i.e.&nbsp;towards smaller <span class="math inline">\(P(x_2, x_1)\)</span> values until <span class="math inline">\(\mathcal{R}(p)\)</span> is hit, or <span class="math inline">\(Q\)</span> is shifted downwards long the <span class="math inline">\(\beta\)</span> axis.</p>
<p>A suitable metric on <span class="math inline">\(\mathcal S(\mathcal{X})\)</span> is</p>
<p><span id="eq-metric"><span class="math display">\[
d(P, P') = \sum_{x\in\mathcal{X}} \sum_{y\not= x} p(x)\, \left|P(y, x) - P'(y, x)\right|
\tag{67}\]</span></span></p>
<p>which is only zero, if <span class="math inline">\(P'=P\)</span>. The following figure shows “circles” around some <span class="math inline">\(Q\in\mathcal S(\mathcal X)\)</span> which are of course not actual circles because <span class="math inline">\(d(P,P')\)</span> is a weighted L1 norm, so <span class="math inline">\(d\)</span>-circles are diamonds.</p>
<p>For the 2-state system, we have</p>
<p><span class="math display">\[
d(P, P') = p(x_1)\, |\alpha - \alpha'| + p(x_2)\, |\beta - \beta'|
\]</span></p>
<p>where <span class="math inline">\(\alpha, \alpha'\)</span> etc. are the off-diagonal entries of the transition matrices <span class="math inline">\(P, P'\)</span>.</p>
<div class="cell" data-execution_count="45">
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> distance(p, P, Q):</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>    M <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> np.eye(<span class="bu">len</span>(p))</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.<span class="bu">sum</span>(np.fabs(P<span class="op">-</span>Q)<span class="op">*</span>M<span class="op">*</span>p)</span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> circle(p0, Q, factor<span class="op">=</span><span class="fl">0.95</span>):</span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a>    P <span class="op">=</span> M(p0, <span class="op">*</span>Q)</span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> transition_matrix(<span class="op">*</span>Q)</span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a>    B <span class="op">=</span> transition_matrix(<span class="op">*</span>P)</span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-12"><a href="#cb52-12" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> np.array([p0, <span class="dv">1</span><span class="op">-</span>p0])                          </span>
<span id="cb52-13"><a href="#cb52-13" aria-hidden="true" tabindex="-1"></a>    d <span class="op">=</span> distance(p, A, B) <span class="op">*</span> factor</span>
<span id="cb52-14"><a href="#cb52-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-15"><a href="#cb52-15" aria-hidden="true" tabindex="-1"></a>    alpha <span class="op">=</span> np.linspace(<span class="fl">0.</span>, <span class="fl">1.</span>, <span class="dv">100</span>)</span>
<span id="cb52-16"><a href="#cb52-16" aria-hidden="true" tabindex="-1"></a>    beta <span class="op">=</span> (d <span class="op">-</span> np.fabs(alpha<span class="op">-</span>Q[<span class="dv">0</span>]) <span class="op">*</span> p0) <span class="op">/</span> (<span class="dv">1</span><span class="op">-</span>p0)</span>
<span id="cb52-17"><a href="#cb52-17" aria-hidden="true" tabindex="-1"></a>    mask <span class="op">=</span> beta <span class="op">&gt;=</span> <span class="dv">0</span></span>
<span id="cb52-18"><a href="#cb52-18" aria-hidden="true" tabindex="-1"></a>    alpha <span class="op">=</span> alpha[mask]</span>
<span id="cb52-19"><a href="#cb52-19" aria-hidden="true" tabindex="-1"></a>    beta <span class="op">=</span> beta[mask]</span>
<span id="cb52-20"><a href="#cb52-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb52-21"><a href="#cb52-21" aria-hidden="true" tabindex="-1"></a>    alpha <span class="op">=</span> np.append(alpha, alpha[::<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb52-22"><a href="#cb52-22" aria-hidden="true" tabindex="-1"></a>    beta <span class="op">=</span> np.append(Q[<span class="dv">1</span>]<span class="op">-</span>beta, Q[<span class="dv">1</span>]<span class="op">+</span>beta[::<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb52-23"><a href="#cb52-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb52-24"><a href="#cb52-24" aria-hidden="true" tabindex="-1"></a>    mask <span class="op">=</span> np.logical_and(beta <span class="op">&gt;=</span> <span class="dv">0</span>, beta <span class="op">&lt;=</span> <span class="dv">1</span>)</span>
<span id="cb52-25"><a href="#cb52-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-26"><a href="#cb52-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> d, alpha[mask], beta[mask]</span>
<span id="cb52-27"><a href="#cb52-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb52-28"><a href="#cb52-28" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">10</span>))</span>
<span id="cb52-29"><a href="#cb52-29" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> <span class="bu">list</span>(ax.flat)</span>
<span id="cb52-30"><a href="#cb52-30" aria-hidden="true" tabindex="-1"></a>counter <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb52-31"><a href="#cb52-31" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> Q <span class="kw">in</span> [(<span class="fl">0.1</span>, <span class="fl">0.8</span>), (<span class="fl">0.8</span>, <span class="fl">0.2</span>), (<span class="fl">0.9</span>, <span class="fl">0.5</span>), (<span class="fl">0.5</span>, <span class="fl">0.5</span>)][:<span class="dv">4</span>]:</span>
<span id="cb52-32"><a href="#cb52-32" aria-hidden="true" tabindex="-1"></a>    make_plot(p0, ax<span class="op">=</span>ax[counter])</span>
<span id="cb52-33"><a href="#cb52-33" aria-hidden="true" tabindex="-1"></a>    P <span class="op">=</span> M(p0, <span class="op">*</span>Q)</span>
<span id="cb52-34"><a href="#cb52-34" aria-hidden="true" tabindex="-1"></a>    R <span class="op">=</span> Q[<span class="dv">1</span>] <span class="op">*</span> p0 <span class="op">/</span> (<span class="dv">1</span><span class="op">-</span>p0) <span class="op">/</span> Q[<span class="dv">0</span>]</span>
<span id="cb52-35"><a href="#cb52-35" aria-hidden="true" tabindex="-1"></a>    ax[counter].set_title(<span class="vs">r'$|\log R| = </span><span class="sc">{0:.1f}</span><span class="vs">$'</span>.<span class="bu">format</span>(np.fabs(np.log(R))))</span>
<span id="cb52-36"><a href="#cb52-36" aria-hidden="true" tabindex="-1"></a>    ax[counter].plot([Q[<span class="dv">0</span>],P[<span class="dv">0</span>]],[Q[<span class="dv">1</span>],P[<span class="dv">1</span>]], ls<span class="op">=</span><span class="st">'--'</span>, marker<span class="op">=</span><span class="st">'o'</span>, markersize<span class="op">=</span><span class="dv">10</span>,</span>
<span id="cb52-37"><a href="#cb52-37" aria-hidden="true" tabindex="-1"></a>            markeredgecolor<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb52-38"><a href="#cb52-38" aria-hidden="true" tabindex="-1"></a>    d, alpha, beta <span class="op">=</span> circle(p0, Q, <span class="fl">0.97</span>)</span>
<span id="cb52-39"><a href="#cb52-39" aria-hidden="true" tabindex="-1"></a>    ax[counter].set_title(<span class="vs">r'$d(Q,M[Q]) = </span><span class="sc">{0:.2f}</span><span class="vs">$'</span>.<span class="bu">format</span>(d))</span>
<span id="cb52-40"><a href="#cb52-40" aria-hidden="true" tabindex="-1"></a>    ax[counter].plot(alpha, beta, color<span class="op">=</span><span class="st">'k'</span>, ls<span class="op">=</span><span class="st">'--'</span>)</span>
<span id="cb52-41"><a href="#cb52-41" aria-hidden="true" tabindex="-1"></a>    counter <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb52-42"><a href="#cb52-42" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-46-output-1.png" width="919" height="920"></p>
</div>
</div>
<p>Billera and Diaconis demonstrate that the Metropolis map minimizes the distance <span class="math inline">\(d(Q,P)\)</span> between the proposal chain <span class="math inline">\(Q\)</span> and all <span class="math inline">\(P\in\mathcal{R}(p)\)</span>. Among all minimizers in the set of <span class="math inline">\(p\)</span>-reversible chains, it picks the unique element that is coordinate-wise decreasing (Eq. <a href="#eq-coordinatewise-decreasing">Equation&nbsp;66</a>). It makes sense to demand that the mapping is coordinate-wise decreasing, because otherwise it will be more difficult to guarantee that the mapped chain is still in <span class="math inline">\(\mathcal S(\mathcal X)\)</span>.</p>
</section>
<section id="variations-of-metropolis-hastings" class="level3">
<h3 class="anchored" data-anchor-id="variations-of-metropolis-hastings">Variations of Metropolis-Hastings</h3>
<p>Given a proposal chain <span class="math inline">\(Q\)</span>, our goal is to change it to a chain with stationary distribution <span class="math inline">\(p(x)\)</span>. The new chain should work as follows:</p>
<ul>
<li><p>Propose <span class="math inline">\(y \sim Q(\cdot, x)\)</span></p></li>
<li><p>Accept or reject <span class="math inline">\(y\)</span> as new <span class="math inline">\(x\)</span> with probability <span class="math inline">\(A(y, x)\in[0,1]\)</span></p></li>
</ul>
<p>The transition probabilities of the new chain will be</p>
<p><span class="math display">\[
Q(y, x)\, A(y, x)\,\,\,\text{for}\,\, y\not= x \, .
\]</span></p>
<p>Again, the diagonal entries a fixed by column stochasticity. To impose stationarity with regard to our target, we demand that the new chain is <span class="math inline">\(p\)</span>-reversible:</p>
<p><span class="math display">\[
Q(y, x)\, A(y, x)\, p(x) = Q(x, y)\, A(x, y)\, p(y)
\]</span></p>
<p>which gives us</p>
<p><span class="math display">\[
A(y, x) = \frac{Q(x, y)}{Q(y, x)}\frac{p(y)}{p(x)}\, A(x, y) = R(y, x)\, A(x, y)\, .
\]</span></p>
<p>Since <span class="math inline">\(A(y, x) \in [0, 1]\)</span> is a probability, it follows that</p>
<p><span class="math display">\[
A(x, y) = \frac{1}{R(y, x)} \, A(y, x) \le 1 \,\,\,\Rightarrow\,\,\,
A(y, x) \le R(y, x)
\]</span></p>
<p>Combined with <span class="math inline">\(A(y, x)\le 1\)</span>, we have</p>
<p><span class="math display">\[
A(y, x) \le \min\left\{1, R(y, x)\right\}
\]</span></p>
<p>That is, the acceptance probability of any propose-accept scheme is smaller than or equal to the acceptance probability of the Metropolis-Hastings algorithm. The MH algorithm maximizes the chance of moving away from <span class="math inline">\(x\)</span>.</p>
<p>Other choices for <span class="math inline">\(A(y, x)\)</span> have been proposed. These are typically of the form <span class="math inline">\(A(y, x) = f(R(y, x))\)</span> where</p>
<p><span class="math display">\[
0 \le f(r) \le \min\left\{1, r \right\},\,\,\, r\ge 0
\]</span></p>
<p>For example, Barker’s algorithm uses a sigmoidal function <span class="math inline">\(f(r) = r / (1 + r)\)</span> such that</p>
<p><span class="math display">\[
A(y, x) = \frac{R(y, x)}{1 + R(y, x)}
\]</span></p>
<p>An early investigation into different acceptance probabilities is: <a href="https://academic.oup.com/biomet/article/60/3/607/217255">Peskun, P. H. (1973). Optimum Monte Carlo sampling using Markov chains. Biometrika, 60:607–612.</a></p>
<div class="cell" data-execution_count="46">
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Barker's acceptance probability</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>R <span class="op">=</span> np.linspace(<span class="fl">0.</span>, <span class="fl">2.</span>, <span class="dv">100</span>)</span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>acc_barker <span class="op">=</span> R <span class="op">/</span> (<span class="dv">1</span> <span class="op">+</span> R)</span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>acc_metropolis <span class="op">=</span> np.clip(R, <span class="fl">0.</span>, <span class="fl">1.</span>)</span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">7</span>))</span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a>ax.plot(R, acc_barker, color<span class="op">=</span><span class="st">'r'</span>, label<span class="op">=</span><span class="st">'Barker'</span>, lw<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a>ax.plot(R, acc_metropolis, color<span class="op">=</span><span class="st">'b'</span>, label<span class="op">=</span><span class="st">'Metropolis'</span>, lw<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="vs">r'acceptance ratio $R(y, x)$'</span>)</span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="vs">r'acceptance probability $A(y, x)$'</span>)</span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a>ax.legend()</span>
<span id="cb53-13"><a href="#cb53-13" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-47-output-1.png" width="920" height="632"></p>
</div>
</div>
</section>
<section id="metropolis-hastings-in-continuous-sample-spaces" class="level3">
<h3 class="anchored" data-anchor-id="metropolis-hastings-in-continuous-sample-spaces">Metropolis-Hastings in continuous sample spaces</h3>
<p>The MH algorithm works also for continuous sample space where <span class="math inline">\(p\)</span> is a pdf and <span class="math inline">\(Q(y, x)\)</span> is a Markov kernel. The following example uses a uniform proposal kernel</p>
<p><span class="math display">\[
Q(y, x) = \mathcal U(x - \epsilon, x + \epsilon)
\]</span></p>
<p>with <span class="math inline">\(\epsilon &gt; 0\)</span> being a step size. Since <span class="math inline">\(Q(y, x) = Q(x, y)\)</span>, the acceptance ratio simplifies to <span class="math inline">\(p(y)/p(x)\)</span>. Let us try to sample from the standard Gaussian distribution</p>
<p><span class="math display">\[
p(x) \propto \exp\left\{-\frac{1}{2} x^2 \right\}
\]</span></p>
<div class="cell" data-execution_count="47">
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="co"># sampling a standard Gaussian with a uniform proposal</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> MetropolisHastings:</span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, x, p, Q, S<span class="op">=</span><span class="fl">1e4</span>):</span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a><span class="co">        Parameters</span></span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a><span class="co">        ----------</span></span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a><span class="co">        x : initial state</span></span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a><span class="co">        p : target distribution</span></span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a><span class="co">        Q : simulator of a symmetric proposal chain</span></span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a><span class="co">        S : number of samples</span></span>
<span id="cb54-13"><a href="#cb54-13" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb54-14"><a href="#cb54-14" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.p <span class="op">=</span> p</span>
<span id="cb54-15"><a href="#cb54-15" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.Q <span class="op">=</span> Q</span>
<span id="cb54-16"><a href="#cb54-16" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.S <span class="op">=</span> S</span>
<span id="cb54-17"><a href="#cb54-17" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._initial <span class="op">=</span> x</span>
<span id="cb54-18"><a href="#cb54-18" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb54-19"><a href="#cb54-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _reset(<span class="va">self</span>):</span>
<span id="cb54-20"><a href="#cb54-20" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._counter <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb54-21"><a href="#cb54-21" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.n_accepted <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb54-22"><a href="#cb54-22" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.x <span class="op">=</span> <span class="va">self</span>._initial</span>
<span id="cb54-23"><a href="#cb54-23" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb54-24"><a href="#cb54-24" aria-hidden="true" tabindex="-1"></a>    <span class="at">@property</span></span>
<span id="cb54-25"><a href="#cb54-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> acceptance_rate(<span class="va">self</span>):</span>
<span id="cb54-26"><a href="#cb54-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.n_accepted <span class="op">/</span> <span class="va">self</span>._counter</span>
<span id="cb54-27"><a href="#cb54-27" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb54-28"><a href="#cb54-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__next__</span>(<span class="va">self</span>):</span>
<span id="cb54-29"><a href="#cb54-29" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb54-30"><a href="#cb54-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>._counter <span class="op">&gt;=</span> <span class="va">self</span>.S:</span>
<span id="cb54-31"><a href="#cb54-31" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">StopIteration</span></span>
<span id="cb54-32"><a href="#cb54-32" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb54-33"><a href="#cb54-33" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> <span class="va">self</span>.Q(<span class="va">self</span>.x)</span>
<span id="cb54-34"><a href="#cb54-34" aria-hidden="true" tabindex="-1"></a>        u <span class="op">=</span> np.random.uniform()</span>
<span id="cb54-35"><a href="#cb54-35" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb54-36"><a href="#cb54-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> u <span class="op">&lt;=</span> <span class="va">self</span>.p(y) <span class="op">/</span> <span class="va">self</span>.p(<span class="va">self</span>.x):</span>
<span id="cb54-37"><a href="#cb54-37" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.x <span class="op">=</span> y</span>
<span id="cb54-38"><a href="#cb54-38" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.n_accepted <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb54-39"><a href="#cb54-39" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._counter <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb54-40"><a href="#cb54-40" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb54-41"><a href="#cb54-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.x</span>
<span id="cb54-42"><a href="#cb54-42" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb54-43"><a href="#cb54-43" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__iter__</span>(<span class="va">self</span>):</span>
<span id="cb54-44"><a href="#cb54-44" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._reset()</span>
<span id="cb54-45"><a href="#cb54-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span></span>
<span id="cb54-46"><a href="#cb54-46" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb54-47"><a href="#cb54-47" aria-hidden="true" tabindex="-1"></a><span class="co"># target</span></span>
<span id="cb54-48"><a href="#cb54-48" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> <span class="kw">lambda</span> x: np.exp(<span class="op">-</span>x<span class="op">**</span><span class="dv">2</span><span class="op">/</span><span class="dv">2</span>)</span>
<span id="cb54-49"><a href="#cb54-49" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">1</span>, <span class="fl">1.</span>, <span class="dv">1000</span>) <span class="op">*</span> <span class="dv">5</span></span>
<span id="cb54-50"><a href="#cb54-50" aria-hidden="true" tabindex="-1"></a>target <span class="op">=</span> t, p(t) <span class="op">/</span> np.sqrt(<span class="dv">2</span><span class="op">*</span>np.pi)</span>
<span id="cb54-51"><a href="#cb54-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-52"><a href="#cb54-52" aria-hidden="true" tabindex="-1"></a><span class="co"># proposal</span></span>
<span id="cb54-53"><a href="#cb54-53" aria-hidden="true" tabindex="-1"></a>Q <span class="op">=</span> <span class="kw">lambda</span> x, eps<span class="op">=</span><span class="fl">0.1</span>: np.random.uniform(x<span class="op">-</span>eps, x<span class="op">+</span>eps)</span>
<span id="cb54-54"><a href="#cb54-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-55"><a href="#cb54-55" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> <span class="fl">1e4</span></span>
<span id="cb54-56"><a href="#cb54-56" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="fl">10.</span></span>
<span id="cb54-57"><a href="#cb54-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-58"><a href="#cb54-58" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">3</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">9</span>), sharex<span class="op">=</span><span class="st">'col'</span>)</span>
<span id="cb54-59"><a href="#cb54-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-60"><a href="#cb54-60" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, eps <span class="kw">in</span> <span class="bu">enumerate</span>([<span class="fl">1e-1</span>, <span class="fl">1e0</span>, <span class="fl">1e1</span>]):</span>
<span id="cb54-61"><a href="#cb54-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-62"><a href="#cb54-62" aria-hidden="true" tabindex="-1"></a>    <span class="co"># run MH simulation</span></span>
<span id="cb54-63"><a href="#cb54-63" aria-hidden="true" tabindex="-1"></a>    mh <span class="op">=</span> MetropolisHastings(x, p, <span class="kw">lambda</span> x: Q(x, eps), S)</span>
<span id="cb54-64"><a href="#cb54-64" aria-hidden="true" tabindex="-1"></a>    samples <span class="op">=</span> np.array(<span class="bu">list</span>(mh))</span>
<span id="cb54-65"><a href="#cb54-65" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb54-66"><a href="#cb54-66" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">'acceptance rate: </span><span class="sc">{0:.1%}</span><span class="st"> (stepsize = </span><span class="sc">{1:.2e}</span><span class="st">)'</span>.<span class="bu">format</span>(</span>
<span id="cb54-67"><a href="#cb54-67" aria-hidden="true" tabindex="-1"></a>        mh.acceptance_rate, eps))</span>
<span id="cb54-68"><a href="#cb54-68" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb54-69"><a href="#cb54-69" aria-hidden="true" tabindex="-1"></a>    <span class="co"># plot results</span></span>
<span id="cb54-70"><a href="#cb54-70" aria-hidden="true" tabindex="-1"></a>    ax[i,<span class="dv">0</span>].plot(samples, color<span class="op">=</span><span class="st">'k'</span>, lw<span class="op">=</span><span class="dv">2</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb54-71"><a href="#cb54-71" aria-hidden="true" tabindex="-1"></a>    ax[i,<span class="dv">1</span>].hist(samples, bins<span class="op">=</span><span class="dv">50</span>, density<span class="op">=</span><span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.2</span>, color<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb54-72"><a href="#cb54-72" aria-hidden="true" tabindex="-1"></a>    ax[i,<span class="dv">2</span>].hist(samples[<span class="dv">1000</span>:], bins<span class="op">=</span><span class="dv">50</span>, density<span class="op">=</span><span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.2</span>, color<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb54-73"><a href="#cb54-73" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> a <span class="kw">in</span> ax[i,<span class="dv">1</span>:]:</span>
<span id="cb54-74"><a href="#cb54-74" aria-hidden="true" tabindex="-1"></a>        a.plot(<span class="op">*</span>target, color<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb54-75"><a href="#cb54-75" aria-hidden="true" tabindex="-1"></a>        a.set_ylim(<span class="fl">0.</span>, <span class="fl">0.45</span>)</span>
<span id="cb54-76"><a href="#cb54-76" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>acceptance rate: 97.4% (stepsize = 1.00e-01)</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>acceptance rate: 80.8% (stepsize = 1.00e+00)</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>acceptance rate: 15.4% (stepsize = 1.00e+01)</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-48-output-4.png" width="1114" height="824"></p>
</div>
</div>
</section>
</section>
</section>
<section id="lecture-6-gibbs-sampling-1" class="level1">
<h1>Lecture 6: Gibbs sampling</h1>
<p>Michael Habeck - University Hospital Jena - michael.habeck@uni-jena.de</p>
<section id="outline-5" class="level2">
<h2 class="anchored" data-anchor-id="outline-5">Outline</h2>
<ul>
<li>Recap: Metropolis-Hastings algorithm</li>
<li>Combining Markov chains</li>
<li>Gibbs sampling</li>
<li>Auxiliary variable methods</li>
</ul>
</section>
<section id="recap-2" class="level2">
<h2 class="anchored" data-anchor-id="recap-2">Recap</h2>
<ul>
<li><p>Markov chain Monte Carlo (MCMC) algorithms simulate a Markov chain to generate samples from a target distribution <span class="math inline">\(p\)</span></p></li>
<li><p>The Metropolis-Hastings (MH) algorithm is a very general scheme to generate a <em>reversible</em> Markov chain whose stationary distribution is a desired target distribution</p></li>
</ul>
<section id="metropolis-hastings-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="metropolis-hastings-algorithm">Metropolis-Hastings Algorithm</h3>
<p>The MH algorithm allows us to map (almost) any Markov chain <span class="math inline">\(Q\)</span> (the <em>proposal chain</em>) with whatever stationary distribution to a Markov chain <span class="math inline">\(M[Q]\)</span> (the <em>Metropolis map</em> of <span class="math inline">\(Q\)</span>) that has the desired stationary distribution, our target distribution <span class="math inline">\(p\)</span>. We have</p>
<p><span class="math display">\[
M[Q](y, x) = \min\left\{Q(y, x), Q(x, y)\frac{p(y)}{p(x)} \right\} \,\,\, \text{for}\,\,\, y\not=x\, .
\]</span></p>
<p>By construction, the Metropolis map is coordinate-wise decreasing, <span class="math inline">\(M[Q](y, x) \le Q(y, x)\)</span>. Among all maps that implement a <em>propose-accept/reject</em> scheme, <span class="math inline">\(M[Q]\)</span> <em>maximizes</em> the probability of moving from a current state to a new state proposed by <span class="math inline">\(Q\)</span>. The Metropolis map projects the proposal chain <span class="math inline">\(Q\)</span> onto the subspace <span class="math inline">\(\mathcal{R}(p)\)</span> of <span class="math inline">\(p\)</span>-reversible Markov chains. The projection minimizes the distance <span class="math inline">\(d(P,P') = \sum_{x\in\mathcal X} \sum_{y\not= x} p(x) |P(y, x) - P'(y, x)|\)</span>, and identifies <span class="math inline">\(M[Q]\in\mathcal{R}(p)\)</span> uniquely by demanding that the map is coordinate-wise decreasing.</p>
<div class="cell" data-execution_count="48">
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 2D visualization</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pylab <span class="im">as</span> plt</span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>plt.rc(<span class="st">'font'</span>, size<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> make_plot(p0<span class="op">=</span><span class="fl">0.4</span>, limits<span class="op">=</span>(<span class="op">-</span><span class="fl">0.05</span>, <span class="fl">1.05</span>), ax<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a>    kw <span class="op">=</span> <span class="bu">dict</span>(xticks<span class="op">=</span>[<span class="fl">0.</span>,<span class="fl">0.5</span>, <span class="fl">1.0</span>], yticks<span class="op">=</span>[<span class="fl">0.</span>,<span class="fl">0.5</span>, <span class="fl">1.0</span>])</span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> ax <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a>        fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">5</span>, <span class="dv">5</span>), subplot_kw<span class="op">=</span>kw)</span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb58-13"><a href="#cb58-13" aria-hidden="true" tabindex="-1"></a>        fig <span class="op">=</span> <span class="va">None</span></span>
<span id="cb58-14"><a href="#cb58-14" aria-hidden="true" tabindex="-1"></a>    alpha <span class="op">=</span> beta <span class="op">=</span> np.linspace(<span class="fl">0.</span>, <span class="fl">1.</span>, <span class="dv">100</span>)</span>
<span id="cb58-15"><a href="#cb58-15" aria-hidden="true" tabindex="-1"></a>    ax.fill_between(alpha, beta<span class="op">*</span><span class="fl">0.</span>, beta<span class="op">*</span><span class="fl">0.</span><span class="op">+</span><span class="dv">1</span>, color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb58-16"><a href="#cb58-16" aria-hidden="true" tabindex="-1"></a>    ax.axvline(<span class="fl">1.</span>, ls<span class="op">=</span><span class="st">'--'</span>, color<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb58-17"><a href="#cb58-17" aria-hidden="true" tabindex="-1"></a>    ax.axhline(<span class="fl">1.</span>, ls<span class="op">=</span><span class="st">'--'</span>, color<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb58-18"><a href="#cb58-18" aria-hidden="true" tabindex="-1"></a>    ax.axvline(<span class="fl">0.</span>, ls<span class="op">=</span><span class="st">'--'</span>, color<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb58-19"><a href="#cb58-19" aria-hidden="true" tabindex="-1"></a>    ax.axhline(<span class="fl">0.</span>, ls<span class="op">=</span><span class="st">'--'</span>, color<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb58-20"><a href="#cb58-20" aria-hidden="true" tabindex="-1"></a>    ax.plot(alpha, alpha<span class="op">*</span>p0<span class="op">/</span>(<span class="dv">1</span><span class="op">-</span>p0), lw<span class="op">=</span><span class="dv">3</span>, color<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb58-21"><a href="#cb58-21" aria-hidden="true" tabindex="-1"></a>    ax.annotate(<span class="vs">r'$\mathcal</span><span class="sc">{S}</span><span class="vs">(\mathcal</span><span class="sc">{X}</span><span class="vs">)$'</span>, (<span class="fl">.2</span>, <span class="fl">.8</span>), xycoords<span class="op">=</span><span class="st">'axes fraction'</span>, fontsize<span class="op">=</span><span class="dv">30</span>)</span>
<span id="cb58-22"><a href="#cb58-22" aria-hidden="true" tabindex="-1"></a>    ax.annotate(<span class="vs">r'$\mathcal</span><span class="sc">{R}</span><span class="vs">(p)$'</span>, (<span class="fl">.65</span>, <span class="fl">.36</span>), color<span class="op">=</span><span class="st">'r'</span>, xycoords<span class="op">=</span><span class="st">'axes fraction'</span>, fontsize<span class="op">=</span><span class="dv">30</span>)</span>
<span id="cb58-23"><a href="#cb58-23" aria-hidden="true" tabindex="-1"></a>    ax.set_xlim(<span class="op">*</span>limits)</span>
<span id="cb58-24"><a href="#cb58-24" aria-hidden="true" tabindex="-1"></a>    ax.set_ylim(<span class="op">*</span>limits)</span>
<span id="cb58-25"><a href="#cb58-25" aria-hidden="true" tabindex="-1"></a>    ax.set_xlabel(<span class="vs">r'$\alpha$'</span>)</span>
<span id="cb58-26"><a href="#cb58-26" aria-hidden="true" tabindex="-1"></a>    ax.set_ylabel(<span class="vs">r'$\beta$'</span>)</span>
<span id="cb58-27"><a href="#cb58-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> fig:</span>
<span id="cb58-28"><a href="#cb58-28" aria-hidden="true" tabindex="-1"></a>        fig.tight_layout()</span>
<span id="cb58-29"><a href="#cb58-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-30"><a href="#cb58-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> fig, ax</span>
<span id="cb58-31"><a href="#cb58-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-32"><a href="#cb58-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-33"><a href="#cb58-33" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> M(p0, alpha, beta):</span>
<span id="cb58-34"><a href="#cb58-34" aria-hidden="true" tabindex="-1"></a>    alpha_new <span class="op">=</span> <span class="bu">min</span>(alpha, (<span class="dv">1</span><span class="op">-</span>p0) <span class="op">*</span> beta <span class="op">/</span> p0) </span>
<span id="cb58-35"><a href="#cb58-35" aria-hidden="true" tabindex="-1"></a>    beta_new <span class="op">=</span> <span class="bu">min</span>(beta, p0 <span class="op">*</span> alpha <span class="op">/</span> (<span class="dv">1</span><span class="op">-</span>p0))</span>
<span id="cb58-36"><a href="#cb58-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> alpha_new, beta_new</span>
<span id="cb58-37"><a href="#cb58-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-38"><a href="#cb58-38" aria-hidden="true" tabindex="-1"></a>p0 <span class="op">=</span> <span class="fl">0.4</span></span>
<span id="cb58-39"><a href="#cb58-39" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> make_plot(p0)</span>
<span id="cb58-40"><a href="#cb58-40" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> Q <span class="kw">in</span> [(<span class="fl">0.1</span>, <span class="fl">0.8</span>), (<span class="fl">0.8</span>, <span class="fl">0.2</span>), (<span class="fl">0.9</span>, <span class="fl">0.5</span>), (<span class="fl">0.9</span>, <span class="fl">0.9</span>), (<span class="fl">0.5</span>, <span class="fl">0.5</span>)]:</span>
<span id="cb58-41"><a href="#cb58-41" aria-hidden="true" tabindex="-1"></a>    P <span class="op">=</span> M(p0, <span class="op">*</span>Q)</span>
<span id="cb58-42"><a href="#cb58-42" aria-hidden="true" tabindex="-1"></a>    ax.plot([Q[<span class="dv">0</span>],P[<span class="dv">0</span>]],[Q[<span class="dv">1</span>],P[<span class="dv">1</span>]], ls<span class="op">=</span><span class="st">'--'</span>, marker<span class="op">=</span><span class="st">'o'</span>, markersize<span class="op">=</span><span class="dv">10</span>,</span>
<span id="cb58-43"><a href="#cb58-43" aria-hidden="true" tabindex="-1"></a>            markeredgecolor<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb58-44"><a href="#cb58-44" aria-hidden="true" tabindex="-1"></a>ax.scatter(<span class="dv">1</span><span class="op">-</span>p0, p0, s<span class="op">=</span><span class="dv">120</span>, color<span class="op">=</span><span class="st">'k'</span>, zorder<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb58-45"><a href="#cb58-45" aria-hidden="true" tabindex="-1"></a>ax.annotate(<span class="vs">r'$p\mathbb</span><span class="sc">{1}</span><span class="vs">^T$'</span>, (<span class="dv">1</span><span class="op">-</span>p0<span class="op">-</span><span class="fl">0.05</span>, p0<span class="op">+</span><span class="fl">0.05</span>))</span>
<span id="cb58-46"><a href="#cb58-46" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-49-output-1.png" width="440" height="442"></p>
</div>
</div>
</section>
</section>
<section id="algorithmic-parameters" class="level2">
<h2 class="anchored" data-anchor-id="algorithmic-parameters">Algorithmic parameters</h2>
<p>Algorithmic parameters such as the step size used in the proposal chain can have a strong effect on the performance of MH sampling. We will later discuss <em>adaptive</em> MCMC algorithms that can tune some of these parameters in a sound fashion.</p>
<div class="cell" data-execution_count="49">
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="co"># sampling a standard Gaussian with a uniform proposal</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> MetropolisHastings:</span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, x, p, Q, S<span class="op">=</span><span class="fl">1e4</span>):</span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a><span class="co">        Parameters</span></span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a><span class="co">        ----------</span></span>
<span id="cb59-9"><a href="#cb59-9" aria-hidden="true" tabindex="-1"></a><span class="co">        x : initial state</span></span>
<span id="cb59-10"><a href="#cb59-10" aria-hidden="true" tabindex="-1"></a><span class="co">        p : target distribution</span></span>
<span id="cb59-11"><a href="#cb59-11" aria-hidden="true" tabindex="-1"></a><span class="co">        Q : simulator of a symmetric proposal chain</span></span>
<span id="cb59-12"><a href="#cb59-12" aria-hidden="true" tabindex="-1"></a><span class="co">        S : number of samples</span></span>
<span id="cb59-13"><a href="#cb59-13" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb59-14"><a href="#cb59-14" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.p <span class="op">=</span> p</span>
<span id="cb59-15"><a href="#cb59-15" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.Q <span class="op">=</span> Q</span>
<span id="cb59-16"><a href="#cb59-16" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.S <span class="op">=</span> S</span>
<span id="cb59-17"><a href="#cb59-17" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._initial <span class="op">=</span> x</span>
<span id="cb59-18"><a href="#cb59-18" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb59-19"><a href="#cb59-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _reset(<span class="va">self</span>):</span>
<span id="cb59-20"><a href="#cb59-20" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._counter <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb59-21"><a href="#cb59-21" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.n_accepted <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb59-22"><a href="#cb59-22" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.x <span class="op">=</span> <span class="va">self</span>._initial</span>
<span id="cb59-23"><a href="#cb59-23" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb59-24"><a href="#cb59-24" aria-hidden="true" tabindex="-1"></a>    <span class="at">@property</span></span>
<span id="cb59-25"><a href="#cb59-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> acceptance_rate(<span class="va">self</span>):</span>
<span id="cb59-26"><a href="#cb59-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.n_accepted <span class="op">/</span> <span class="va">self</span>._counter</span>
<span id="cb59-27"><a href="#cb59-27" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb59-28"><a href="#cb59-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__next__</span>(<span class="va">self</span>):</span>
<span id="cb59-29"><a href="#cb59-29" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb59-30"><a href="#cb59-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>._counter <span class="op">&gt;=</span> <span class="va">self</span>.S:</span>
<span id="cb59-31"><a href="#cb59-31" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">StopIteration</span></span>
<span id="cb59-32"><a href="#cb59-32" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb59-33"><a href="#cb59-33" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> <span class="va">self</span>.Q(<span class="va">self</span>.x)</span>
<span id="cb59-34"><a href="#cb59-34" aria-hidden="true" tabindex="-1"></a>        u <span class="op">=</span> np.random.uniform()</span>
<span id="cb59-35"><a href="#cb59-35" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb59-36"><a href="#cb59-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> u <span class="op">&lt;=</span> <span class="va">self</span>.p(y) <span class="op">/</span> <span class="va">self</span>.p(<span class="va">self</span>.x):</span>
<span id="cb59-37"><a href="#cb59-37" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.x <span class="op">=</span> y</span>
<span id="cb59-38"><a href="#cb59-38" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.n_accepted <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb59-39"><a href="#cb59-39" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._counter <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb59-40"><a href="#cb59-40" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb59-41"><a href="#cb59-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.x</span>
<span id="cb59-42"><a href="#cb59-42" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb59-43"><a href="#cb59-43" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__iter__</span>(<span class="va">self</span>):</span>
<span id="cb59-44"><a href="#cb59-44" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._reset()</span>
<span id="cb59-45"><a href="#cb59-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span></span>
<span id="cb59-46"><a href="#cb59-46" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb59-47"><a href="#cb59-47" aria-hidden="true" tabindex="-1"></a><span class="co"># target</span></span>
<span id="cb59-48"><a href="#cb59-48" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> <span class="kw">lambda</span> x: np.exp(<span class="op">-</span>x<span class="op">**</span><span class="dv">2</span><span class="op">/</span><span class="dv">2</span>)</span>
<span id="cb59-49"><a href="#cb59-49" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">1</span>, <span class="fl">1.</span>, <span class="dv">1000</span>) <span class="op">*</span> <span class="dv">5</span></span>
<span id="cb59-50"><a href="#cb59-50" aria-hidden="true" tabindex="-1"></a>target <span class="op">=</span> t, p(t) <span class="op">/</span> np.sqrt(<span class="dv">2</span><span class="op">*</span>np.pi)</span>
<span id="cb59-51"><a href="#cb59-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-52"><a href="#cb59-52" aria-hidden="true" tabindex="-1"></a><span class="co"># proposal</span></span>
<span id="cb59-53"><a href="#cb59-53" aria-hidden="true" tabindex="-1"></a>Q <span class="op">=</span> <span class="kw">lambda</span> x, eps<span class="op">=</span><span class="fl">0.1</span>: np.random.uniform(x<span class="op">-</span>eps, x<span class="op">+</span>eps)</span>
<span id="cb59-54"><a href="#cb59-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-55"><a href="#cb59-55" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> <span class="fl">1e4</span></span>
<span id="cb59-56"><a href="#cb59-56" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="fl">10.</span></span>
<span id="cb59-57"><a href="#cb59-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-58"><a href="#cb59-58" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">3</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">9</span>), sharex<span class="op">=</span><span class="st">'col'</span>)</span>
<span id="cb59-59"><a href="#cb59-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-60"><a href="#cb59-60" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, eps <span class="kw">in</span> <span class="bu">enumerate</span>([<span class="fl">1e-1</span>, <span class="fl">1e0</span>, <span class="fl">1e1</span>]):</span>
<span id="cb59-61"><a href="#cb59-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-62"><a href="#cb59-62" aria-hidden="true" tabindex="-1"></a>    <span class="co"># run MH simulation</span></span>
<span id="cb59-63"><a href="#cb59-63" aria-hidden="true" tabindex="-1"></a>    mh <span class="op">=</span> MetropolisHastings(x, p, <span class="kw">lambda</span> x: Q(x, eps), S)</span>
<span id="cb59-64"><a href="#cb59-64" aria-hidden="true" tabindex="-1"></a>    samples <span class="op">=</span> np.array(<span class="bu">list</span>(mh))</span>
<span id="cb59-65"><a href="#cb59-65" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb59-66"><a href="#cb59-66" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">'acceptance rate: </span><span class="sc">{0:.1%}</span><span class="st"> (stepsize = </span><span class="sc">{1:.2e}</span><span class="st">)'</span>.<span class="bu">format</span>(</span>
<span id="cb59-67"><a href="#cb59-67" aria-hidden="true" tabindex="-1"></a>        mh.acceptance_rate, eps))</span>
<span id="cb59-68"><a href="#cb59-68" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb59-69"><a href="#cb59-69" aria-hidden="true" tabindex="-1"></a>    <span class="co"># plot results</span></span>
<span id="cb59-70"><a href="#cb59-70" aria-hidden="true" tabindex="-1"></a>    ax[i,<span class="dv">0</span>].plot(samples, color<span class="op">=</span><span class="st">'k'</span>, lw<span class="op">=</span><span class="dv">2</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb59-71"><a href="#cb59-71" aria-hidden="true" tabindex="-1"></a>    ax[i,<span class="dv">1</span>].hist(samples, bins<span class="op">=</span><span class="dv">50</span>, density<span class="op">=</span><span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.2</span>, color<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb59-72"><a href="#cb59-72" aria-hidden="true" tabindex="-1"></a>    ax[i,<span class="dv">2</span>].hist(samples[<span class="dv">1000</span>:], bins<span class="op">=</span><span class="dv">50</span>, density<span class="op">=</span><span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.2</span>, color<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb59-73"><a href="#cb59-73" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> a <span class="kw">in</span> ax[i,<span class="dv">1</span>:]:</span>
<span id="cb59-74"><a href="#cb59-74" aria-hidden="true" tabindex="-1"></a>        a.plot(<span class="op">*</span>target, color<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb59-75"><a href="#cb59-75" aria-hidden="true" tabindex="-1"></a>        a.set_ylim(<span class="fl">0.</span>, <span class="fl">0.45</span>)</span>
<span id="cb59-76"><a href="#cb59-76" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>acceptance rate: 96.5% (stepsize = 1.00e-01)</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>acceptance rate: 79.5% (stepsize = 1.00e+00)</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>acceptance rate: 15.7% (stepsize = 1.00e+01)</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-50-output-4.png" width="1114" height="825"></p>
</div>
</div>
<p>In the next example, we run the MH algorithm on a continuous pdf in two dimensions.</p>
<div class="cell" data-execution_count="50">
<div class="sourceCode cell-code" id="cb63"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="co"># logsumexp(x) is semantically equivalent to log(sum(exp(x)))</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.special <span class="im">import</span> logsumexp</span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a><span class="co">"""</span></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a><span class="co">Metroplis sampling of a banana-shaped pdf</span></span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a><span class="co">"""</span></span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Banana:</span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-11"><a href="#cb63-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.C <span class="op">=</span> np.array([[<span class="fl">1.</span>, <span class="fl">0.9</span>],</span>
<span id="cb63-12"><a href="#cb63-12" aria-hidden="true" tabindex="-1"></a>                           [<span class="fl">0.9</span>, <span class="fl">1.</span>]])</span>
<span id="cb63-13"><a href="#cb63-13" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb63-14"><a href="#cb63-14" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.C_inv <span class="op">=</span> np.array([[<span class="fl">100.</span>, <span class="op">-</span><span class="fl">90.</span>],</span>
<span id="cb63-15"><a href="#cb63-15" aria-hidden="true" tabindex="-1"></a>                               [<span class="op">-</span><span class="dv">90</span>, <span class="fl">100.</span>]]) <span class="op">/</span> <span class="fl">19.</span></span>
<span id="cb63-16"><a href="#cb63-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-17"><a href="#cb63-17" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.a <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb63-18"><a href="#cb63-18" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.b <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb63-19"><a href="#cb63-19" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb63-20"><a href="#cb63-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(<span class="va">self</span>, x):</span>
<span id="cb63-21"><a href="#cb63-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-22"><a href="#cb63-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> x.ndim <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb63-23"><a href="#cb63-23" aria-hidden="true" tabindex="-1"></a>            x1, x2 <span class="op">=</span> x.T</span>
<span id="cb63-24"><a href="#cb63-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb63-25"><a href="#cb63-25" aria-hidden="true" tabindex="-1"></a>            x1, x2 <span class="op">=</span> x</span>
<span id="cb63-26"><a href="#cb63-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-27"><a href="#cb63-27" aria-hidden="true" tabindex="-1"></a>        a, b <span class="op">=</span> <span class="va">self</span>.a, <span class="va">self</span>.b</span>
<span id="cb63-28"><a href="#cb63-28" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb63-29"><a href="#cb63-29" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> np.transpose([x1 <span class="op">/</span> a, a <span class="op">*</span> x2 <span class="op">+</span> a <span class="op">*</span> b <span class="op">*</span> (x1<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> a)])</span>
<span id="cb63-30"><a href="#cb63-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-31"><a href="#cb63-31" aria-hidden="true" tabindex="-1"></a>        logp <span class="op">=</span> <span class="op">-</span><span class="fl">0.5</span> <span class="op">*</span> np.<span class="bu">sum</span>(y.dot(<span class="va">self</span>.C_inv.T) <span class="op">*</span> y, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb63-32"><a href="#cb63-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-33"><a href="#cb63-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> logp</span>
<span id="cb63-34"><a href="#cb63-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-35"><a href="#cb63-35" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_marginal(pdf2d, axis<span class="op">=</span><span class="dv">0</span>, vals<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb63-36"><a href="#cb63-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-37"><a href="#cb63-37" aria-hidden="true" tabindex="-1"></a>    marginal <span class="op">=</span> logsumexp(pdf2d, axis<span class="op">=</span>axis)</span>
<span id="cb63-38"><a href="#cb63-38" aria-hidden="true" tabindex="-1"></a>    marginal <span class="op">-=</span> logsumexp(marginal)</span>
<span id="cb63-39"><a href="#cb63-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-40"><a href="#cb63-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> vals <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb63-41"><a href="#cb63-41" aria-hidden="true" tabindex="-1"></a>        marginal <span class="op">-=</span> np.log(vals[<span class="dv">1</span>]<span class="op">-</span>vals[<span class="dv">0</span>])</span>
<span id="cb63-42"><a href="#cb63-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-43"><a href="#cb63-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> marginal</span>
<span id="cb63-44"><a href="#cb63-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-45"><a href="#cb63-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-46"><a href="#cb63-46" aria-hidden="true" tabindex="-1"></a>Q <span class="op">=</span> <span class="kw">lambda</span> x, eps<span class="op">=</span><span class="fl">1.</span>: x <span class="op">+</span> np.random.standard_normal(<span class="dv">2</span>) <span class="op">*</span> eps</span>
<span id="cb63-47"><a href="#cb63-47" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> Banana()</span>
<span id="cb63-48"><a href="#cb63-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-49"><a href="#cb63-49" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.zeros(<span class="dv">2</span>)</span>
<span id="cb63-50"><a href="#cb63-50" aria-hidden="true" tabindex="-1"></a>p_x <span class="op">=</span> p(x)</span>
<span id="cb63-51"><a href="#cb63-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-52"><a href="#cb63-52" aria-hidden="true" tabindex="-1"></a>samples <span class="op">=</span> [x]</span>
<span id="cb63-53"><a href="#cb63-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-54"><a href="#cb63-54" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="bu">len</span>(samples) <span class="op">&lt;</span> <span class="fl">1e4</span>:</span>
<span id="cb63-55"><a href="#cb63-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-56"><a href="#cb63-56" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> Q(x)</span>
<span id="cb63-57"><a href="#cb63-57" aria-hidden="true" tabindex="-1"></a>    p_y <span class="op">=</span> p(y)</span>
<span id="cb63-58"><a href="#cb63-58" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb63-59"><a href="#cb63-59" aria-hidden="true" tabindex="-1"></a>    accept <span class="op">=</span> np.log(np.random.uniform()) <span class="op">&lt;</span> p_y <span class="op">-</span> p_x</span>
<span id="cb63-60"><a href="#cb63-60" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> accept:</span>
<span id="cb63-61"><a href="#cb63-61" aria-hidden="true" tabindex="-1"></a>        x, p_x <span class="op">=</span> y, p_y</span>
<span id="cb63-62"><a href="#cb63-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-63"><a href="#cb63-63" aria-hidden="true" tabindex="-1"></a>    samples.append(x)</span>
<span id="cb63-64"><a href="#cb63-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-65"><a href="#cb63-65" aria-hidden="true" tabindex="-1"></a>samples <span class="op">=</span> np.array(samples)</span>
<span id="cb63-66"><a href="#cb63-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-67"><a href="#cb63-67" aria-hidden="true" tabindex="-1"></a><span class="co"># plot results</span></span>
<span id="cb63-68"><a href="#cb63-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-69"><a href="#cb63-69" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="op">-</span><span class="fl">3.</span>, <span class="fl">3.</span>, <span class="dv">200</span>)</span>
<span id="cb63-70"><a href="#cb63-70" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> np.linspace(<span class="op">-</span><span class="fl">8.</span>, <span class="fl">1.</span>, <span class="bu">len</span>(x))</span>
<span id="cb63-71"><a href="#cb63-71" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> np.reshape(np.meshgrid(x, y), (<span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span>)).T</span>
<span id="cb63-72"><a href="#cb63-72" aria-hidden="true" tabindex="-1"></a>pdf <span class="op">=</span> p(grid).reshape(<span class="bu">len</span>(x), <span class="bu">len</span>(y))</span>
<span id="cb63-73"><a href="#cb63-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-74"><a href="#cb63-74" aria-hidden="true" tabindex="-1"></a>pdf_x <span class="op">=</span> compute_marginal(pdf, axis<span class="op">=</span><span class="dv">0</span>, vals<span class="op">=</span>x)</span>
<span id="cb63-75"><a href="#cb63-75" aria-hidden="true" tabindex="-1"></a>pdf_y <span class="op">=</span> compute_marginal(pdf, axis<span class="op">=</span><span class="dv">1</span>, vals<span class="op">=</span>y)</span>
<span id="cb63-76"><a href="#cb63-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-77"><a href="#cb63-77" aria-hidden="true" tabindex="-1"></a>kw_hist <span class="op">=</span> <span class="bu">dict</span>(bins<span class="op">=</span><span class="dv">30</span>, color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.2</span>, density<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb63-78"><a href="#cb63-78" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">4</span>))</span>
<span id="cb63-79"><a href="#cb63-79" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb63-80"><a href="#cb63-80" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].contour(x, y, np.exp(pdf))</span>
<span id="cb63-81"><a href="#cb63-81" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].scatter(<span class="op">*</span>samples.T, color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.2</span>, s<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb63-82"><a href="#cb63-82" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_xlabel(<span class="vs">r'$x_1$'</span>)</span>
<span id="cb63-83"><a href="#cb63-83" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_ylabel(<span class="vs">r'$x_2$'</span>)</span>
<span id="cb63-84"><a href="#cb63-84" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb63-85"><a href="#cb63-85" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].hist(samples[:,<span class="dv">0</span>], <span class="op">**</span>kw_hist)</span>
<span id="cb63-86"><a href="#cb63-86" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].plot(x, np.exp(pdf_x), color<span class="op">=</span><span class="st">'r'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, lw<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb63-87"><a href="#cb63-87" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlabel(<span class="vs">r'$x_1$'</span>)</span>
<span id="cb63-88"><a href="#cb63-88" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_ylabel(<span class="vs">r'$p(x_1)$'</span>)</span>
<span id="cb63-89"><a href="#cb63-89" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb63-90"><a href="#cb63-90" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].hist(samples[:,<span class="dv">1</span>], <span class="op">**</span>kw_hist)                       </span>
<span id="cb63-91"><a href="#cb63-91" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].plot(y, np.exp(pdf_y), color<span class="op">=</span><span class="st">'r'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, lw<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb63-92"><a href="#cb63-92" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].set_xlabel(<span class="vs">r'$x_2$'</span>)</span>
<span id="cb63-93"><a href="#cb63-93" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].set_ylabel(<span class="vs">r'$p(x_2)$'</span>)</span>
<span id="cb63-94"><a href="#cb63-94" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb63-95"><a href="#cb63-95" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-51-output-1.png" width="1088" height="346"></p>
</div>
</div>
</section>
<section id="combining-markov-chains" class="level2">
<h2 class="anchored" data-anchor-id="combining-markov-chains">Combining Markov Chains</h2>
<p>Let <span class="math inline">\(P_i\)</span> be <span class="math inline">\(N\)</span> Markov chains that share the same stationary distribution <span class="math inline">\(\pi\)</span>:</p>
<p><span id="eq-multiple_chains"><span class="math display">\[
P_i \pi = \pi, \,\,\, \mathbb{1}^T\!P_i = \mathbb{1}^T
\tag{68}\]</span></span></p>
<p>The product of all chains, <span class="math inline">\(P=\prod_i P_i\)</span> (here <span class="math inline">\(\prod_i\)</span> symbolizes a <em>matrix product</em>), is also a Markov chain with the same stationary distribution:</p>
<p><span id="eq-product_chain"><span class="math display">\[
P\pi = \pi, \,\,\, \mathbb{1}^T\!P = \mathbb{1}^T
\tag{69}\]</span></span></p>
<p>Therefore, the following algorithm will simulate <span class="math inline">\(P\)</span> and therefore eventually <span class="math inline">\(\pi\)</span>:</p>
<p><span class="math display">\[\begin{align}\label{eq-markov-sequence}
\begin{split}
  \tilde{x}^{(1)} &amp;\sim P_1\bigl(\,\cdot\,, x^{(s)}\bigr) \\
  \tilde{x}^{(2)} &amp;\sim P_2\bigl(\,\cdot\,, \tilde{x}^{(1)}\bigr) \\
  &amp; \vdots   \\
  x^{(s+1)} &amp;\sim P_N\bigl(\,\cdot\,, \tilde{x}^{(N-1)}\bigr) \\
\end{split}
\end{align}\]</span></p>
<section id="coordinate-wise-sampling" class="level3">
<h3 class="anchored" data-anchor-id="coordinate-wise-sampling">Coordinate-wise sampling</h3>
<p>Let’s look at a special but important case. Assume that the sample space decomposes into a product of <span class="math inline">\(N\)</span> sample spaces <span class="math inline">\(\mathcal X = \mathcal X_1 \times \cdots \times \mathcal X_N\)</span> with associated variables <span class="math inline">\(x_i\)</span> (<span class="math inline">\(i=1, \ldots, N\)</span>) where <span class="math inline">\(x_i\)</span> denotes a single variable or a group of variables that will be sampled jointly. The joint distribution of all variables is <span class="math inline">\(p(x) = p(x_1, \ldots, x_N)\)</span>.</p>
<p>By <span class="math inline">\(x_{\setminus i}\)</span> we denote the variable vector obtained by omitting the <span class="math inline">\(i\)</span>-th variable (or group of variables):</p>
<p><span id="eq-without-group"><span class="math display">\[
x_{\setminus i} := \begin{pmatrix}x_1, \ldots, x_{i-1}, x_{i+1}, \ldots, x_N \end{pmatrix}
\tag{70}\]</span></span></p>
<p>Then <span class="math inline">\(x_{\setminus i}\)</span> follows the marginal distribution:</p>
<p><span id="eq-without-group-marginal"><span class="math display">\[
p_{\setminus i}(x_{\setminus i}) = \int p(x_1, \ldots, x_N)\, d x_i
\tag{71}\]</span></span></p>
<p>The marginal distribution of <span class="math inline">\(x_i\)</span> is:</p>
<p><span id="eq-group-marginal"><span class="math display">\[
p_{i}(x_{i}) = \int p(x_1, \ldots, x_N)\, d x_{\setminus i}
\tag{72}\]</span></span></p>
<p>The conditional distribution of <span class="math inline">\(x_i\)</span> also readily available:</p>
<p><span id="eq-group-conditional"><span class="math display">\[
p_{i}(x_{i}|x_{\setminus i}) = \frac{p(x)}{p_{\setminus i}(x_{\setminus i})}
\tag{73}\]</span></span></p>
<p>Let us consider a sequence of <span class="math inline">\(N\)</span> Markov chains <span class="math inline">\(P_i\)</span> where each chain only updates <span class="math inline">\(x_i\)</span> and does not change <span class="math inline">\(x_{\setminus i}\)</span>:</p>
<p><span id="eq-chain-group"><span class="math display">\[
Q_i(y, x) = q_i(y_i, x_i; x_{\setminus i})\, \delta(y_{\setminus i} - x_{\setminus i})  
\tag{74}\]</span></span></p>
<p>where we introduced a product of delta distributions:</p>
<p><span class="math display">\[
\delta(x_{\setminus i}) := \prod_{j\not= i} \delta(x_j)
\]</span></p>
<p>and <span class="math inline">\(q_i(y_i, x_i; x_{\setminus i})\)</span> is a Markov kernel on <span class="math inline">\(\mathcal X_i \times \mathcal X_i\)</span> with <span class="math inline">\(x_{\setminus i}\)</span> being treated like a set of parameters.</p>
<p>The Metropolis map of <span class="math inline">\(Q_i(y, x)\)</span> is</p>
<p><span class="math display">\[\begin{align}\label{eq-coordinatewise-map}
\begin{split}
M[Q_i](y, x)
&amp;= \min\left\{Q_i(y, x), Q_i(x, y) \frac{p(y)}{p(x)} \right\} \\
&amp;= \delta(y_{\setminus i}-x_{\setminus i})\, \min\left\{q_i(y_i, x_i; x_{\setminus i}), q_i(x_i, y_i; x_{\setminus i}) \frac{p_i(y_i|y_{\setminus i})\,p_{\setminus i}(y_{\setminus i})}{p_i(x_i | x_{\setminus i}) p_{\setminus i}(x_{\setminus i})} \right\} \\
&amp;= \delta(y_{\setminus i}-x_{\setminus i})\, \min\left\{q_i(y_i, x_i; x_{\setminus i}), q_i(x_i, y_i; x_{\setminus i}) \frac{p_i(y_i|x_{\setminus i})}{p_i(x_i | x_{\setminus i})} \right\}
\end{split}
\end{align}\]</span></p>
<p>If we run the Metropolis-Hastings algorithm with <span class="math inline">\(Q_i\)</span>, we simulate a Markov chain only on the conditional distribution of the <span class="math inline">\(i\)</span>-th variable (or group of variables). This involves a Markov kernel <span class="math inline">\(q_i\)</span> on the corresponding subspace <span class="math inline">\(\mathcal X_i\)</span> that could, in principle, depend on all of the current variables.</p>
<p>This produces a Markov chain with the correct stationary distribution, but since <span class="math inline">\(Q_i\)</span> changes only the <span class="math inline">\(i\)</span>-th variable, the resulting Markov chain is not ergodic. The trick is to update each parameter group successively using <span class="math inline">\(Q_i\)</span> in each subspace <span class="math inline">\(\mathcal X_i\)</span>, and thereby produce a sequence of Metropolis maps, <span class="math inline">\(M[Q_i]\)</span>, that share a common target distribution. Simulation of <span class="math inline">\(M[Q_i]\)</span> one after the other generates a simulation of the product chain, in a fashion analogous to equation (<span class="math inline">\(\ref{eq-markov-sequence}\)</span>). This scheme is sometimes called <em>Metropolis-within-Gibbs</em>.</p>
<p>Let’s apply the coordinate-wise sampling scheme to the banana-shaped distribution using uniform proposals in each direction:</p>
<div class="cell" data-execution_count="51">
<div class="sourceCode cell-code" id="cb64"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> Banana()</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>Q <span class="op">=</span> []</span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>):</span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>    Q_i <span class="op">=</span> <span class="kw">lambda</span> x, i<span class="op">=</span>i, eps<span class="op">=</span><span class="fl">2.</span>: <span class="op">\</span></span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>    x <span class="op">+</span> eps <span class="op">*</span> np.random.uniform(<span class="op">-</span><span class="fl">1.</span>,<span class="fl">1.</span>,<span class="dv">2</span>) <span class="op">*</span> np.eye(<span class="dv">2</span>)[i]</span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a>    Q.append(Q_i)</span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.zeros(<span class="dv">2</span>)</span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a>p_x <span class="op">=</span> p(x)</span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true" tabindex="-1"></a>samples <span class="op">=</span> [x]</span>
<span id="cb64-12"><a href="#cb64-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-13"><a href="#cb64-13" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="bu">len</span>(samples) <span class="op">&lt;</span> <span class="fl">1e5</span>:</span>
<span id="cb64-14"><a href="#cb64-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-15"><a href="#cb64-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> Q_i <span class="kw">in</span> Q:</span>
<span id="cb64-16"><a href="#cb64-16" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> Q_i(x)</span>
<span id="cb64-17"><a href="#cb64-17" aria-hidden="true" tabindex="-1"></a>        p_y <span class="op">=</span> p(y)</span>
<span id="cb64-18"><a href="#cb64-18" aria-hidden="true" tabindex="-1"></a>        accept <span class="op">=</span> np.log(np.random.uniform()) <span class="op">&lt;</span> p_y <span class="op">-</span> p_x</span>
<span id="cb64-19"><a href="#cb64-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> accept:</span>
<span id="cb64-20"><a href="#cb64-20" aria-hidden="true" tabindex="-1"></a>            x, p_x <span class="op">=</span> y, p_y</span>
<span id="cb64-21"><a href="#cb64-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-22"><a href="#cb64-22" aria-hidden="true" tabindex="-1"></a>    samples.append(x)</span>
<span id="cb64-23"><a href="#cb64-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-24"><a href="#cb64-24" aria-hidden="true" tabindex="-1"></a>samples <span class="op">=</span> np.array(samples)</span>
<span id="cb64-25"><a href="#cb64-25" aria-hidden="true" tabindex="-1"></a>samples <span class="op">=</span> samples[<span class="bu">int</span>(<span class="fl">0.2</span><span class="op">*</span><span class="bu">len</span>(samples)):]</span>
<span id="cb64-26"><a href="#cb64-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-27"><a href="#cb64-27" aria-hidden="true" tabindex="-1"></a><span class="co"># plot results</span></span>
<span id="cb64-28"><a href="#cb64-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-29"><a href="#cb64-29" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="op">-</span><span class="fl">3.</span>, <span class="fl">3.</span>, <span class="dv">200</span>)</span>
<span id="cb64-30"><a href="#cb64-30" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> np.linspace(<span class="op">-</span><span class="fl">8.</span>, <span class="fl">1.</span>, <span class="bu">len</span>(x))</span>
<span id="cb64-31"><a href="#cb64-31" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> np.reshape(np.meshgrid(x, y), (<span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span>)).T</span>
<span id="cb64-32"><a href="#cb64-32" aria-hidden="true" tabindex="-1"></a>pdf <span class="op">=</span> p(grid).reshape(<span class="bu">len</span>(x), <span class="bu">len</span>(y))</span>
<span id="cb64-33"><a href="#cb64-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-34"><a href="#cb64-34" aria-hidden="true" tabindex="-1"></a>pdf_x <span class="op">=</span> compute_marginal(pdf, axis<span class="op">=</span><span class="dv">0</span>, vals<span class="op">=</span>x)</span>
<span id="cb64-35"><a href="#cb64-35" aria-hidden="true" tabindex="-1"></a>pdf_y <span class="op">=</span> compute_marginal(pdf, axis<span class="op">=</span><span class="dv">1</span>, vals<span class="op">=</span>y)</span>
<span id="cb64-36"><a href="#cb64-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-37"><a href="#cb64-37" aria-hidden="true" tabindex="-1"></a>kw_hist <span class="op">=</span> <span class="bu">dict</span>(bins<span class="op">=</span><span class="dv">50</span>, color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.2</span>, density<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb64-38"><a href="#cb64-38" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">4</span>))</span>
<span id="cb64-39"><a href="#cb64-39" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb64-40"><a href="#cb64-40" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].contour(x, y, np.exp(pdf))</span>
<span id="cb64-41"><a href="#cb64-41" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].scatter(<span class="op">*</span>samples.T, color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.2</span>, s<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb64-42"><a href="#cb64-42" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_xlabel(<span class="vs">r'$x_1$'</span>)</span>
<span id="cb64-43"><a href="#cb64-43" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_ylabel(<span class="vs">r'$x_2$'</span>)</span>
<span id="cb64-44"><a href="#cb64-44" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb64-45"><a href="#cb64-45" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].hist(samples[:,<span class="dv">0</span>], <span class="op">**</span>kw_hist)</span>
<span id="cb64-46"><a href="#cb64-46" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].plot(x, np.exp(pdf_x), color<span class="op">=</span><span class="st">'r'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, lw<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb64-47"><a href="#cb64-47" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlabel(<span class="vs">r'$x_1$'</span>)</span>
<span id="cb64-48"><a href="#cb64-48" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_ylabel(<span class="vs">r'$p(x_1)$'</span>)</span>
<span id="cb64-49"><a href="#cb64-49" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb64-50"><a href="#cb64-50" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].hist(samples[:,<span class="dv">1</span>], <span class="op">**</span>kw_hist)                       </span>
<span id="cb64-51"><a href="#cb64-51" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].plot(y, np.exp(pdf_y), color<span class="op">=</span><span class="st">'r'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, lw<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb64-52"><a href="#cb64-52" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].set_xlabel(<span class="vs">r'$x_2$'</span>)</span>
<span id="cb64-53"><a href="#cb64-53" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].set_ylabel(<span class="vs">r'$p(x_2)$'</span>)</span>
<span id="cb64-54"><a href="#cb64-54" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb64-55"><a href="#cb64-55" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-52-output-1.png" width="1114" height="346"></p>
</div>
</div>
</section>
</section>
<section id="gibbs-sampling" class="level2">
<h2 class="anchored" data-anchor-id="gibbs-sampling">Gibbs sampling</h2>
<p><a href="https://en.wikipedia.org/wiki/Gibbs_sampling"><strong>Gibbs sampling</strong></a> is a simple and powerful MCMC method that can be interpreted as a special variant of the component-wise MH algorithm outlined above. Gibbs sampling assumes that we can sample directly from the conditional distributions <span class="math inline">\(p_i(x_i | x_{\setminus i})\)</span>, and uses these as component-wise Markov chains:</p>
<p><span class="math display">\[
q_i(y_i, x_i; x_{\setminus i}) = p_i(y_i | x_{\setminus i})
\]</span></p>
<p>The acceptance ratio in the Metropolis map <span class="math inline">\(M[Q_i]\)</span> (Eq. <span class="math inline">\(\ref{eq-coordinatewise-map}\)</span>) simplifies to</p>
<p><span class="math display">\[
\frac{q_i(x_i, y_i; x_{\setminus i})}{q_i(y_i, x_i; x_{\setminus i})} \frac{p_i(y_i|x_{\setminus i})}{p_i(x_i|x_{\setminus i})} =
\frac{p_i(x_i | x_{\setminus i})}{p_i(y_i | x_{\setminus i})} \frac{p_i(y_i|x_{\setminus i})}{p_i(x_i|x_{\setminus i})} = 1
\]</span></p>
<p>That is, all proposals are accepted - Gibbs sampling is rejection-free.</p>
<section id="algorithm-gibbs-sampling" class="level3">
<h3 class="anchored" data-anchor-id="algorithm-gibbs-sampling">Algorithm: Gibbs sampling</h3>
<p>Let <span class="math inline">\(p(x_1, \ldots, x_N)\)</span> be the joint distribution of <span class="math inline">\(N\)</span> random variables or groups of random variables <span class="math inline">\(x_i\in\mathcal X_i\)</span> with conditional distributions <span class="math inline">\(p_i(x_i | x_{\setminus i})\)</span>, then the following iterative algorithm simulates a Markov chain whose stationary distribution is <span class="math inline">\(p(x_1, \ldots, x_N)\)</span>:</p>
<p><span class="math display">\[\begin{align}\label{eq-gibbs-sampling}
\begin{split}
  x^{(s+1)}_1 &amp;\sim p_1\bigl(\,\cdot\, | x^{(s)}_{\setminus 1}\bigr) \\
  x^{(s+1)}_2 &amp;\sim p_2\bigl(\,\cdot\, | {x}^{(s,s+1)}_{\setminus 2}\bigr) \\
  &amp; \vdots   \\
  x^{(s+1)}_N &amp;\sim p_N\bigl(\,\cdot\, | {x}^{(s,s+1)}_{\setminus N}\bigr) \\
\end{split}
\end{align}\]</span></p>
<p>where <span class="math inline">\({x}^{(s+1)}_i\)</span> are the components of the next sample and</p>
<p><span class="math display">\[{x}^{(s,s+1)}_{\setminus i} = \begin{pmatrix}{x}^{(s+1)}_1, \ldots, {x}^{(s+1)}_{i-1}, x^{(s)}_{i+1}, \ldots, x^{(s)}_{N}\end{pmatrix}\]</span></p>
<p>so <span class="math inline">\({x}^{(s,s+1)}_{\setminus N} = x^{(s+1)}_{\setminus N}\)</span>.</p>
<section id="collapsed-gibbs-sampler" class="level4">
<h4 class="anchored" data-anchor-id="collapsed-gibbs-sampler">Collapsed Gibbs Sampler</h4>
<p>A variant of the Gibbs sampler (Eq. <span class="math inline">\(\ref{eq-gibbs-sampling}\)</span>) is the <a href="https://en.wikipedia.org/wiki/Gibbs_sampling#Collapsed_Gibbs_sampler"><em>collapsed Gibbs sampler</em></a> where some of the conditional distributions <span class="math inline">\(p_i(x_i | x_{\setminus i})\)</span> are replaced by a marginal distribution, e.g.&nbsp;<span class="math inline">\(p_i(x_i) = \int p(x_1, \ldots, x_N) dx_{\setminus i}\)</span>. This scheme is equally valid and rejection-free. See also the original paper by <a href="https://www.tandfonline.com/doi/abs/10.1080/01621459.1994.10476829">Jun S. Liu</a>.</p>
</section>
<section id="example-sampling-a-bivariate-gaussian-model" class="level4">
<h4 class="anchored" data-anchor-id="example-sampling-a-bivariate-gaussian-model">Example: Sampling a bivariate Gaussian model</h4>
<p>In the following, let’s use Gibbs sampling to draw from a two-dimensional Gaussian distribution with general covariance matrix:</p>
<p><span class="math display">\[
p(x_1, x_2) = \frac{1}{2\pi\sigma_1\sigma_2\sqrt{1-\rho^2}} \exp\left\{-\frac{1}{2} \begin{pmatrix} x_1 - \mu_1 \\ x_2 - \mu_2\end{pmatrix}^T \begin{pmatrix} \sigma_1^2 &amp; \sigma_1\sigma_2\rho \\ \sigma_1\sigma_2\rho &amp; \sigma_2^2 \end{pmatrix}^{-1} \begin{pmatrix} x_1 - \mu_1 \\ x_2 -\mu_2 \end{pmatrix}  \right\}
\]</span></p>
<p>The conditional distributions are given <a href="https://en.wikipedia.org/wiki/Multivariate_normal_distribution#Bivariate_case_2">by</a>:</p>
<p><span class="math display">\[\begin{align*}
p(x_1 | x_2) &amp;= \frac{1}{\sqrt{2\pi\sigma_1^2(1-\rho^2)}} \exp\left\{-\frac{1}{2\sigma_1^2(1-\rho^2)} \bigl(x_1 - \mu_1 - \frac{\sigma_1}{\sigma_2}\rho (x_2 - \mu_2) \bigr)^2\right\} \\
p(x_2 | x_1) &amp;= \frac{1}{\sqrt{2\pi\sigma_2^2(1-\rho^2)}} \exp\left\{-\frac{1}{2\sigma_2^2(1-\rho^2)} \bigl(x_2 - \mu_2 - \frac{\sigma_2}{\sigma_1}\rho (x_1 - \mu_1) \bigr)^2\right\}
\end{align*}\]</span></p>
<p>and the marginal distributions are <span class="math inline">\(p_i(x_i) = \mathcal N(\mu_i, \sigma_i^2)\)</span>. We use the standard Gibbs sampler and the collapsed Gibbs samplers to generate samples from the joint bivariate Gaussian:</p>
<div class="cell" data-execution_count="52">
<div class="sourceCode cell-code" id="cb65"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Gaussian:</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Bivariate Gaussian</span></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, mu <span class="op">=</span> np.zeros(<span class="dv">2</span>), sigma1<span class="op">=</span><span class="fl">1.</span>, sigma2<span class="op">=</span><span class="fl">3.</span>, rho<span class="op">=</span><span class="fl">0.95</span>):</span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.mu <span class="op">=</span> mu</span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.sigma <span class="op">=</span> np.array([sigma1, sigma2])</span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.rho <span class="op">=</span> <span class="bu">float</span>(rho)</span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a>    <span class="at">@property</span></span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> sigma1(<span class="va">self</span>):</span>
<span id="cb65-12"><a href="#cb65-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.sigma[<span class="dv">0</span>]</span>
<span id="cb65-13"><a href="#cb65-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-14"><a href="#cb65-14" aria-hidden="true" tabindex="-1"></a>    <span class="at">@property</span></span>
<span id="cb65-15"><a href="#cb65-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> sigma2(<span class="va">self</span>):</span>
<span id="cb65-16"><a href="#cb65-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.sigma[<span class="dv">1</span>]</span>
<span id="cb65-17"><a href="#cb65-17" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb65-18"><a href="#cb65-18" aria-hidden="true" tabindex="-1"></a>    <span class="at">@property</span></span>
<span id="cb65-19"><a href="#cb65-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> Sigma(<span class="va">self</span>):</span>
<span id="cb65-20"><a href="#cb65-20" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb65-21"><a href="#cb65-21" aria-hidden="true" tabindex="-1"></a><span class="co">        Covariance matrix</span></span>
<span id="cb65-22"><a href="#cb65-22" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb65-23"><a href="#cb65-23" aria-hidden="true" tabindex="-1"></a>        Sigma <span class="op">=</span> np.diag([<span class="va">self</span>.sigma1, <span class="va">self</span>.sigma2])</span>
<span id="cb65-24"><a href="#cb65-24" aria-hidden="true" tabindex="-1"></a>        Sigma <span class="op">=</span> Sigma <span class="op">@</span> np.array([[<span class="dv">1</span>, <span class="va">self</span>.rho], [<span class="va">self</span>.rho, <span class="dv">1</span>]]) <span class="op">@</span> Sigma</span>
<span id="cb65-25"><a href="#cb65-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> Sigma</span>
<span id="cb65-26"><a href="#cb65-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-27"><a href="#cb65-27" aria-hidden="true" tabindex="-1"></a>    <span class="at">@property</span></span>
<span id="cb65-28"><a href="#cb65-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> Lambda(<span class="va">self</span>):</span>
<span id="cb65-29"><a href="#cb65-29" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb65-30"><a href="#cb65-30" aria-hidden="true" tabindex="-1"></a><span class="co">        Precision matrix</span></span>
<span id="cb65-31"><a href="#cb65-31" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb65-32"><a href="#cb65-32" aria-hidden="true" tabindex="-1"></a>        precision <span class="op">=</span> np.diag([<span class="dv">1</span><span class="op">/</span><span class="va">self</span>.sigma1, <span class="dv">1</span><span class="op">/</span><span class="va">self</span>.sigma2]) <span class="op">/</span> np.sqrt(<span class="dv">1</span> <span class="op">-</span> <span class="va">self</span>.rho<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb65-33"><a href="#cb65-33" aria-hidden="true" tabindex="-1"></a>        precision <span class="op">=</span> precision <span class="op">@</span> np.array([[<span class="dv">1</span>, <span class="op">-</span><span class="va">self</span>.rho], [<span class="op">-</span><span class="va">self</span>.rho, <span class="dv">1</span>]])  <span class="op">@</span> precision</span>
<span id="cb65-34"><a href="#cb65-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> precision</span>
<span id="cb65-35"><a href="#cb65-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-36"><a href="#cb65-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> log_prob(<span class="va">self</span>, x):</span>
<span id="cb65-37"><a href="#cb65-37" aria-hidden="true" tabindex="-1"></a>        logp <span class="op">=</span> <span class="op">-</span><span class="fl">.5</span> <span class="op">*</span> np.<span class="bu">sum</span>(x <span class="op">*</span> x.dot(<span class="va">self</span>.Lambda), <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb65-38"><a href="#cb65-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> logp</span>
<span id="cb65-39"><a href="#cb65-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-40"><a href="#cb65-40" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> sample_conditional(<span class="va">self</span>, x, index<span class="op">=</span><span class="dv">0</span>):</span>
<span id="cb65-41"><a href="#cb65-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-42"><a href="#cb65-42" aria-hidden="true" tabindex="-1"></a>        ratio <span class="op">=</span> <span class="va">self</span>.rho <span class="op">*</span> <span class="va">self</span>.sigma[index] <span class="op">/</span> <span class="va">self</span>.sigma[<span class="dv">1</span><span class="op">-</span>index]</span>
<span id="cb65-43"><a href="#cb65-43" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb65-44"><a href="#cb65-44" aria-hidden="true" tabindex="-1"></a>        mu <span class="op">=</span> <span class="va">self</span>.mu[index] <span class="op">+</span> ratio <span class="op">*</span> (x[<span class="dv">1</span><span class="op">-</span>index] <span class="op">-</span> <span class="va">self</span>.mu[<span class="dv">1</span><span class="op">-</span>index])</span>
<span id="cb65-45"><a href="#cb65-45" aria-hidden="true" tabindex="-1"></a>        sigma <span class="op">=</span> np.sqrt(<span class="dv">1</span><span class="op">-</span><span class="va">self</span>.rho<span class="op">**</span><span class="dv">2</span>) <span class="op">*</span> <span class="va">self</span>.sigma[index]</span>
<span id="cb65-46"><a href="#cb65-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-47"><a href="#cb65-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.random.standard_normal() <span class="op">*</span> sigma <span class="op">+</span> mu</span>
<span id="cb65-48"><a href="#cb65-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-49"><a href="#cb65-49" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> sample_marginal(<span class="va">self</span>, index<span class="op">=</span><span class="dv">0</span>):</span>
<span id="cb65-50"><a href="#cb65-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-51"><a href="#cb65-51" aria-hidden="true" tabindex="-1"></a>        mu <span class="op">=</span> <span class="va">self</span>.mu[index]</span>
<span id="cb65-52"><a href="#cb65-52" aria-hidden="true" tabindex="-1"></a>        sigma <span class="op">=</span> <span class="va">self</span>.sigma[index]</span>
<span id="cb65-53"><a href="#cb65-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-54"><a href="#cb65-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.random.standard_normal() <span class="op">*</span> sigma <span class="op">+</span> mu</span>
<span id="cb65-55"><a href="#cb65-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-56"><a href="#cb65-56" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb65-57"><a href="#cb65-57" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_marginal(prob, axis<span class="op">=</span><span class="dv">0</span>, x<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb65-58"><a href="#cb65-58" aria-hidden="true" tabindex="-1"></a>    marginal <span class="op">=</span> logsumexp(prob, axis<span class="op">=</span>axis)</span>
<span id="cb65-59"><a href="#cb65-59" aria-hidden="true" tabindex="-1"></a>    marginal <span class="op">-=</span> logsumexp(marginal)</span>
<span id="cb65-60"><a href="#cb65-60" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> x <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb65-61"><a href="#cb65-61" aria-hidden="true" tabindex="-1"></a>        marginal <span class="op">-=</span> np.log(x[<span class="dv">1</span>]<span class="op">-</span>x[<span class="dv">0</span>])</span>
<span id="cb65-62"><a href="#cb65-62" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> marginal</span>
<span id="cb65-63"><a href="#cb65-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-64"><a href="#cb65-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-65"><a href="#cb65-65" aria-hidden="true" tabindex="-1"></a>pdf <span class="op">=</span> Gaussian(sigma1<span class="op">=</span><span class="fl">1.</span>, sigma2<span class="op">=</span><span class="fl">5.</span>, rho<span class="op">=</span><span class="fl">0.95</span>)</span>
<span id="cb65-66"><a href="#cb65-66" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="op">-</span><span class="fl">1.</span>, <span class="fl">1.</span>, <span class="dv">100</span>) <span class="op">*</span> <span class="dv">3</span> <span class="op">*</span> pdf.sigma1</span>
<span id="cb65-67"><a href="#cb65-67" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> np.linspace(<span class="op">-</span><span class="fl">1.</span>, <span class="fl">1.</span>, <span class="dv">100</span>) <span class="op">*</span> <span class="dv">3</span> <span class="op">*</span> pdf.sigma2</span>
<span id="cb65-68"><a href="#cb65-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-69"><a href="#cb65-69" aria-hidden="true" tabindex="-1"></a>X, Y <span class="op">=</span> np.meshgrid(x, y)</span>
<span id="cb65-70"><a href="#cb65-70" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> np.transpose([X.flatten(), Y.flatten()])</span>
<span id="cb65-71"><a href="#cb65-71" aria-hidden="true" tabindex="-1"></a>prob <span class="op">=</span> pdf.log_prob(grid).reshape(<span class="bu">len</span>(x), <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb65-72"><a href="#cb65-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-73"><a href="#cb65-73" aria-hidden="true" tabindex="-1"></a>samples <span class="op">=</span> [(<span class="fl">20.</span>, <span class="fl">90.</span>)]</span>
<span id="cb65-74"><a href="#cb65-74" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="bu">len</span>(samples) <span class="op">&lt;</span> <span class="fl">1e4</span>:</span>
<span id="cb65-75"><a href="#cb65-75" aria-hidden="true" tabindex="-1"></a>    newstate <span class="op">=</span> <span class="bu">list</span>(samples[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb65-76"><a href="#cb65-76" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> index <span class="kw">in</span> [<span class="dv">0</span>, <span class="dv">1</span>]:</span>
<span id="cb65-77"><a href="#cb65-77" aria-hidden="true" tabindex="-1"></a>        newstate[index] <span class="op">=</span> pdf.sample_conditional(newstate, index)</span>
<span id="cb65-78"><a href="#cb65-78" aria-hidden="true" tabindex="-1"></a>    samples.append(<span class="bu">tuple</span>(newstate))</span>
<span id="cb65-79"><a href="#cb65-79" aria-hidden="true" tabindex="-1"></a>samples <span class="op">=</span> np.array(samples)</span>
<span id="cb65-80"><a href="#cb65-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-81"><a href="#cb65-81" aria-hidden="true" tabindex="-1"></a>logp <span class="op">=</span> pdf.log_prob(samples)</span>
<span id="cb65-82"><a href="#cb65-82" aria-hidden="true" tabindex="-1"></a>burnin <span class="op">=</span> <span class="bu">int</span>(<span class="fl">0.1</span><span class="op">*</span><span class="bu">len</span>(samples))</span>
<span id="cb65-83"><a href="#cb65-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-84"><a href="#cb65-84" aria-hidden="true" tabindex="-1"></a>kw_hist <span class="op">=</span> <span class="bu">dict</span>(bins<span class="op">=</span><span class="dv">30</span>, color<span class="op">=</span><span class="st">'k'</span>, density<span class="op">=</span><span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.2</span>)</span>
<span id="cb65-85"><a href="#cb65-85" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">10</span>))</span>
<span id="cb65-86"><a href="#cb65-86" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> <span class="bu">list</span>(ax.flat)</span>
<span id="cb65-87"><a href="#cb65-87" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb65-88"><a href="#cb65-88" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].scatter(<span class="op">*</span>samples.T, color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb65-89"><a href="#cb65-89" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].contour(x, y, np.exp(prob))</span>
<span id="cb65-90"><a href="#cb65-90" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_xlabel(<span class="vs">r'$x_1$'</span>)</span>
<span id="cb65-91"><a href="#cb65-91" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_ylabel(<span class="vs">r'$x_2$'</span>)</span>
<span id="cb65-92"><a href="#cb65-92" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb65-93"><a href="#cb65-93" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].plot(logp[:<span class="dv">50</span>], color<span class="op">=</span><span class="st">'k'</span>, lw<span class="op">=</span><span class="dv">3</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb65-94"><a href="#cb65-94" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlabel(<span class="vs">r'iteration $s$'</span>)</span>
<span id="cb65-95"><a href="#cb65-95" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_ylabel(<span class="vs">r'$\log p(x_1^{(s)}, x_2^{(s)})$'</span>)</span>
<span id="cb65-96"><a href="#cb65-96" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb65-97"><a href="#cb65-97" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].hist(samples[burnin:,<span class="dv">0</span>], <span class="op">**</span>kw_hist)</span>
<span id="cb65-98"><a href="#cb65-98" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].plot(x, np.exp(compute_marginal(prob, <span class="dv">1</span>, x)), color<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb65-99"><a href="#cb65-99" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].set_xlabel(<span class="vs">r'$x_1$'</span>)</span>
<span id="cb65-100"><a href="#cb65-100" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].set_ylabel(<span class="vs">r'$p_1(x_1)$'</span>)</span>
<span id="cb65-101"><a href="#cb65-101" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb65-102"><a href="#cb65-102" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">3</span>].hist(samples[burnin:,<span class="dv">1</span>], <span class="op">**</span>kw_hist)</span>
<span id="cb65-103"><a href="#cb65-103" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">3</span>].plot(y, np.exp(compute_marginal(prob, <span class="dv">0</span>, y)), color<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb65-104"><a href="#cb65-104" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">3</span>].set_xlabel(<span class="vs">r'$x_2$'</span>)</span>
<span id="cb65-105"><a href="#cb65-105" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">3</span>].set_ylabel(<span class="vs">r'$p_2(x_2)$'</span>)</span>
<span id="cb65-106"><a href="#cb65-106" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb65-107"><a href="#cb65-107" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-53-output-1.png" width="922" height="922"></p>
</div>
</div>
<p>This collapsed Gibbs sampler uses the marginal distribution to sample <span class="math inline">\(x_1\)</span> and the conditional distribution to sample <span class="math inline">\(x_2\)</span>:</p>
<div class="cell" data-execution_count="53">
<div class="sourceCode cell-code" id="cb66"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="co"># collapsed Gibbs 1</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>samples <span class="op">=</span> [(<span class="fl">20.</span>, <span class="fl">90.</span>)]</span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="bu">len</span>(samples) <span class="op">&lt;</span> <span class="fl">1e4</span>:</span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a>    newstate <span class="op">=</span> <span class="bu">list</span>(samples[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a>    newstate[<span class="dv">0</span>] <span class="op">=</span> pdf.sample_marginal(<span class="dv">0</span>)</span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a>    newstate[<span class="dv">1</span>] <span class="op">=</span> pdf.sample_conditional(newstate, <span class="dv">1</span>)</span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a>    samples.append(<span class="bu">tuple</span>(newstate))</span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a>samples <span class="op">=</span> np.array(samples)</span>
<span id="cb66-10"><a href="#cb66-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-11"><a href="#cb66-11" aria-hidden="true" tabindex="-1"></a>logp <span class="op">=</span> pdf.log_prob(samples)</span>
<span id="cb66-12"><a href="#cb66-12" aria-hidden="true" tabindex="-1"></a>burnin <span class="op">=</span> <span class="bu">int</span>(<span class="fl">0.1</span><span class="op">*</span><span class="bu">len</span>(samples))</span>
<span id="cb66-13"><a href="#cb66-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-14"><a href="#cb66-14" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">10</span>))</span>
<span id="cb66-15"><a href="#cb66-15" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> <span class="bu">list</span>(ax.flat)</span>
<span id="cb66-16"><a href="#cb66-16" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb66-17"><a href="#cb66-17" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].scatter(<span class="op">*</span>samples.T, color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb66-18"><a href="#cb66-18" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].contour(x, y, np.exp(prob))</span>
<span id="cb66-19"><a href="#cb66-19" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_xlabel(<span class="vs">r'$x_1$'</span>)</span>
<span id="cb66-20"><a href="#cb66-20" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_ylabel(<span class="vs">r'$x_2$'</span>)</span>
<span id="cb66-21"><a href="#cb66-21" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb66-22"><a href="#cb66-22" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].plot(logp[:<span class="dv">50</span>], color<span class="op">=</span><span class="st">'k'</span>, lw<span class="op">=</span><span class="dv">3</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb66-23"><a href="#cb66-23" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlabel(<span class="vs">r'iteration $s$'</span>)</span>
<span id="cb66-24"><a href="#cb66-24" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_ylabel(<span class="vs">r'$\log p(x_1^{(s)}, x_2^{(s)})$'</span>)</span>
<span id="cb66-25"><a href="#cb66-25" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb66-26"><a href="#cb66-26" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].hist(samples[burnin:,<span class="dv">0</span>], <span class="op">**</span>kw_hist)</span>
<span id="cb66-27"><a href="#cb66-27" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].plot(x, np.exp(compute_marginal(prob, <span class="dv">1</span>, x)), color<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb66-28"><a href="#cb66-28" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].set_xlabel(<span class="vs">r'$x_1$'</span>)</span>
<span id="cb66-29"><a href="#cb66-29" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].set_ylabel(<span class="vs">r'$p_1(x_1)$'</span>)</span>
<span id="cb66-30"><a href="#cb66-30" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb66-31"><a href="#cb66-31" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">3</span>].hist(samples[burnin:,<span class="dv">1</span>], <span class="op">**</span>kw_hist)</span>
<span id="cb66-32"><a href="#cb66-32" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">3</span>].plot(y, np.exp(compute_marginal(prob, <span class="dv">0</span>, y)), color<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb66-33"><a href="#cb66-33" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">3</span>].set_xlabel(<span class="vs">r'$x_2$'</span>)</span>
<span id="cb66-34"><a href="#cb66-34" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">3</span>].set_ylabel(<span class="vs">r'$p_2(x_2)$'</span>)</span>
<span id="cb66-35"><a href="#cb66-35" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb66-36"><a href="#cb66-36" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-54-output-1.png" width="922" height="922"></p>
</div>
</div>
<p>This collapsed Gibbs sampler uses the marginal distribution to sample <span class="math inline">\(x_2\)</span> and the conditional distribution to sample <span class="math inline">\(x_1\)</span>:</p>
<div class="cell" data-execution_count="54">
<div class="sourceCode cell-code" id="cb67"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="co"># collapsed Gibbs 2</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>samples <span class="op">=</span> [(<span class="fl">20.</span>, <span class="fl">90.</span>)]</span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="bu">len</span>(samples) <span class="op">&lt;</span> <span class="fl">1e4</span>:</span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a>    newstate <span class="op">=</span> <span class="bu">list</span>(samples[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a>    newstate[<span class="dv">1</span>] <span class="op">=</span> pdf.sample_marginal(<span class="dv">1</span>)</span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a>    newstate[<span class="dv">0</span>] <span class="op">=</span> pdf.sample_conditional(newstate, <span class="dv">0</span>)</span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a>    samples.append(<span class="bu">tuple</span>(newstate))</span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a>samples <span class="op">=</span> np.array(samples)</span>
<span id="cb67-10"><a href="#cb67-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-11"><a href="#cb67-11" aria-hidden="true" tabindex="-1"></a>logp <span class="op">=</span> pdf.log_prob(samples)</span>
<span id="cb67-12"><a href="#cb67-12" aria-hidden="true" tabindex="-1"></a>burnin <span class="op">=</span> <span class="bu">int</span>(<span class="fl">0.1</span><span class="op">*</span><span class="bu">len</span>(samples))</span>
<span id="cb67-13"><a href="#cb67-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-14"><a href="#cb67-14" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">10</span>))</span>
<span id="cb67-15"><a href="#cb67-15" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> <span class="bu">list</span>(ax.flat)</span>
<span id="cb67-16"><a href="#cb67-16" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb67-17"><a href="#cb67-17" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].scatter(<span class="op">*</span>samples.T, color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb67-18"><a href="#cb67-18" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].contour(x, y, np.exp(prob))</span>
<span id="cb67-19"><a href="#cb67-19" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_xlabel(<span class="vs">r'$x_1$'</span>)</span>
<span id="cb67-20"><a href="#cb67-20" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_ylabel(<span class="vs">r'$x_2$'</span>)</span>
<span id="cb67-21"><a href="#cb67-21" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb67-22"><a href="#cb67-22" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].plot(logp[:<span class="dv">50</span>], color<span class="op">=</span><span class="st">'k'</span>, lw<span class="op">=</span><span class="dv">3</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb67-23"><a href="#cb67-23" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlabel(<span class="vs">r'iteration $s$'</span>)</span>
<span id="cb67-24"><a href="#cb67-24" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_ylabel(<span class="vs">r'$\log p(x_1^{(s)}, x_2^{(s)})$'</span>)</span>
<span id="cb67-25"><a href="#cb67-25" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb67-26"><a href="#cb67-26" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].hist(samples[burnin:,<span class="dv">0</span>], <span class="op">**</span>kw_hist)</span>
<span id="cb67-27"><a href="#cb67-27" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].plot(x, np.exp(compute_marginal(prob, <span class="dv">1</span>, x)), color<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb67-28"><a href="#cb67-28" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].set_xlabel(<span class="vs">r'$x_1$'</span>)</span>
<span id="cb67-29"><a href="#cb67-29" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].set_ylabel(<span class="vs">r'$p_1(x_1)$'</span>)</span>
<span id="cb67-30"><a href="#cb67-30" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb67-31"><a href="#cb67-31" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">3</span>].hist(samples[burnin:,<span class="dv">1</span>], <span class="op">**</span>kw_hist)</span>
<span id="cb67-32"><a href="#cb67-32" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">3</span>].plot(y, np.exp(compute_marginal(prob, <span class="dv">0</span>, y)), color<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb67-33"><a href="#cb67-33" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">3</span>].set_xlabel(<span class="vs">r'$x_2$'</span>)</span>
<span id="cb67-34"><a href="#cb67-34" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">3</span>].set_ylabel(<span class="vs">r'$p_2(x_2)$'</span>)</span>
<span id="cb67-35"><a href="#cb67-35" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb67-36"><a href="#cb67-36" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-55-output-1.png" width="922" height="922"></p>
</div>
</div>
</section>
</section>
</section>
<section id="auxiliary-variables" class="level2">
<h2 class="anchored" data-anchor-id="auxiliary-variables">Auxiliary Variables</h2>
<p>The idea of sampling methods that use <em>auxiliary variables</em> is to <em>introduce</em> new variables rather than marginalizing them out. The target distribution is <span class="math inline">\(p(x)\)</span> defined over sample space <span class="math inline">\(\mathcal X\)</span>. But it might be beneficial to introduce helper variables <span class="math inline">\(y\)</span> and consider <span class="math inline">\(p(x, y)\)</span> defined over the extended sample space <span class="math inline">\(\mathcal X \times{} \mathcal Y\)</span> where</p>
<p><span class="math display">\[
p(x) = \int_{\mathcal{Y}} p(x, y)\, dy
\]</span></p>
<p>If we can generate samples <span class="math inline">\(\bigl(x^{(s)}, y^{(s)}\bigr) \sim p(x, y)\)</span>, then a valid estimator for expectations of <span class="math inline">\(p(x)\)</span> is</p>
<p><span class="math display">\[
\mathbb{E}_p[f] \approx \frac{1}{S} \sum_{s=1}^S f\bigl(x^{(s)}\bigr)\, .
\]</span></p>
<p>Why is this helpful? We can use Gibbs sampling to generate samples from <span class="math inline">\(p(x, y)\)</span>:</p>
<p><span class="math display">\[\begin{align}\label{eq-gibbs-auxiliary}
\begin{split}
x^{(s+1)} &amp;\sim p\bigl(x | y^{(s)}\bigr) \\
y^{(s+1)} &amp;\sim p\bigl(y | x^{(s+1)}\bigr) \\
\end{split}
\end{align}\]</span></p>
<p>where the marginal distributions might be easier to simulate than <span class="math inline">\(p(x)\)</span>.</p>
<section id="example-student-t-distribution" class="level4">
<h4 class="anchored" data-anchor-id="example-student-t-distribution">Example: Student-t distribution</h4>
<p>The <a href="https://en.wikipedia.org/wiki/Student%27s_t-distribution">Student-t distribution</a> is defined as</p>
<p><span class="math display">\[
p(x | \nu) = \frac{1}{Z(\nu)} \left(1 + \frac{x^2}{\nu}\right)^{-\frac{\nu+1}{2}}
\]</span></p>
<p>with a normalization constant <span class="math inline">\(Z(\nu)\)</span> that depends on the degrees of freedom <span class="math inline">\(\nu &gt; 0\)</span>.</p>
<p>This integral can be written as a <a href="https://www.jstor.org/stable/2984774?seq=1#metadata_info_tab_contents">scale-mixture of normals</a>:</p>
<p><span class="math display">\[
\begin{aligned}
    f(x ; \alpha, \beta) &amp;= \int \underbrace{\sqrt{\frac{s}{2\pi}}\, e^{-\frac{s}{2} x^2 }}_{\text{Gaussian}}\,\,\, \underbrace{\frac{\beta^\alpha}{\Gamma(\alpha)} s^{\alpha -1} e^{-\beta s}}_{\text{Gamma distribution}} ds \\
    &amp;= \frac{\beta^\alpha}{\Gamma(\alpha)\,\sqrt{2\pi}} \int s^{\frac{2\alpha + 1}{2} - 1}\,\, \exp\left\{-s(\beta + x^2/2)\right\} ds \\
    &amp;= \frac{\beta^\alpha}{\Gamma(\alpha)\,\sqrt{2\pi}} \frac{\Gamma(\alpha+1/2)}{\left(\beta + x^2/2\right)^{\frac{2\alpha+1}{2}}} \\
    &amp;= \frac{1}{\sqrt{2\pi\beta}} \frac{\Gamma(\alpha+1/2)}{\Gamma(\alpha)} \left(1 + x^2/2\beta\right)^{-(\frac{2\alpha+1}{2})}
\end{aligned}
\]</span></p>
<p>So <span class="math inline">\(f(x; \alpha, \beta)\)</span> is identical to <span class="math inline">\(p(x|\nu)\)</span> for <span class="math inline">\(\alpha=\nu/2\)</span> and <span class="math inline">\(\beta=\nu/2\)</span>.</p>
<p>The joint distribution is</p>
<p><span class="math display">\[
p(x, s) = p(x | s) p(s) = \mathcal{N}(x; 0, s^{-1/2})\, \mathcal{G}(s; \nu/2, \nu/2)
\]</span></p>
<p>The conditional distributions are <span class="math inline">\(\mathcal{N}(x; 0, s^{-1/2})\)</span> and <span class="math inline">\(\mathcal{G}(s; (\nu+1)/2, (\nu+x^2)/2)\)</span>.</p>
<div class="cell" data-execution_count="55">
<div class="sourceCode cell-code" id="cb68"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="co"># sample student t with auxiliary variable</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>nu <span class="op">=</span> <span class="fl">2.</span></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>alpha <span class="op">=</span> nu <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>beta <span class="op">=</span> nu <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a>log_target <span class="op">=</span> <span class="kw">lambda</span> x : <span class="op">-</span> <span class="fl">0.5</span> <span class="op">*</span> (nu<span class="op">+</span><span class="fl">1.</span>) <span class="op">*</span> np.log(<span class="dv">1</span> <span class="op">+</span> x<span class="op">**</span><span class="dv">2</span><span class="op">/</span>nu)</span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true" tabindex="-1"></a><span class="co"># standard Gibbs sampler</span></span>
<span id="cb68-10"><a href="#cb68-10" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="fl">0.</span></span>
<span id="cb68-11"><a href="#cb68-11" aria-hidden="true" tabindex="-1"></a>samples <span class="op">=</span> []</span>
<span id="cb68-12"><a href="#cb68-12" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="bu">len</span>(samples) <span class="op">&lt;</span> <span class="fl">1e5</span>:</span>
<span id="cb68-13"><a href="#cb68-13" aria-hidden="true" tabindex="-1"></a>    s <span class="op">=</span> np.random.gamma(alpha<span class="op">+</span><span class="fl">0.5</span>, <span class="dv">1</span><span class="op">/</span>(beta <span class="op">+</span> <span class="fl">0.5</span><span class="op">*</span>x<span class="op">**</span><span class="dv">2</span>))</span>
<span id="cb68-14"><a href="#cb68-14" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> np.random.standard_normal() <span class="op">/</span> np.sqrt(s)</span>
<span id="cb68-15"><a href="#cb68-15" aria-hidden="true" tabindex="-1"></a>    samples.append(x)</span>
<span id="cb68-16"><a href="#cb68-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb68-17"><a href="#cb68-17" aria-hidden="true" tabindex="-1"></a><span class="co"># collapsed Gibbs sampler</span></span>
<span id="cb68-18"><a href="#cb68-18" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> np.random.gamma(alpha, <span class="dv">1</span><span class="op">/</span>beta, size<span class="op">=</span><span class="bu">len</span>(samples))</span>
<span id="cb68-19"><a href="#cb68-19" aria-hidden="true" tabindex="-1"></a>samples2 <span class="op">=</span> np.random.standard_normal(<span class="bu">len</span>(s)) <span class="op">/</span> np.sqrt(s)</span>
<span id="cb68-20"><a href="#cb68-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb68-21"><a href="#cb68-21" aria-hidden="true" tabindex="-1"></a>burnin <span class="op">=</span> <span class="bu">int</span>(<span class="fl">0.1</span><span class="op">*</span><span class="bu">len</span>(samples))</span>
<span id="cb68-22"><a href="#cb68-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb68-23"><a href="#cb68-23" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.linspace(<span class="op">-</span><span class="fl">1.</span>, <span class="fl">1.</span>, <span class="dv">1000</span>) <span class="op">*</span> <span class="dv">10</span></span>
<span id="cb68-24"><a href="#cb68-24" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> log_target(t)</span>
<span id="cb68-25"><a href="#cb68-25" aria-hidden="true" tabindex="-1"></a>p <span class="op">-=</span> logsumexp(p) <span class="op">+</span> np.log(t[<span class="dv">1</span>]<span class="op">-</span>t[<span class="dv">0</span>])</span>
<span id="cb68-26"><a href="#cb68-26" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> np.exp(p)</span>
<span id="cb68-27"><a href="#cb68-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-28"><a href="#cb68-28" aria-hidden="true" tabindex="-1"></a>kw <span class="op">=</span> <span class="bu">dict</span>(xlim<span class="op">=</span>(<span class="op">-</span><span class="fl">10.</span>, <span class="fl">10.</span>))</span>
<span id="cb68-29"><a href="#cb68-29" aria-hidden="true" tabindex="-1"></a>kw_hist <span class="op">=</span> <span class="bu">dict</span>(bins<span class="op">=</span><span class="dv">1000</span>, density<span class="op">=</span><span class="va">True</span>, color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.2</span>)</span>
<span id="cb68-30"><a href="#cb68-30" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">4</span>), sharey<span class="op">=</span><span class="st">'all'</span>, subplot_kw<span class="op">=</span>kw)</span>
<span id="cb68-31"><a href="#cb68-31" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].hist(samples[burnin:], <span class="op">**</span>kw_hist)</span>
<span id="cb68-32"><a href="#cb68-32" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].hist(samples2[burnin:], <span class="op">**</span>kw_hist)</span>
<span id="cb68-33"><a href="#cb68-33" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> a <span class="kw">in</span> ax:</span>
<span id="cb68-34"><a href="#cb68-34" aria-hidden="true" tabindex="-1"></a>    a.plot(t, p, color<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb68-35"><a href="#cb68-35" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-56-output-1.png" width="730" height="346"></p>
</div>
</div>
</section>
</section>
</section>
<section id="lecture-7-hamiltonian-monte-carlo-1" class="level1">
<h1>Lecture 7: Hamiltonian Monte Carlo</h1>
<p>Michael Habeck - University Hospital Jena - michael.habeck@uni-jena.de</p>
<section id="outline-6" class="level2">
<h2 class="anchored" data-anchor-id="outline-6">Outline</h2>
<ul>
<li>Recap: MCMC + Gibbs Sampling</li>
<li>More on auxiliary variable methods</li>
<li>Hamiltonian Monte Carlo</li>
</ul>
</section>
<section id="recap-3" class="level2">
<h2 class="anchored" data-anchor-id="recap-3">Recap</h2>
<ul>
<li><p><strong>Metropolis-Hastings algorithm:</strong> Take (almost) any Markov chain <span class="math inline">\(Q\)</span> (proposal chain) and map it to a new Markov chain <span class="math inline">\(M[Q]\)</span> with a desired proposal distribution <span class="math inline">\(p\)</span>: <span class="math display">\[
M[Q](y, x) = Q(y, x) \, \min\left\{1, \frac{Q(x, y)}{Q(y, x)} \frac{p(y)}{p(x)} \right\},\,\,\, y\not= x
\]</span></p></li>
<li><p><strong>Metropolis-within-Gibbs:</strong> Multiple proposal kernels <span class="math inline">\(P_i\)</span> that have the same stationary distribution <span class="math inline">\(p\)</span> can be combined to produce a new kernel <span class="math inline">\(P=\prod_i P_i\)</span> with the same stationary distribution. A special case is to use proposal chains <span class="math inline">\(Q_i\)</span> that only update a group of variables <span class="math inline">\(x_i\)</span> and leave the other variables <span class="math inline">\(x_{\setminus i}\)</span> untouched: <span class="math display">\[
Q_i(y, x) = \delta(y_{\setminus i} - x_{\setminus i})\, q_i(y_i, x_i; x_{\setminus i})
\]</span> The Metropolis map of <span class="math inline">\(Q_i\)</span> simulates a Markov chain in the subspace <span class="math inline">\(\mathcal X_i\)</span> with proposal kernel <span class="math inline">\(q_i\)</span>.</p></li>
<li><p><strong>Gibbs sampling:</strong> A special case is <span class="math inline">\(q_i(y_i, x_i; x_{\setminus i}) = p_i(y_i|x_{\setminus i})\)</span> (the proposal is the conditional distribution <span class="math inline">\(p_i\)</span> of the <span class="math inline">\(i\)</span>-th group of variables), which results in proposals that are always accepted.</p></li>
</ul>
</section>
<section id="auxiliary-variable-methods" class="level2">
<h2 class="anchored" data-anchor-id="auxiliary-variable-methods">Auxiliary variable methods</h2>
<p>The idea of auxiliary variable methods is to introduce helper variables <span class="math inline">\(y\in\mathcal Y\)</span> that facilitate sampling. The joint distribution <span class="math inline">\(p(x, y)\)</span> over the extended sample space <span class="math inline">\(\mathcal X \times{} \mathcal Y\)</span> has to be designed such that</p>
<p><span class="math display">\[
p(x) = \int_{\mathcal{Y}} p(x, y)\, dy\, .
\]</span></p>
<p>Samples <span class="math inline">\(\bigl(x^{(s)}, y^{(s)}\bigr) \sim p(x, y)\)</span> can then be used to estimate expectations with respect to <span class="math inline">\(p(x)\)</span>:</p>
<p><span class="math display">\[
\mathbb{E}_p[f] = \int_{\mathcal X} f(x)\, p(x)\, dx = \int_{\mathcal X \times \mathcal Y} f(x)\, p(x, y)\, dx dy \approx \frac{1}{S} \sum_{s=1}^S f\bigl(x^{(s)}\bigr)\, .
\]</span></p>
<p>Why is this helpful? We can use Gibbs sampling to generate samples from <span class="math inline">\(p(x, y)\)</span>:</p>
<p><span class="math display">\[\begin{align}\label{eq-gibbs-auxiliary2}
\begin{split}
x^{(s+1)} &amp;\sim p\bigl(x | y^{(s)}\bigr) \\
y^{(s+1)} &amp;\sim p\bigl(y | x^{(s+1)}\bigr) \\
\end{split}
\end{align}\]</span></p>
<p>where the marginal distributions might be easier to simulate than <span class="math inline">\(p(x)\)</span>.</p>
<section id="example-swendsen-wang-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="example-swendsen-wang-algorithm">Example: Swendsen-Wang algorithm</h3>
<p>An example of an auxiliary variable method is the <a href="https://en.wikipedia.org/wiki/Swendsen%E2%80%93Wang_algorithm">Swendsen-Wang algorithm</a> for sampling Ising models. The Ising model (see lecture 1) is defined on a two-dimensional square lattice of length <span class="math inline">\(L\)</span>. The sample space is <span class="math inline">\(\mathcal X = \{-1, +1\}^{L \times L}\)</span>. The probability is</p>
<p><span class="math display">\[
p(x) \propto \exp\left\{\beta \sum_{i\sim j} x_i x_j \right\}
\]</span></p>
<p>where <span class="math inline">\(i\sim j\)</span> indicates if two nodes <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> are nearest neighbors on the square lattice (assuming periodic boundary conditions). In the first lecture, we saw that it is challenging to simulate the Ising model for <span class="math inline">\(\beta \simeq 0.44\)</span>, because of a phase transition: For <span class="math inline">\(\beta\)</span> larger than the critical value, spin variables become highly correlated which makes the sampling quite challenging.</p>
<p>The sampling strategy used in lecture 1 can be interpreted as “Metropolis-within-Gibbs”: The entire 2D lattice is scanned (a loop over all lattice sites is called a <em>sweep</em>). At each lattice site, we try to flip the spin: If <span class="math inline">\(x_i\)</span> is the current value of spin <span class="math inline">\(i\)</span>, then the flipped value is <span class="math inline">\(x_i'=-x_i\)</span>; all other spin variables are unchanged. That is, the proposal kernel <span class="math inline">\(Q_i\)</span> only affects a single site and is symmetric and deterministic. A spin flip is accepted with probability:</p>
<p><span class="math display">\[
\frac{p(x')}{p(x)} = \exp\left\{\beta\sum_{i\sim j} (x_i'x_j' - x_i x_j) \right\} = \exp\left\{-2\beta x_i S_i \right\}
\]</span></p>
<p>where <span class="math inline">\(S_i = \sum_{j\sim i} x_j\)</span> is the total spin of the nearest neighbors, which can be evaluated very efficiently.</p>
<div class="cell" data-execution_count="56">
<div class="sourceCode cell-code" id="cb69"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>load_ext Cython</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>The Cython extension is already loaded. To reload it, use:
  %reload_ext Cython</code></pre>
</div>
</div>
<div class="cell" data-execution_count="57">
<div class="sourceCode cell-code" id="cb71"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="op">%%</span>cython</span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a>cimport cython</span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a>cimport numpy <span class="im">as</span> np</span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-8"><a href="#cb71-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pylab <span class="im">as</span> plt</span>
<span id="cb71-9"><a href="#cb71-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-10"><a href="#cb71-10" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> libc.math cimport exp</span>
<span id="cb71-11"><a href="#cb71-11" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> libc.stdlib cimport rand</span>
<span id="cb71-12"><a href="#cb71-12" aria-hidden="true" tabindex="-1"></a>cdef extern <span class="im">from</span> <span class="st">"limits.h"</span>:</span>
<span id="cb71-13"><a href="#cb71-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">int</span> RAND_MAX</span>
<span id="cb71-14"><a href="#cb71-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-15"><a href="#cb71-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb71-16"><a href="#cb71-16" aria-hidden="true" tabindex="-1"></a><span class="at">@cython.boundscheck</span>(<span class="va">False</span>)</span>
<span id="cb71-17"><a href="#cb71-17" aria-hidden="true" tabindex="-1"></a><span class="at">@cython.wraparound</span>(<span class="va">False</span>)</span>
<span id="cb71-18"><a href="#cb71-18" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ising_energy(np.int64_t[:, :] x):</span>
<span id="cb71-19"><a href="#cb71-19" aria-hidden="true" tabindex="-1"></a>    cdef <span class="bu">int</span> N <span class="op">=</span> x.shape[<span class="dv">0</span>]</span>
<span id="cb71-20"><a href="#cb71-20" aria-hidden="true" tabindex="-1"></a>    cdef <span class="bu">int</span> M <span class="op">=</span> x.shape[<span class="dv">1</span>]</span>
<span id="cb71-21"><a href="#cb71-21" aria-hidden="true" tabindex="-1"></a>    cdef <span class="bu">int</span> E <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb71-22"><a href="#cb71-22" aria-hidden="true" tabindex="-1"></a>    cdef <span class="bu">int</span> i, j</span>
<span id="cb71-23"><a href="#cb71-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb71-24"><a href="#cb71-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(M):</span>
<span id="cb71-25"><a href="#cb71-25" aria-hidden="true" tabindex="-1"></a>            E <span class="op">-=</span> x[i,j] <span class="op">*</span> (x[i,(j<span class="op">+</span><span class="dv">1</span>)<span class="op">%</span>M] <span class="op">+</span> x[(i<span class="op">+</span><span class="dv">1</span>)<span class="op">%</span>N, j])</span>
<span id="cb71-26"><a href="#cb71-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> E</span>
<span id="cb71-27"><a href="#cb71-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-28"><a href="#cb71-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-29"><a href="#cb71-29" aria-hidden="true" tabindex="-1"></a><span class="at">@cython.boundscheck</span>(<span class="va">False</span>)</span>
<span id="cb71-30"><a href="#cb71-30" aria-hidden="true" tabindex="-1"></a><span class="at">@cython.wraparound</span>(<span class="va">False</span>)</span>
<span id="cb71-31"><a href="#cb71-31" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ising_sweep(np.int64_t[:, :] x, <span class="bu">float</span> beta<span class="op">=</span><span class="fl">0.4</span>):</span>
<span id="cb71-32"><a href="#cb71-32" aria-hidden="true" tabindex="-1"></a>    cdef <span class="bu">int</span> N <span class="op">=</span> x.shape[<span class="dv">0</span>]</span>
<span id="cb71-33"><a href="#cb71-33" aria-hidden="true" tabindex="-1"></a>    cdef <span class="bu">int</span> M <span class="op">=</span> x.shape[<span class="dv">1</span>]</span>
<span id="cb71-34"><a href="#cb71-34" aria-hidden="true" tabindex="-1"></a>    cdef <span class="bu">int</span> start_i, start_j, i, j</span>
<span id="cb71-35"><a href="#cb71-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> start_i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>):</span>
<span id="cb71-36"><a href="#cb71-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> start_j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>):</span>
<span id="cb71-37"><a href="#cb71-37" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(start_i, N, <span class="dv">2</span>):</span>
<span id="cb71-38"><a href="#cb71-38" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(start_j, M, <span class="dv">2</span>):</span>
<span id="cb71-39"><a href="#cb71-39" aria-hidden="true" tabindex="-1"></a>                    ising_flip(x, i, j, beta)</span>
<span id="cb71-40"><a href="#cb71-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array(x)</span>
<span id="cb71-41"><a href="#cb71-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-42"><a href="#cb71-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-43"><a href="#cb71-43" aria-hidden="true" tabindex="-1"></a><span class="at">@cython.boundscheck</span>(<span class="va">False</span>)</span>
<span id="cb71-44"><a href="#cb71-44" aria-hidden="true" tabindex="-1"></a><span class="at">@cython.wraparound</span>(<span class="va">False</span>)</span>
<span id="cb71-45"><a href="#cb71-45" aria-hidden="true" tabindex="-1"></a>cdef ising_flip(np.int64_t[:, :] x, <span class="bu">int</span> i, <span class="bu">int</span> j, <span class="bu">float</span> beta):</span>
<span id="cb71-46"><a href="#cb71-46" aria-hidden="true" tabindex="-1"></a>    cdef <span class="bu">int</span> N <span class="op">=</span> x.shape[<span class="dv">0</span>]</span>
<span id="cb71-47"><a href="#cb71-47" aria-hidden="true" tabindex="-1"></a>    cdef <span class="bu">int</span> M <span class="op">=</span> x.shape[<span class="dv">1</span>]</span>
<span id="cb71-48"><a href="#cb71-48" aria-hidden="true" tabindex="-1"></a>    cdef <span class="bu">int</span> S <span class="op">=</span> x[(i<span class="op">-</span><span class="dv">1</span>)<span class="op">%</span>N,j] <span class="op">+</span> x[(i<span class="op">+</span><span class="dv">1</span>)<span class="op">%</span>N,j] <span class="op">+</span> x[i,(j<span class="op">-</span><span class="dv">1</span>)<span class="op">%</span>M] <span class="op">+</span> x[i,(j<span class="op">+</span><span class="dv">1</span>)<span class="op">%</span>M]</span>
<span id="cb71-49"><a href="#cb71-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> exp(<span class="op">-</span><span class="dv">2</span> <span class="op">*</span> beta <span class="op">*</span> x[i, j] <span class="op">*</span> S) <span class="op">*</span> RAND_MAX <span class="op">&gt;</span> rand():</span>
<span id="cb71-50"><a href="#cb71-50" aria-hidden="true" tabindex="-1"></a>        x[i, j] <span class="op">*=</span> <span class="op">-</span><span class="dv">1</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>In file included from /opt/hostedtoolcache/Python/3.10.9/x64/lib/python3.10/site-packages/numpy/core/include/numpy/ndarraytypes.h:1948,
                 from /opt/hostedtoolcache/Python/3.10.9/x64/lib/python3.10/site-packages/numpy/core/include/numpy/ndarrayobject.h:12,
                 from /opt/hostedtoolcache/Python/3.10.9/x64/lib/python3.10/site-packages/numpy/core/include/numpy/arrayobject.h:5,
                 from /home/runner/.cache/ipython/cython/_cython_magic_437ff226c04ce7b8553a40470de4e368.c:770:
/opt/hostedtoolcache/Python/3.10.9/x64/lib/python3.10/site-packages/numpy/core/include/numpy/npy_1_7_deprecated_api.h:17:2: warning: #warning "Using deprecated NumPy API, disable it with " "#define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION" [-Wcpp]
   17 | #warning "Using deprecated NumPy API, disable it with " \
      |  ^~~~~~~</code></pre>
</div>
</div>
<p>To improve the sampling of spin configuration, we introduce auxiliary variables <span class="math inline">\(b_{ij} \in \{0, 1\}\)</span>, also called <em>bond variables</em>, for each pair of spins <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> that are neighbors on the square lattice: <span class="math inline">\(i\sim j\)</span>. The bond variables indicate if two neighboring spins <span class="math inline">\(x_i\)</span>, <span class="math inline">\(x_j\)</span> are aligned (i.e.&nbsp;have the same spin or color):</p>
<p><span class="math display">\[
b_{ij} = \left\{\begin{array}{c c} 1 &amp; \text{if } x_i = x_j \\ 0 &amp; \text{else} \\
\end{array}\right.
\]</span></p>
<p>The bond variables can be seen as Bernoulli coins that are tossed independently of each other. For spins that are aligned, the probability for forming a bond between sites <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span>, <span class="math inline">\(b_{ij}=1\)</span>, is <span class="math inline">\(p=1-e^{-2\beta}\)</span>. So there is a bias for <span class="math inline">\(b_{ij}\)</span> to form that increases with increasing inverse temperature <span class="math inline">\(\beta\)</span>. For spins that are not aligned, the associated bond is <em>not</em> formed with probability one. The overall probability is</p>
<p><span class="math display">\[
p(x, b) \propto \prod_{i\sim j} [p\delta(x_i, x_j)]^{b_{ij}} (1-p)^{1-b_{ij}}
\]</span></p>
<p>where <span class="math inline">\(\delta(x_i, x_j)=1\)</span> if <span class="math inline">\(x_i=x_j\)</span> and <span class="math inline">\(\delta(x_i,x_j)=0\)</span> otherwise. For the Ising model with <span class="math inline">\(x_i=\pm 1\)</span>, we can write</p>
<p><span class="math display">\[
\delta(x_i, x_j) = \frac{x_ix_j + 1}{2}\, .
\]</span></p>
<p>To verify that the marginal distribution over <span class="math inline">\(x\)</span> is correct, let us compute it by summing over <span class="math inline">\(b_{ij}\)</span>:</p>
<p><span class="math display">\[\begin{align*}
\sum_{b} p(x, b) &amp;\propto \sum_{b} \prod_{i\sim j} [p\delta(x_i, x_j)]^{b_{ij}} (1-p)^{1-b_{ij}}\\
&amp;= \prod_{i\sim j} [p\delta(x_i, x_j) + 1 - p] \\
&amp;= \prod_{i\sim j} [1-p]^{1-\delta(x_i, x_j)} \\
&amp;= \prod_{i\sim j} \exp\left\{-2\beta(1-\delta(x_i, x_j))\right\} \\
&amp;= \prod_{i\sim j} \exp\left\{-\beta(1-x_ix_j)\right\} \\
&amp;\propto \prod_{i\sim j} \exp\left\{\beta x_ix_j\right\} \\
\end{align*}\]</span></p>
<p>The conditional distribution of a single bond variable <span class="math inline">\(b_{ij}\)</span> is</p>
<p><span class="math display">\[
p(b_{ij} | x) \propto [p\delta(x_i, x_j)]^{b_{ij}} (1-p)^{1-b_{ij}}
\]</span></p>
<p>These can be updated by simply generating Bernoulli variables for aligned spins, the other bond variables are set to zero.</p>
<p>The conditional distribution of the spins is sampled by assigning all spin variables that belong to the same <a href="https://en.wikipedia.org/wiki/Component_(graph_theory)">connected component</a> of the bond network to a single, randomly selected value <span class="math inline">\(\pm 1\)</span>.</p>
<div class="cell" data-execution_count="58">
<div class="sourceCode cell-code" id="cb73"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="co"># pure Python implementation of Swendsen-Wang</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.sparse <span class="im">as</span> sparse</span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SwendsenWang:</span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, L):</span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.L <span class="op">=</span> <span class="bu">int</span>(L)</span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb73-9"><a href="#cb73-9" aria-hidden="true" tabindex="-1"></a>        <span class="co"># create edges</span></span>
<span id="cb73-10"><a href="#cb73-10" aria-hidden="true" tabindex="-1"></a>        iy, ix <span class="op">=</span> np.meshgrid(np.arange(L), np.arange(L))</span>
<span id="cb73-11"><a href="#cb73-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-12"><a href="#cb73-12" aria-hidden="true" tabindex="-1"></a>        i <span class="op">=</span> np.arange(L<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb73-13"><a href="#cb73-13" aria-hidden="true" tabindex="-1"></a>        i <span class="op">=</span> np.concatenate([i, i])</span>
<span id="cb73-14"><a href="#cb73-14" aria-hidden="true" tabindex="-1"></a>        j <span class="op">=</span> [(L<span class="op">*</span>ix <span class="op">+</span> (iy<span class="op">+</span><span class="dv">1</span>)<span class="op">%</span>L).flatten(), (L<span class="op">*</span>((ix<span class="op">+</span><span class="dv">1</span>)<span class="op">%</span>L) <span class="op">+</span> iy).flatten()]</span>
<span id="cb73-15"><a href="#cb73-15" aria-hidden="true" tabindex="-1"></a>        j <span class="op">=</span> np.concatenate(j)</span>
<span id="cb73-16"><a href="#cb73-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-17"><a href="#cb73-17" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.edges <span class="op">=</span> np.sort([i, j], <span class="dv">0</span>)</span>
<span id="cb73-18"><a href="#cb73-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-19"><a href="#cb73-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> adjacency_matrix(<span class="va">self</span>, bonds<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb73-20"><a href="#cb73-20" aria-hidden="true" tabindex="-1"></a>        i, j <span class="op">=</span> <span class="va">self</span>.edges</span>
<span id="cb73-21"><a href="#cb73-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> bonds <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb73-22"><a href="#cb73-22" aria-hidden="true" tabindex="-1"></a>            i, j <span class="op">=</span> i[bonds], j[bonds]               </span>
<span id="cb73-23"><a href="#cb73-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> sparse.csr_matrix(</span>
<span id="cb73-24"><a href="#cb73-24" aria-hidden="true" tabindex="-1"></a>            (np.ones_like(i), (i, j)), shape<span class="op">=</span>(<span class="va">self</span>.L<span class="op">**</span><span class="dv">2</span>, <span class="va">self</span>.L<span class="op">**</span><span class="dv">2</span>))</span>
<span id="cb73-25"><a href="#cb73-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-26"><a href="#cb73-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> sample_bonds(<span class="va">self</span>, x, beta<span class="op">=</span><span class="fl">1.</span>):</span>
<span id="cb73-27"><a href="#cb73-27" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> x.reshape(<span class="op">-</span><span class="dv">1</span>,)</span>
<span id="cb73-28"><a href="#cb73-28" aria-hidden="true" tabindex="-1"></a>        i, j <span class="op">=</span> <span class="va">self</span>.edges</span>
<span id="cb73-29"><a href="#cb73-29" aria-hidden="true" tabindex="-1"></a>        aligned <span class="op">=</span> (x[i] <span class="op">==</span> x[j])</span>
<span id="cb73-30"><a href="#cb73-30" aria-hidden="true" tabindex="-1"></a>        prob <span class="op">=</span> aligned <span class="op">*</span> (<span class="dv">1</span><span class="op">-</span>np.exp(<span class="op">-</span><span class="dv">2</span><span class="op">*</span>beta)) </span>
<span id="cb73-31"><a href="#cb73-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.random.random(<span class="bu">len</span>(prob)) <span class="op">&lt;</span> prob</span>
<span id="cb73-32"><a href="#cb73-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-33"><a href="#cb73-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> sample_spins(<span class="va">self</span>, x, beta<span class="op">=</span><span class="fl">0.</span>):</span>
<span id="cb73-34"><a href="#cb73-34" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> x.copy().flatten()    </span>
<span id="cb73-35"><a href="#cb73-35" aria-hidden="true" tabindex="-1"></a>        bonds <span class="op">=</span> <span class="va">self</span>.sample_bonds(x, beta)</span>
<span id="cb73-36"><a href="#cb73-36" aria-hidden="true" tabindex="-1"></a>        adjacency <span class="op">=</span> <span class="va">self</span>.adjacency_matrix(bonds)</span>
<span id="cb73-37"><a href="#cb73-37" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb73-38"><a href="#cb73-38" aria-hidden="true" tabindex="-1"></a>        n_comp, labels <span class="op">=</span> sparse.csgraph.connected_components(</span>
<span id="cb73-39"><a href="#cb73-39" aria-hidden="true" tabindex="-1"></a>            adjacency, directed<span class="op">=</span><span class="va">False</span>, return_labels<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb73-40"><a href="#cb73-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-41"><a href="#cb73-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> label <span class="kw">in</span> <span class="bu">range</span>(n_comp):</span>
<span id="cb73-42"><a href="#cb73-42" aria-hidden="true" tabindex="-1"></a>            x[labels<span class="op">==</span>label] <span class="op">=</span> np.random.choice([<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>])</span>
<span id="cb73-43"><a href="#cb73-43" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb73-44"><a href="#cb73-44" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> x.reshape(<span class="va">self</span>.L, <span class="op">-</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="59">
<div class="sourceCode cell-code" id="cb74"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="co"># For comparison: mean energy per spin in infinite lattice from Onsager theory</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a><span class="co"># https://en.wikipedia.org/wiki/Square_lattice_Ising_model#Exact_solution</span></span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy <span class="im">import</span> integrate</span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> energy_per_spin(beta):</span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Average energy per lattice site according to Onsager.</span></span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb74-9"><a href="#cb74-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> np.iterable(beta):</span>
<span id="cb74-10"><a href="#cb74-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.array(<span class="bu">list</span>(<span class="bu">map</span>(energy_per_spin, beta)))</span>
<span id="cb74-11"><a href="#cb74-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb74-12"><a href="#cb74-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># scalar beta</span></span>
<span id="cb74-13"><a href="#cb74-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> f(theta):</span>
<span id="cb74-14"><a href="#cb74-14" aria-hidden="true" tabindex="-1"></a>        k <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> np.sinh(<span class="dv">2</span><span class="op">*</span>beta)<span class="op">**</span><span class="dv">2</span></span>
<span id="cb74-15"><a href="#cb74-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span> <span class="op">/</span> np.sqrt(<span class="dv">1</span> <span class="op">-</span> <span class="dv">4</span><span class="op">*</span>k<span class="op">/</span>(<span class="dv">1</span><span class="op">+</span>k)<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> np.sin(theta)<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb74-16"><a href="#cb74-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-17"><a href="#cb74-17" aria-hidden="true" tabindex="-1"></a>    I <span class="op">=</span> integrate.quad(f, <span class="fl">0.</span>, <span class="fl">0.5</span><span class="op">*</span>np.pi)[<span class="dv">0</span>]</span>
<span id="cb74-18"><a href="#cb74-18" aria-hidden="true" tabindex="-1"></a>    I <span class="op">*=</span> <span class="dv">2</span> <span class="op">*</span> (<span class="dv">2</span><span class="op">*</span>np.tanh(<span class="dv">2</span><span class="op">*</span>beta)<span class="op">**</span><span class="dv">2</span> <span class="op">-</span> <span class="dv">1</span>) <span class="op">/</span> np.pi</span>
<span id="cb74-19"><a href="#cb74-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span> (<span class="dv">1</span> <span class="op">+</span> I) <span class="op">/</span> np.tanh(<span class="dv">2</span><span class="op">*</span>beta)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="60">
<div class="sourceCode cell-code" id="cb75"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a>L <span class="op">=</span> <span class="dv">2</span><span class="op">**</span><span class="dv">7</span></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.random.choice([<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>], (L, L))</span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a><span class="co"># inverse temperature close to critical value</span></span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a>beta <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> np.log(<span class="dv">1</span> <span class="op">+</span> <span class="dv">2</span><span class="op">**</span>(<span class="dv">1</span><span class="op">/</span><span class="dv">2</span>))</span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a>n_iter <span class="op">=</span> <span class="dv">30</span></span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-8"><a href="#cb75-8" aria-hidden="true" tabindex="-1"></a><span class="co"># starting from random configuration (beta=0.) using Metropolis</span></span>
<span id="cb75-9"><a href="#cb75-9" aria-hidden="true" tabindex="-1"></a><span class="co"># algorithm to approach distribution at critical beta</span></span>
<span id="cb75-10"><a href="#cb75-10" aria-hidden="true" tabindex="-1"></a>x_MH <span class="op">=</span> x.copy()</span>
<span id="cb75-11"><a href="#cb75-11" aria-hidden="true" tabindex="-1"></a>E_MH <span class="op">=</span> [ising_energy(x_MH)<span class="op">/</span>L<span class="op">**</span><span class="dv">2</span>]</span>
<span id="cb75-12"><a href="#cb75-12" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n_iter):</span>
<span id="cb75-13"><a href="#cb75-13" aria-hidden="true" tabindex="-1"></a>    x_MH <span class="op">=</span> ising_sweep(x_MH)</span>
<span id="cb75-14"><a href="#cb75-14" aria-hidden="true" tabindex="-1"></a>    E_MH.append(ising_energy(x_MH)<span class="op">/</span>L<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb75-15"><a href="#cb75-15" aria-hidden="true" tabindex="-1"></a>E_MH <span class="op">=</span> np.array(E_MH)</span>
<span id="cb75-16"><a href="#cb75-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-17"><a href="#cb75-17" aria-hidden="true" tabindex="-1"></a><span class="co"># starting from random configuration (beta=0.) using Swendsen-</span></span>
<span id="cb75-18"><a href="#cb75-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Wang to approach distribution at critical beta</span></span>
<span id="cb75-19"><a href="#cb75-19" aria-hidden="true" tabindex="-1"></a>sampler <span class="op">=</span> SwendsenWang(L)</span>
<span id="cb75-20"><a href="#cb75-20" aria-hidden="true" tabindex="-1"></a>x_SW <span class="op">=</span> x.copy()</span>
<span id="cb75-21"><a href="#cb75-21" aria-hidden="true" tabindex="-1"></a>E_SW <span class="op">=</span> [ising_energy(x_SW)<span class="op">/</span>L<span class="op">**</span><span class="dv">2</span>]</span>
<span id="cb75-22"><a href="#cb75-22" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n_iter):</span>
<span id="cb75-23"><a href="#cb75-23" aria-hidden="true" tabindex="-1"></a>    x_SW <span class="op">=</span> sampler.sample_spins(x_SW, beta)</span>
<span id="cb75-24"><a href="#cb75-24" aria-hidden="true" tabindex="-1"></a>    E_SW.append(ising_energy(x_SW)<span class="op">/</span>L<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb75-25"><a href="#cb75-25" aria-hidden="true" tabindex="-1"></a>E_SW <span class="op">=</span> np.array(E_SW)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="61">
<div class="sourceCode cell-code" id="cb76"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a>betas <span class="op">=</span> [np.linspace(<span class="fl">1e-3</span>, <span class="fl">1.</span>, <span class="dv">101</span>), </span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>         np.linspace(<span class="fl">0.2</span>, <span class="fl">0.8</span>, <span class="dv">101</span>)][<span class="dv">0</span>]</span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a>U <span class="op">=</span> energy_per_spin(betas)</span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a>plt.rc(<span class="st">'font'</span>, size<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb76-6"><a href="#cb76-6" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">5</span>), sharey<span class="op">=</span><span class="st">'all'</span>)</span>
<span id="cb76-7"><a href="#cb76-7" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> <span class="bu">list</span>(ax.flat)</span>
<span id="cb76-8"><a href="#cb76-8" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].plot(E_MH, lw<span class="op">=</span><span class="dv">3</span>, label<span class="op">=</span><span class="st">'Metropolis'</span>)</span>
<span id="cb76-9"><a href="#cb76-9" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].plot(E_SW, lw<span class="op">=</span><span class="dv">3</span>, label<span class="op">=</span><span class="st">'Swendsen-Wang'</span>)</span>
<span id="cb76-10"><a href="#cb76-10" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_xlabel(<span class="vs">r'iteration $s$'</span>)</span>
<span id="cb76-11"><a href="#cb76-11" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_ylabel(<span class="vs">r'energy per spin $E/L^2$'</span>)</span>
<span id="cb76-12"><a href="#cb76-12" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].legend()</span>
<span id="cb76-13"><a href="#cb76-13" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].scatter(beta, E_MH[<span class="op">-</span><span class="dv">1</span>], s<span class="op">=</span><span class="dv">200</span>, label<span class="op">=</span><span class="st">'Metropolis'</span>)</span>
<span id="cb76-14"><a href="#cb76-14" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].scatter(beta, E_SW[<span class="op">-</span><span class="dv">1</span>], s<span class="op">=</span><span class="dv">200</span>, label<span class="op">=</span><span class="st">'Swendsen-Wang'</span>)</span>
<span id="cb76-15"><a href="#cb76-15" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].plot(betas, U, color<span class="op">=</span><span class="st">'r'</span>, ls<span class="op">=</span><span class="st">'--'</span>, lw<span class="op">=</span><span class="dv">3</span>, label<span class="op">=</span><span class="st">'Onsager'</span>)</span>
<span id="cb76-16"><a href="#cb76-16" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlabel(<span class="vs">r'inverse temperature $\beta$'</span>)</span>
<span id="cb76-17"><a href="#cb76-17" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].legend()</span>
<span id="cb76-18"><a href="#cb76-18" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-62-output-1.png" width="921" height="453"></p>
</div>
</div>
<div class="cell" data-execution_count="62">
<div class="sourceCode cell-code" id="cb77"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a>plt.rc(<span class="st">'image'</span>, interpolation<span class="op">=</span><span class="va">None</span>, cmap<span class="op">=</span><span class="st">'gray'</span>)</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>kw <span class="op">=</span> <span class="bu">dict</span>(xticks<span class="op">=</span>[], yticks<span class="op">=</span>[])</span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">5</span>), subplot_kw<span class="op">=</span>kw)</span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_title(<span class="st">'Metropolis'</span>)</span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].imshow(x_MH.reshape(L, L))</span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_title(<span class="st">'Swendsen-Wang'</span>)</span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].imshow(x_SW.reshape(L, L))</span>
<span id="cb77-8"><a href="#cb77-8" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>/tmp/ipykernel_1922/3345378395.py:1: MatplotlibDeprecationWarning: Support for setting an rcParam that expects a str value to a non-str value is deprecated since 3.5 and support will be removed two minor releases later.
  plt.rc('image', interpolation=None, cmap='gray')</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-63-output-2.png" width="914" height="473"></p>
</div>
</div>
</section>
</section>
<section id="hamiltonian-monte-carlo" class="level2">
<h2 class="anchored" data-anchor-id="hamiltonian-monte-carlo">Hamiltonian Monte Carlo</h2>
<p>Another auxiliary variable method is <a href="https://en.wikipedia.org/wiki/Hamiltonian_Monte_Carlo">Hamiltonian Monte Carlo (HMC)</a> also known as <a href="https://doi.org/10.1016%2F0370-2693%2887%2991197-X"><em>Hybrid Monte Carlo</em></a>. HMC is among the most widely used methods for sampling probabilistic models over continuous sample spaces. Radford Neal, one of the inventors of HMC, has written a nice introduction that can be found <a href="http://www.mcmchandbook.net/HandbookChapter5.pdf">here</a>.</p>
<p>The idea of HMC is to exploit the following physical analogy: we interpret</p>
<p><span id="eq-energy-hmc"><span class="math display">\[
E(x) = - \log p(x)
\tag{75}\]</span></span></p>
<p>as a potential energy function of a physical system with degrees of freedom <span class="math inline">\(x\)</span>. Typically, <span class="math inline">\(x\in\mathbb{R}^D\)</span>.</p>
<p>We introduce auxiliary variables <span class="math inline">\(v\in\mathbb{R}^D\)</span> that follow a <span class="math inline">\(D\)</span>-dimensional standard Gaussian distribution:</p>
<p><span class="math display">\[
p(v) = (2\pi)^{-D/2} \exp\left\{-\|v\|^2 / 2 \right\}
\]</span></p>
<p>and construct the joint distribution:</p>
<p><span id="eq-hmc-joint"><span class="math display">\[
p(x, v) = p(x)\, p(v) \propto \exp\left\{- E(x) - \|v\|^2 / 2 \right\}\, .
\tag{76}\]</span></span></p>
<p>It seems that we didn’t gain anything by introducing <span class="math inline">\(v\)</span> other than artificially blowing up the problem and writing the joint distribution in some fancy, pseudo-physical way. However, the major insight comes from the fact that if we stretch the physical analogy further, the joint distribution can be viewed as the <a href="https://en.wikipedia.org/wiki/Canonical_ensemble">canonical ensemble</a> defined over <a href="https://en.wikipedia.org/wiki/Phase_space"><em>phase space</em></a>:</p>
<p><span id="eq-hmc-hamiltonian"><span class="math display">\[
p(x, v) \propto \exp\left\{- H(x, v)\right\}\,\,\,\text{where}\,\,\,  H(x, v) := \underbrace{\tfrac{1}{2} \|v\|^2}_{\text{kinetic energy}} + \underbrace{E(x)}_{\text{potential energy}}\, .
\tag{77}\]</span></span></p>
<p>Phase space is the joint space of positions <span class="math inline">\(x\)</span> and momenta (velocities) <span class="math inline">\(v\)</span> in our physical analogy, and the total energy is given by the sum of the kinetic and potential energy is called the <a href="https://en.wikipedia.org/wiki/Hamiltonian_mechanics"><em>Hamiltonian</em></a> of the system.</p>
<section id="hamiltonian-dynamics" class="level3">
<h3 class="anchored" data-anchor-id="hamiltonian-dynamics">Hamiltonian dynamics</h3>
<p>Classical systems with <span class="math inline">\(D\)</span> degrees of freedom evolve in time by the action of the Hamiltonian <span class="math inline">\(H(x, v)\)</span>. Trajectories in phase space are given by the time evolution of velocities and positions, <span class="math inline">\(v(t)\)</span> and <span class="math inline">\(x(t)\)</span>. The dynamics of the system is described by Hamilton’s equations of motion (an elegant generalization of Newton dynamics):</p>
<p><span class="math display">\[\begin{align}\label{eq-hmc-dynamics}
\begin{split}
\dot{v} &amp;= \frac{d}{dt} v = - \nabla_x H(x, v) \\
\dot{x} &amp;= \frac{d}{dt} x = + \nabla_v H(x, v) \\
\end{split}
\end{align}\]</span></p>
<p>where <span class="math inline">\(d/dt\)</span> is the derivative with respect to time <span class="math inline">\(t\)</span> and abbreviated by a dot (as in <span class="math inline">\(\dot{x}\)</span>), and <span class="math inline">\(\nabla_x, \nabla_v\)</span> are the gradients with respect to positions <span class="math inline">\(x\)</span> and momenta <span class="math inline">\(v\)</span>.</p>
<p>The hallmark of Hamiltonian dynamics (Eq. <span class="math inline">\(\ref{eq-hmc-dynamics}\)</span>) of an isolated classical system is that it conserves the total energy. This is clear from</p>
<p><span class="math display">\[
\frac{d}{dt} H = (\nabla_x H(x, v))^T\dot{x} + (\nabla_v H(x, v))^T\dot{v} = (\nabla_x H)^T\!(\nabla_v H) - (\nabla_v H)^T\!(\nabla_x H) = 0
\]</span></p>
<p>where we used the <a href="https://en.wikipedia.org/wiki/Chain_rule">chain rule</a> to compute the <a href="https://en.wikipedia.org/wiki/Total_derivative">total derivative</a> of the Hamiltonian with respect to time (note that there is no explicit time dependence of <span class="math inline">\(H\)</span>, i.e.&nbsp;<span class="math inline">\(\partial_t H=0\)</span>).</p>
<p>The trick of HMC is to sample the momenta <span class="math inline">\(v\)</span> from the collapsed distribution</p>
<p><span class="math display">\[
v^{(s)} \sim \mathcal N(0, I_D)
\]</span></p>
<p>and evolve the system to a proposal state starting from the previous positions <span class="math inline">\(x^{(s)}\)</span> and the newly sampled momenta <span class="math inline">\(v^{(s)}\)</span>. If the time evolution is based on Hamiltonian dynamics, we know that the Hamiltonian <span class="math inline">\(H(x, v)\)</span> is conserved. So if <span class="math inline">\(H(x^{(s)}, v^{(s)})\)</span> is the total energy of the current state, then the Hamiltonian of the proposal state <span class="math inline">\(\bigl(x(T), v(T)\bigr)\)</span> where <span class="math inline">\(T\)</span> is the integration time will be the same:</p>
<p><span class="math display">\[
H\bigl(x(T), v(T)\bigr) = H\bigl(x^{(s)}, v^{(s)}\bigr)\,\,\,\text{where}\,\,\,  \bigl(x^{(s)}, v^{(s)}\bigr) \xrightarrow[\text{dynamics}]{\text{Hamiltonian}} \bigl(x(T), v(T)\bigr) \,.
\]</span></p>
<p>The probability for accepting <span class="math inline">\(\bigl(x(T), v(T)\bigr)\)</span> as new state <span class="math inline">\(\bigl(x^{(s+1)}, v^{(s+1)}\bigr)\)</span> is given by the ratio</p>
<p><span class="math display">\[
\frac{p\bigl(x(T),v(T)\bigr)}{p\bigl(x^{(s)}, y^{(s)}\bigr)} = \exp\left\{-\Delta H \right\}\,\,\, \text{with}\,\,\, \Delta H = H\bigl(x(T), v(T) \bigr) -  H\bigl(x^{(s)}, v^{(s)} \bigr)\, .
\]</span></p>
<p>This ratio doesn’t depend on the proposal probabilities, because Hamiltonian dynamics is <a href="https://en.wikipedia.org/wiki/Liouville%27s_theorem_(Hamiltonian)">symplectic</a>, i.e.&nbsp;the chance for going from one point in phase space to another point in phase space is the same for the reverse dynamics (volumes in phase space don’t change under Hamiltonian dynamics, the dynamics of the system is incompressible). So the proposal chain is symmetric and proposal probabilities cancel out in the acceptance step.</p>
<p>Since the total energy of the start and proposal state are the same, we have <span class="math inline">\(\Delta H = 0\)</span> and the proposed state will be accepted with probability one.</p>
</section>
<section id="example-harmonic-oscillator" class="level3">
<h3 class="anchored" data-anchor-id="example-harmonic-oscillator">Example: Harmonic oscillator</h3>
<p>Let us consider a concrete example whose dynamics can be solved exactly: the <a href="https://en.wikipedia.org/wiki/Harmonic_oscillator">harmonic oscillator</a> which corresponds to a Gaussian model:</p>
<p><span class="math display">\[
H(x, v) = v^2 / 2 + k x^2 / 2
\]</span></p>
<p>with the following dynamics:</p>
<p><span class="math display">\[\begin{align}
\begin{split}
\dot{x} &amp;= +\frac{\partial H}{\partial v} = v \\
\dot{v} &amp;= -\frac{\partial H}{\partial x} = -k x\\
\end{split}
\end{align}\]</span></p>
<p>In matrix-vector form we have</p>
<p><span id="eq-oscillator"><span class="math display">\[
\frac{d}{dt} \begin{pmatrix} v\\ x\end{pmatrix} = \begin{pmatrix} 0 &amp; -k \\ 1 &amp; 0 \\ \end{pmatrix} \begin{pmatrix} v\\ x\end{pmatrix} = A \begin{pmatrix} v\\ x\end{pmatrix}\,\,\,\Rightarrow\,\,\, \begin{pmatrix} v(t)\\ x(t)\end{pmatrix} = \exp\{tA\} \begin{pmatrix} v_0\\ x_0\end{pmatrix}
\tag{78}\]</span></span></p>
<p>where <span class="math inline">\(\exp\{tA\}\)</span> is a matrix exponential <span class="math inline">\(\exp\{tA\} = \sum_n \frac{t^n}{n!} A^n\)</span>. The matrix powers have a simple structure:</p>
<p><span class="math display">\[
A^{2n} = (-k)^n I, \,\,\, A^{2n+1} = (-k)^n A
\]</span></p>
<p>So the solution of the Hamilton equations is (with <span class="math inline">\(\omega = \sqrt{k}\)</span>):</p>
<p><span class="math display">\[\begin{eqnarray*}\label{eq-oscillator2}
\begin{pmatrix} v(t)\\ x(t)\end{pmatrix} &amp;=&amp; I \sum_{n} \frac{(-)^n}{(2n)!} (\omega t)^{2n} \begin{pmatrix} v_0\\ x_0\end{pmatrix} + \omega^{-1}A \sum_{n} \frac{(-)^n}{(2n+1)!} (\omega t)^{2n+1} \begin{pmatrix} v_0\\ x_0\end{pmatrix} \\
&amp;=&amp; \biggl(I \cos(\omega t) + \omega^{-1}A \sin(\omega t)\biggr) \begin{pmatrix} v_0\\ x_0\end{pmatrix} \\
&amp;=&amp; \begin{pmatrix} \cos(\omega t) &amp; -\omega\sin(\omega t)\\ \sin(\omega t)/\omega  &amp; \cos(\omega t) \\ \end{pmatrix} \begin{pmatrix} v_0\\ x_0\end{pmatrix}
\end{eqnarray*}\]</span></p>
<p>The Hamiltonian <span class="math inline">\(H(x, v)\)</span> is indeed conserved (<em>Exercise</em>).</p>
<p>We can now sample a Gaussian model by exploiting the physical analogy to the harmonic oscillator. We pretend that we can only sample the momenta from a standard normal distribution, and then use the dynamics of the harmonic oscillator to generate a proposal state that is accepted with probability one:</p>
<div class="cell" data-execution_count="63">
<div class="sourceCode cell-code" id="cb79"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a>plt.rc(<span class="st">'image'</span>, cmap<span class="op">=</span><span class="st">'viridis'</span>)</span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Oscillator:</span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, k<span class="op">=</span><span class="fl">1.</span>, T<span class="op">=</span><span class="fl">1.</span>):</span>
<span id="cb79-7"><a href="#cb79-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-8"><a href="#cb79-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.k <span class="op">=</span> <span class="bu">float</span>(k)</span>
<span id="cb79-9"><a href="#cb79-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.T <span class="op">=</span> <span class="bu">float</span>(T)</span>
<span id="cb79-10"><a href="#cb79-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.A <span class="op">=</span> np.array([[<span class="dv">0</span>, <span class="dv">1</span>], [<span class="op">-</span><span class="va">self</span>.k, <span class="dv">0</span>]])</span>
<span id="cb79-11"><a href="#cb79-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.w <span class="op">=</span> np.sqrt(k)</span>
<span id="cb79-12"><a href="#cb79-12" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb79-13"><a href="#cb79-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> propagate(<span class="va">self</span>, x, v, T<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb79-14"><a href="#cb79-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-15"><a href="#cb79-15" aria-hidden="true" tabindex="-1"></a>        T <span class="op">=</span> <span class="va">self</span>.T <span class="cf">if</span> T <span class="kw">is</span> <span class="va">None</span> <span class="cf">else</span> <span class="bu">float</span>(T)</span>
<span id="cb79-16"><a href="#cb79-16" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb79-17"><a href="#cb79-17" aria-hidden="true" tabindex="-1"></a>        U <span class="op">=</span> np.array([[np.cos(<span class="va">self</span>.w<span class="op">*</span>T), np.sin(<span class="va">self</span>.w<span class="op">*</span>T)<span class="op">/</span><span class="va">self</span>.w],</span>
<span id="cb79-18"><a href="#cb79-18" aria-hidden="true" tabindex="-1"></a>                      [<span class="op">-</span>np.sin(<span class="va">self</span>.w<span class="op">*</span>T)<span class="op">*</span><span class="va">self</span>.w, np.cos(<span class="va">self</span>.w<span class="op">*</span>T)]])</span>
<span id="cb79-19"><a href="#cb79-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-20"><a href="#cb79-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> U.dot([x, v])</span>
<span id="cb79-21"><a href="#cb79-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-22"><a href="#cb79-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> calc_hamiltonian(<span class="va">self</span>, x, v):</span>
<span id="cb79-23"><a href="#cb79-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="fl">0.5</span> <span class="op">*</span> v<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> <span class="va">self</span>.k <span class="op">*</span> x<span class="op">**</span><span class="dv">2</span></span>
<span id="cb79-24"><a href="#cb79-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-25"><a href="#cb79-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> gradient(<span class="va">self</span>, x):</span>
<span id="cb79-26"><a href="#cb79-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.k <span class="op">*</span> x</span>
<span id="cb79-27"><a href="#cb79-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb79-28"><a href="#cb79-28" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> (<span class="fl">10.</span>, <span class="fl">0.1</span>)[<span class="dv">1</span>]</span>
<span id="cb79-29"><a href="#cb79-29" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="fl">1000.</span></span>
<span id="cb79-30"><a href="#cb79-30" aria-hidden="true" tabindex="-1"></a>x0 <span class="op">=</span> <span class="fl">10.</span></span>
<span id="cb79-31"><a href="#cb79-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-32"><a href="#cb79-32" aria-hidden="true" tabindex="-1"></a>osci <span class="op">=</span> Oscillator(k, T)</span>
<span id="cb79-33"><a href="#cb79-33" aria-hidden="true" tabindex="-1"></a>samples <span class="op">=</span> [(x0, np.random.standard_normal())]</span>
<span id="cb79-34"><a href="#cb79-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-35"><a href="#cb79-35" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="bu">len</span>(samples) <span class="op">&lt;</span> <span class="fl">1e4</span>:</span>
<span id="cb79-36"><a href="#cb79-36" aria-hidden="true" tabindex="-1"></a>    x, v <span class="op">=</span> osci.propagate(<span class="op">*</span>samples[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb79-37"><a href="#cb79-37" aria-hidden="true" tabindex="-1"></a>    v <span class="op">=</span> np.random.standard_normal()</span>
<span id="cb79-38"><a href="#cb79-38" aria-hidden="true" tabindex="-1"></a>    samples.append((x, v))</span>
<span id="cb79-39"><a href="#cb79-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-40"><a href="#cb79-40" aria-hidden="true" tabindex="-1"></a>samples <span class="op">=</span> np.array(samples)</span>
<span id="cb79-41"><a href="#cb79-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-42"><a href="#cb79-42" aria-hidden="true" tabindex="-1"></a>sigma <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> osci.k<span class="op">**</span><span class="fl">0.5</span></span>
<span id="cb79-43"><a href="#cb79-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-44"><a href="#cb79-44" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">1</span>, <span class="fl">1.</span>, <span class="dv">1000</span>) <span class="op">*</span> <span class="dv">4</span> <span class="op">*</span> sigma</span>
<span id="cb79-45"><a href="#cb79-45" aria-hidden="true" tabindex="-1"></a>p_x <span class="op">=</span> np.exp(<span class="op">-</span><span class="fl">0.5</span> <span class="op">*</span> x<span class="op">**</span><span class="dv">2</span> <span class="op">/</span> sigma<span class="op">**</span><span class="dv">2</span> <span class="op">-</span> <span class="fl">0.5</span> <span class="op">*</span> np.log(<span class="dv">2</span><span class="op">*</span>np.pi<span class="op">*</span>sigma<span class="op">**</span><span class="dv">2</span>))</span>
<span id="cb79-46"><a href="#cb79-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-47"><a href="#cb79-47" aria-hidden="true" tabindex="-1"></a>v <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">1</span>, <span class="fl">1.</span>, <span class="dv">1000</span>) <span class="op">*</span> <span class="dv">4</span> </span>
<span id="cb79-48"><a href="#cb79-48" aria-hidden="true" tabindex="-1"></a>p_v <span class="op">=</span> np.exp(<span class="op">-</span><span class="fl">0.5</span> <span class="op">*</span> v<span class="op">**</span><span class="dv">2</span> <span class="op">-</span> <span class="fl">0.5</span> <span class="op">*</span> np.log(<span class="dv">2</span><span class="op">*</span>np.pi))</span>
<span id="cb79-49"><a href="#cb79-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-50"><a href="#cb79-50" aria-hidden="true" tabindex="-1"></a>burnin <span class="op">=</span> <span class="dv">200</span></span>
<span id="cb79-51"><a href="#cb79-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-52"><a href="#cb79-52" aria-hidden="true" tabindex="-1"></a>kw_hist <span class="op">=</span> <span class="bu">dict</span>(bins<span class="op">=</span><span class="dv">20</span>, color<span class="op">=</span><span class="st">'k'</span>, density<span class="op">=</span><span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.2</span>)</span>
<span id="cb79-53"><a href="#cb79-53" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">4</span>))</span>
<span id="cb79-54"><a href="#cb79-54" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb79-55"><a href="#cb79-55" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].plot(<span class="op">*</span>samples[:burnin].T, color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.2</span>)</span>
<span id="cb79-56"><a href="#cb79-56" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].scatter(<span class="op">*</span>samples[:burnin].T, c<span class="op">=</span>np.linspace(<span class="fl">0.</span>, <span class="fl">1.</span>, <span class="bu">len</span>(samples[:burnin])), alpha<span class="op">=</span><span class="fl">1.</span>)</span>
<span id="cb79-57"><a href="#cb79-57" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_xlabel(<span class="vs">r'$x^{(s)}$'</span>)</span>
<span id="cb79-58"><a href="#cb79-58" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_ylabel(<span class="vs">r'$v^{(s)}$'</span>)</span>
<span id="cb79-59"><a href="#cb79-59" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb79-60"><a href="#cb79-60" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].hist(samples[burnin:,<span class="dv">0</span>], <span class="op">**</span>kw_hist)</span>
<span id="cb79-61"><a href="#cb79-61" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].plot(x, p_x, color<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb79-62"><a href="#cb79-62" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlabel(<span class="vs">r'$x^{(s)}$'</span>)</span>
<span id="cb79-63"><a href="#cb79-63" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb79-64"><a href="#cb79-64" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].hist(samples[burnin:,<span class="dv">1</span>], <span class="op">**</span>kw_hist)</span>
<span id="cb79-65"><a href="#cb79-65" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].plot(v, p_v, color<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb79-66"><a href="#cb79-66" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].set_xlabel(<span class="vs">r'$v^{(s)}$'</span>)</span>
<span id="cb79-67"><a href="#cb79-67" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb79-68"><a href="#cb79-68" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-64-output-1.png" width="1121" height="355"></p>
</div>
</div>
</section>
</section>
</section>
<section id="lecture-8-hamiltonian-monte-carlo-practical-issues-1" class="level1">
<h1>Lecture 8: Hamiltonian Monte Carlo, Practical Issues</h1>
<p>Michael Habeck - University Hospital Jena - michael.habeck@uni-jena.de</p>
<section id="outline-7" class="level2">
<h2 class="anchored" data-anchor-id="outline-7">Outline</h2>
<ul>
<li>Hamiltonian Monte Carlo continued</li>
<li>Practical Issues (convergence, diagnostic checks)</li>
</ul>
</section>
<section id="recap-4" class="level2">
<h2 class="anchored" data-anchor-id="recap-4">Recap</h2>
<p>In the last lecture we’ve looked at the <a href="https://en.wikipedia.org/wiki/Harmonic_oscillator">harmonic oscillator</a>:</p>
<div class="cell" data-execution_count="64">
<div class="sourceCode cell-code" id="cb80"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pylab <span class="im">as</span> plt</span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Oscillator:</span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, k<span class="op">=</span><span class="fl">1.</span>, T<span class="op">=</span><span class="fl">1.</span>):</span>
<span id="cb80-7"><a href="#cb80-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-8"><a href="#cb80-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.k <span class="op">=</span> <span class="bu">float</span>(k)</span>
<span id="cb80-9"><a href="#cb80-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.T <span class="op">=</span> <span class="bu">float</span>(T)</span>
<span id="cb80-10"><a href="#cb80-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.A <span class="op">=</span> np.array([[<span class="dv">0</span>, <span class="dv">1</span>], [<span class="op">-</span><span class="va">self</span>.k, <span class="dv">0</span>]])</span>
<span id="cb80-11"><a href="#cb80-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.w <span class="op">=</span> np.sqrt(k)</span>
<span id="cb80-12"><a href="#cb80-12" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb80-13"><a href="#cb80-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> propagate(<span class="va">self</span>, x, v, T<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb80-14"><a href="#cb80-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-15"><a href="#cb80-15" aria-hidden="true" tabindex="-1"></a>        T <span class="op">=</span> <span class="va">self</span>.T <span class="cf">if</span> T <span class="kw">is</span> <span class="va">None</span> <span class="cf">else</span> <span class="bu">float</span>(T)</span>
<span id="cb80-16"><a href="#cb80-16" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb80-17"><a href="#cb80-17" aria-hidden="true" tabindex="-1"></a>        U <span class="op">=</span> np.array([[np.cos(<span class="va">self</span>.w<span class="op">*</span>T), np.sin(<span class="va">self</span>.w<span class="op">*</span>T)<span class="op">/</span><span class="va">self</span>.w],</span>
<span id="cb80-18"><a href="#cb80-18" aria-hidden="true" tabindex="-1"></a>                      [<span class="op">-</span>np.sin(<span class="va">self</span>.w<span class="op">*</span>T)<span class="op">*</span><span class="va">self</span>.w, np.cos(<span class="va">self</span>.w<span class="op">*</span>T)]])</span>
<span id="cb80-19"><a href="#cb80-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-20"><a href="#cb80-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> U.dot([x, v])</span>
<span id="cb80-21"><a href="#cb80-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-22"><a href="#cb80-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> calc_hamiltonian(<span class="va">self</span>, x, v):</span>
<span id="cb80-23"><a href="#cb80-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="fl">0.5</span> <span class="op">*</span> v<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> <span class="va">self</span>.k <span class="op">*</span> x<span class="op">**</span><span class="dv">2</span></span>
<span id="cb80-24"><a href="#cb80-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-25"><a href="#cb80-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> gradient(<span class="va">self</span>, x):</span>
<span id="cb80-26"><a href="#cb80-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.k <span class="op">*</span> x</span>
<span id="cb80-27"><a href="#cb80-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb80-28"><a href="#cb80-28" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> (<span class="fl">10.</span>, <span class="fl">0.1</span>)[<span class="dv">1</span>]</span>
<span id="cb80-29"><a href="#cb80-29" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="fl">1000.</span></span>
<span id="cb80-30"><a href="#cb80-30" aria-hidden="true" tabindex="-1"></a>x0 <span class="op">=</span> <span class="fl">10.</span></span>
<span id="cb80-31"><a href="#cb80-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-32"><a href="#cb80-32" aria-hidden="true" tabindex="-1"></a>osci <span class="op">=</span> Oscillator(k, T)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="leapfrog-integrator" class="level2">
<h2 class="anchored" data-anchor-id="leapfrog-integrator">Leapfrog integrator</h2>
<p>It is only rarely possible to solve Hamilton’s equations of motion in closed form. In practice, we often have to resort to numerical integration methods to solve this system of ordinary differential equations.</p>
<p>The crucial feature for making HMC work properly is the conservation of phase space volume. If phase space volume is not conserved, symmetry of the proposal chain is no longer guaranteed, and we would have to take into account the forward and backward probabilities in the acceptance ratios. These probabilities cannot be computed for general systems. Therefore, we have to look out for <a href="https://en.wikipedia.org/wiki/Symplectic_integrator">symplectic integrators</a> that solve Hamilton’s equations of motion numerically but still conserve phase-space volume.</p>
<p><a href="https://en.wikipedia.org/wiki/Leapfrog_integration">Leapfrog integration</a> is a simple symplectic integration scheme that is often used as an integrator in HMC. The leapfrog integrator solves a finite-difference version of Hamilton’s equations of motion:</p>
<p><span class="math display">\[\begin{align}\label{eq-leapfrog}
\begin{split}
v(t+\epsilon/2) &amp;= v(t) - (\epsilon/2) \nabla_x E(x(t)) \\
x(t+\epsilon) &amp;= x(t) + \epsilon v(t+\epsilon/2) \\
v(t+\epsilon) &amp;= v(t+\epsilon/2) - (\epsilon/2) \nabla_x E(x(t+\epsilon))
\end{split}
\end{align}\]</span></p>
<p>where <span class="math inline">\(\epsilon\)</span> is the time step. The initial positions and momenta <span class="math inline">\(x(0)\)</span> and <span class="math inline">\(v(0)\)</span> are the previous state <span class="math inline">\(x^{(s)}\)</span> and a sample from the standard Gaussian <span class="math inline">\(v^{(s)} \sim \mathcal N(0, I)\)</span>.</p>
<p>The leapfrog equations can be rearranged to avoid unnecessary gradient evaluations:</p>
<ol type="1">
<li>From <span class="math inline">\(x(0), v(0)\)</span> compute <span class="math inline">\(v(\epsilon/2)\)</span>:</li>
</ol>
<p><span class="math display">\[
v(\epsilon/2) = v(0) - (\epsilon/2) \nabla_x E(x(0))
\]</span></p>
<ol start="2" type="1">
<li>Loop over <span class="math inline">\(T-1\)</span> integration steps:</li>
</ol>
<p><span class="math display">\[\begin{align}
\begin{split}
x(t+\epsilon) &amp;= x(t) + \epsilon v(t+\epsilon/2) \\
v(t+3\epsilon/2) &amp;= v(t+\epsilon/2) - \epsilon \nabla_x E(x(t+\epsilon)) \\
\end{split}
\end{align}\]</span></p>
<ol start="3" type="1">
<li>Last full-step in <span class="math inline">\(x\)</span> and half-step in <span class="math inline">\(v\)</span>:</li>
</ol>
<p><span class="math display">\[\begin{align}
\begin{split}
x(T) &amp;= x(T-\epsilon) + \epsilon v(T-\epsilon/2)\\
v(T) &amp;= v(T-\epsilon/2) - (\epsilon/2) \nabla_x E(x(T)) \\
\end{split}
\end{align}\]</span></p>
<p>Resulting in <span class="math inline">\(T+1\)</span> gradient evaluations, whereas the original scheme requires two gradient evaluations per time step.</p>
<p>The following demonstration illustrates leapfrog integration for the harmonic oscillator:</p>
<div class="cell" data-execution_count="65">
<div class="sourceCode cell-code" id="cb81"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> leapfrog(x0, v0, eps, gradient, n_steps):</span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Leapfrog integration</span></span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a>    x, v <span class="op">=</span> x0, v0</span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a>    v <span class="op">-=</span> <span class="fl">0.5</span> <span class="op">*</span> eps <span class="op">*</span> gradient(x)</span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n_steps<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb81-8"><a href="#cb81-8" aria-hidden="true" tabindex="-1"></a>        x <span class="op">+=</span> eps <span class="op">*</span> v</span>
<span id="cb81-9"><a href="#cb81-9" aria-hidden="true" tabindex="-1"></a>        v <span class="op">-=</span> eps <span class="op">*</span> gradient(x)</span>
<span id="cb81-10"><a href="#cb81-10" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb81-11"><a href="#cb81-11" aria-hidden="true" tabindex="-1"></a>    x <span class="op">+=</span> eps <span class="op">*</span> v</span>
<span id="cb81-12"><a href="#cb81-12" aria-hidden="true" tabindex="-1"></a>    v <span class="op">-=</span> <span class="fl">0.5</span> <span class="op">*</span> eps <span class="op">*</span> gradient(x)</span>
<span id="cb81-13"><a href="#cb81-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-14"><a href="#cb81-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x, v</span>
<span id="cb81-15"><a href="#cb81-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-16"><a href="#cb81-16" aria-hidden="true" tabindex="-1"></a><span class="co"># comparison of leapfrog with analytical solution</span></span>
<span id="cb81-17"><a href="#cb81-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-18"><a href="#cb81-18" aria-hidden="true" tabindex="-1"></a>x0 <span class="op">=</span> <span class="fl">10.</span></span>
<span id="cb81-19"><a href="#cb81-19" aria-hidden="true" tabindex="-1"></a>v0 <span class="op">=</span> np.random.standard_normal()</span>
<span id="cb81-20"><a href="#cb81-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-21"><a href="#cb81-21" aria-hidden="true" tabindex="-1"></a>n_steps <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb81-22"><a href="#cb81-22" aria-hidden="true" tabindex="-1"></a>eps <span class="op">=</span> <span class="fl">1e-1</span></span>
<span id="cb81-23"><a href="#cb81-23" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> eps <span class="op">*</span> n_steps</span>
<span id="cb81-24"><a href="#cb81-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-25"><a href="#cb81-25" aria-hidden="true" tabindex="-1"></a>traj <span class="op">=</span> [(x0, v0)]</span>
<span id="cb81-26"><a href="#cb81-26" aria-hidden="true" tabindex="-1"></a>traj2 <span class="op">=</span> [(x0, v0)]</span>
<span id="cb81-27"><a href="#cb81-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-28"><a href="#cb81-28" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="bu">len</span>(traj) <span class="op">&lt;</span> <span class="dv">30</span>:</span>
<span id="cb81-29"><a href="#cb81-29" aria-hidden="true" tabindex="-1"></a>    x0, v0 <span class="op">=</span> traj[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb81-30"><a href="#cb81-30" aria-hidden="true" tabindex="-1"></a>    x, v <span class="op">=</span> leapfrog(x0, v0, eps, osci.gradient, n_steps)</span>
<span id="cb81-31"><a href="#cb81-31" aria-hidden="true" tabindex="-1"></a>    traj.append((x, v))</span>
<span id="cb81-32"><a href="#cb81-32" aria-hidden="true" tabindex="-1"></a>    x0, v0 <span class="op">=</span> traj2[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb81-33"><a href="#cb81-33" aria-hidden="true" tabindex="-1"></a>    traj2.append(osci.propagate(x0, v0, T))</span>
<span id="cb81-34"><a href="#cb81-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-35"><a href="#cb81-35" aria-hidden="true" tabindex="-1"></a>traj <span class="op">=</span> np.array(traj)</span>
<span id="cb81-36"><a href="#cb81-36" aria-hidden="true" tabindex="-1"></a>traj2 <span class="op">=</span> np.array(traj2)</span>
<span id="cb81-37"><a href="#cb81-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-38"><a href="#cb81-38" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">4</span>))</span>
<span id="cb81-39"><a href="#cb81-39" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].plot(<span class="op">*</span>traj.T, color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb81-40"><a href="#cb81-40" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].scatter(<span class="op">*</span>traj.T, c<span class="op">=</span>np.linspace(<span class="fl">0.</span>, <span class="fl">1.</span>, <span class="bu">len</span>(traj)))</span>
<span id="cb81-41"><a href="#cb81-41" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_xlabel(<span class="vs">r'$x(t)$'</span>)</span>
<span id="cb81-42"><a href="#cb81-42" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_ylabel(<span class="vs">r'$v(t)$'</span>)</span>
<span id="cb81-43"><a href="#cb81-43" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb81-44"><a href="#cb81-44" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].plot(traj[:,<span class="dv">0</span>], color<span class="op">=</span><span class="st">'k'</span>, lw<span class="op">=</span><span class="dv">5</span>, alpha<span class="op">=</span><span class="fl">0.5</span>, label<span class="op">=</span><span class="st">'analytical'</span>)</span>
<span id="cb81-45"><a href="#cb81-45" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].plot(traj2[:,<span class="dv">0</span>], color<span class="op">=</span><span class="st">'r'</span>, label<span class="op">=</span><span class="st">'leapfrog'</span>)</span>
<span id="cb81-46"><a href="#cb81-46" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_ylim(<span class="op">-</span><span class="dv">11</span>, <span class="dv">11</span>)</span>
<span id="cb81-47"><a href="#cb81-47" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlabel(<span class="vs">r'$t$'</span>)</span>
<span id="cb81-48"><a href="#cb81-48" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_ylabel(<span class="vs">r'$x(t)$'</span>)</span>
<span id="cb81-49"><a href="#cb81-49" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].legend(fontsize<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb81-50"><a href="#cb81-50" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb81-51"><a href="#cb81-51" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].plot(traj[:,<span class="dv">1</span>], color<span class="op">=</span><span class="st">'k'</span>, lw<span class="op">=</span><span class="dv">5</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb81-52"><a href="#cb81-52" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].plot(traj2[:,<span class="dv">1</span>], color<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb81-53"><a href="#cb81-53" aria-hidden="true" tabindex="-1"></a><span class="co">#ax[2].set_ylim(-11, 11)</span></span>
<span id="cb81-54"><a href="#cb81-54" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].set_xlabel(<span class="vs">r'$t$'</span>)</span>
<span id="cb81-55"><a href="#cb81-55" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].set_ylabel(<span class="vs">r'$v(t)$'</span>)</span>
<span id="cb81-56"><a href="#cb81-56" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb81-57"><a href="#cb81-57" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()                             </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-66-output-1.png" width="1123" height="356"></p>
</div>
</div>
<section id="comparison-to-other-integration-methods" class="level3">
<h3 class="anchored" data-anchor-id="comparison-to-other-integration-methods">Comparison to other integration methods</h3>
<p>In his review on HMC, Radford Neal compares the leapfrog integrator with other integration methods such as Euler. The following code reproduces his figure 1</p>
<div class="cell" data-execution_count="66">
<div class="sourceCode cell-code" id="cb82"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="co">"""</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a><span class="co">Implementation of examples from Neal's HMC review</span></span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a><span class="co">"""</span></span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> integrate(transformation, n_steps, q0, p0):</span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Integrate Hamilton's equations of motion for the one-dimensional </span></span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true" tabindex="-1"></a><span class="co">    harmonic oscillator using a transformation matrix that implements a</span></span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true" tabindex="-1"></a><span class="co">    numerical integration method. </span></span>
<span id="cb82-9"><a href="#cb82-9" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb82-10"><a href="#cb82-10" aria-hidden="true" tabindex="-1"></a>    z <span class="op">=</span> np.array([q0, p0])</span>
<span id="cb82-11"><a href="#cb82-11" aria-hidden="true" tabindex="-1"></a>    traj <span class="op">=</span> [z]</span>
<span id="cb82-12"><a href="#cb82-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n_steps):</span>
<span id="cb82-13"><a href="#cb82-13" aria-hidden="true" tabindex="-1"></a>        z <span class="op">=</span> transformation <span class="op">@</span> z</span>
<span id="cb82-14"><a href="#cb82-14" aria-hidden="true" tabindex="-1"></a>        traj.append(z)</span>
<span id="cb82-15"><a href="#cb82-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array(traj)</span>
<span id="cb82-16"><a href="#cb82-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-17"><a href="#cb82-17" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> euler(eps, n_steps, q0<span class="op">=</span><span class="fl">0.</span>, p0<span class="op">=</span><span class="fl">1.</span>):</span>
<span id="cb82-18"><a href="#cb82-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># q(t+eps) = q(t) + eps * p(t)</span></span>
<span id="cb82-19"><a href="#cb82-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># p(t+eps) = p(t) - eps * q(t)</span></span>
<span id="cb82-20"><a href="#cb82-20" aria-hidden="true" tabindex="-1"></a>    T <span class="op">=</span> np.array([[<span class="dv">1</span>, eps],</span>
<span id="cb82-21"><a href="#cb82-21" aria-hidden="true" tabindex="-1"></a>                  [<span class="op">-</span>eps, <span class="dv">1</span>]])</span>
<span id="cb82-22"><a href="#cb82-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> integrate(T, n_steps, q0, p0), T</span>
<span id="cb82-23"><a href="#cb82-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-24"><a href="#cb82-24" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> modified_euler(eps, n_steps, q0<span class="op">=</span><span class="fl">0.</span>, p0<span class="op">=</span><span class="fl">1.</span>):</span>
<span id="cb82-25"><a href="#cb82-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># p(t+eps) = p(t) - eps * q(t)</span></span>
<span id="cb82-26"><a href="#cb82-26" aria-hidden="true" tabindex="-1"></a>    T1 <span class="op">=</span> np.array([[<span class="dv">1</span>, <span class="fl">0.</span>],</span>
<span id="cb82-27"><a href="#cb82-27" aria-hidden="true" tabindex="-1"></a>                   [<span class="op">-</span>eps, <span class="dv">1</span>]])</span>
<span id="cb82-28"><a href="#cb82-28" aria-hidden="true" tabindex="-1"></a>    <span class="co"># q(t+eps) = q(t) + eps * p(t+eps)    </span></span>
<span id="cb82-29"><a href="#cb82-29" aria-hidden="true" tabindex="-1"></a>    T2 <span class="op">=</span> np.array([[<span class="dv">1</span>, eps],</span>
<span id="cb82-30"><a href="#cb82-30" aria-hidden="true" tabindex="-1"></a>                   [<span class="dv">0</span>, <span class="dv">1</span>]])</span>
<span id="cb82-31"><a href="#cb82-31" aria-hidden="true" tabindex="-1"></a>    T <span class="op">=</span> T2 <span class="op">@</span> T1</span>
<span id="cb82-32"><a href="#cb82-32" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb82-33"><a href="#cb82-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> integrate(T, n_steps, q0, p0), T</span>
<span id="cb82-34"><a href="#cb82-34" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb82-35"><a href="#cb82-35" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> leapfrog(eps, n_steps, q0<span class="op">=</span><span class="fl">0.</span>, p0<span class="op">=</span><span class="fl">1.</span>):</span>
<span id="cb82-36"><a href="#cb82-36" aria-hidden="true" tabindex="-1"></a>    <span class="co"># p(t+eps/2) = p(t) - (eps/2) * q(t)</span></span>
<span id="cb82-37"><a href="#cb82-37" aria-hidden="true" tabindex="-1"></a>    T1 <span class="op">=</span> np.array([[<span class="dv">1</span>, <span class="dv">0</span>],</span>
<span id="cb82-38"><a href="#cb82-38" aria-hidden="true" tabindex="-1"></a>                   [<span class="op">-</span>eps<span class="op">/</span><span class="dv">2</span>, <span class="dv">1</span>]])</span>
<span id="cb82-39"><a href="#cb82-39" aria-hidden="true" tabindex="-1"></a>    <span class="co"># q(t+eps) = q(t) + eps * p(t+eps/2)</span></span>
<span id="cb82-40"><a href="#cb82-40" aria-hidden="true" tabindex="-1"></a>    T2 <span class="op">=</span> np.array([[<span class="dv">1</span>, eps],</span>
<span id="cb82-41"><a href="#cb82-41" aria-hidden="true" tabindex="-1"></a>                   [<span class="dv">0</span>, <span class="dv">1</span>]])</span>
<span id="cb82-42"><a href="#cb82-42" aria-hidden="true" tabindex="-1"></a>    <span class="co"># p(t+eps) = p(t+eps/2) - (eps/2) * q(t+eps)</span></span>
<span id="cb82-43"><a href="#cb82-43" aria-hidden="true" tabindex="-1"></a>    T3 <span class="op">=</span> T1</span>
<span id="cb82-44"><a href="#cb82-44" aria-hidden="true" tabindex="-1"></a>    T <span class="op">=</span> T3 <span class="op">@</span> T2 <span class="op">@</span> T1</span>
<span id="cb82-45"><a href="#cb82-45" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb82-46"><a href="#cb82-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> integrate(T, n_steps, q0, p0), T</span>
<span id="cb82-47"><a href="#cb82-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-48"><a href="#cb82-48" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################</span></span>
<span id="cb82-49"><a href="#cb82-49" aria-hidden="true" tabindex="-1"></a><span class="co">## run all three integrators</span></span>
<span id="cb82-50"><a href="#cb82-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-51"><a href="#cb82-51" aria-hidden="true" tabindex="-1"></a>eps <span class="op">=</span> (<span class="fl">0.3</span>, <span class="fl">1.2</span>, <span class="fl">0.1</span>)[<span class="dv">0</span>]</span>
<span id="cb82-52"><a href="#cb82-52" aria-hidden="true" tabindex="-1"></a>n_steps <span class="op">=</span> <span class="bu">int</span>(np.floor(<span class="dv">2</span><span class="op">*</span>np.pi<span class="op">/</span>eps))</span>
<span id="cb82-53"><a href="#cb82-53" aria-hidden="true" tabindex="-1"></a>n_steps <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb82-54"><a href="#cb82-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-55"><a href="#cb82-55" aria-hidden="true" tabindex="-1"></a>z1, T1 <span class="op">=</span> euler(eps, n_steps)</span>
<span id="cb82-56"><a href="#cb82-56" aria-hidden="true" tabindex="-1"></a>z2, T2 <span class="op">=</span> modified_euler(eps, n_steps)</span>
<span id="cb82-57"><a href="#cb82-57" aria-hidden="true" tabindex="-1"></a>z3, T3 <span class="op">=</span> leapfrog(eps, n_steps)</span>
<span id="cb82-58"><a href="#cb82-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-59"><a href="#cb82-59" aria-hidden="true" tabindex="-1"></a>methods <span class="op">=</span> (<span class="st">'Euler'</span>, <span class="st">'modified Euler'</span>, <span class="st">'Leapfrog'</span>)</span>
<span id="cb82-60"><a href="#cb82-60" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Volume preservation?'</span>)</span>
<span id="cb82-61"><a href="#cb82-61" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> method, trafo <span class="kw">in</span> <span class="bu">zip</span>(methods, [T1, T2, T3]):</span>
<span id="cb82-62"><a href="#cb82-62" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">'</span><span class="sc">{0:&gt;14}</span><span class="st">: det(trafo) = </span><span class="sc">{1:.3f}</span><span class="st">'</span>.<span class="bu">format</span>(method, np.linalg.det(trafo)))</span>
<span id="cb82-63"><a href="#cb82-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-64"><a href="#cb82-64" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################</span></span>
<span id="cb82-65"><a href="#cb82-65" aria-hidden="true" tabindex="-1"></a><span class="co">## plot trajectories</span></span>
<span id="cb82-66"><a href="#cb82-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-67"><a href="#cb82-67" aria-hidden="true" tabindex="-1"></a><span class="co"># exact dynamics</span></span>
<span id="cb82-68"><a href="#cb82-68" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.sin(eps <span class="op">*</span> np.arange(n_steps<span class="op">+</span><span class="dv">1</span>))</span>
<span id="cb82-69"><a href="#cb82-69" aria-hidden="true" tabindex="-1"></a>v <span class="op">=</span> np.cos(eps <span class="op">*</span> np.arange(n_steps<span class="op">+</span><span class="dv">1</span>))</span>
<span id="cb82-70"><a href="#cb82-70" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb82-71"><a href="#cb82-71" aria-hidden="true" tabindex="-1"></a>limits <span class="op">=</span> np.fabs(z1).<span class="bu">max</span>() <span class="op">*</span> <span class="fl">1.1</span></span>
<span id="cb82-72"><a href="#cb82-72" aria-hidden="true" tabindex="-1"></a>limits <span class="op">=</span> (<span class="op">-</span>limits, limits)</span>
<span id="cb82-73"><a href="#cb82-73" aria-hidden="true" tabindex="-1"></a>plt.rc(<span class="st">'font'</span>, size<span class="op">=</span><span class="dv">12</span>)</span>
<span id="cb82-74"><a href="#cb82-74" aria-hidden="true" tabindex="-1"></a>plt.rc(<span class="st">'image'</span>, cmap<span class="op">=</span><span class="st">'viridis'</span>)</span>
<span id="cb82-75"><a href="#cb82-75" aria-hidden="true" tabindex="-1"></a>kw <span class="op">=</span> <span class="bu">dict</span>(aspect<span class="op">=</span><span class="fl">1.0</span>, xlim<span class="op">=</span>limits, ylim<span class="op">=</span>limits, xlabel<span class="op">=</span><span class="vs">r'$x^{(s)}$'</span>)</span>
<span id="cb82-76"><a href="#cb82-76" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">4</span>), sharey<span class="op">=</span><span class="st">'all'</span>, sharex<span class="op">=</span><span class="st">'all'</span>,</span>
<span id="cb82-77"><a href="#cb82-77" aria-hidden="true" tabindex="-1"></a>                         subplot_kw<span class="op">=</span>kw)</span>
<span id="cb82-78"><a href="#cb82-78" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_ylabel(<span class="vs">r'$v^{(s)}$'</span>)</span>
<span id="cb82-79"><a href="#cb82-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-80"><a href="#cb82-80" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ax, method, z <span class="kw">in</span> <span class="bu">zip</span>(axes, methods, [z1, z2, z3]):</span>
<span id="cb82-81"><a href="#cb82-81" aria-hidden="true" tabindex="-1"></a>    ax.set_title(method)</span>
<span id="cb82-82"><a href="#cb82-82" aria-hidden="true" tabindex="-1"></a>    ax.scatter(<span class="op">*</span>z.T, c<span class="op">=</span>np.linspace(<span class="fl">0.</span>, <span class="fl">1.</span>, n_steps<span class="op">+</span><span class="dv">1</span>))</span>
<span id="cb82-83"><a href="#cb82-83" aria-hidden="true" tabindex="-1"></a>    ax.plot(<span class="op">*</span>z.T, ls<span class="op">=</span><span class="st">'--'</span>, color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb82-84"><a href="#cb82-84" aria-hidden="true" tabindex="-1"></a>    ax.plot(x, v, color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.3</span>, lw<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb82-85"><a href="#cb82-85" aria-hidden="true" tabindex="-1"></a>    ax.scatter(x, v, c<span class="op">=</span>np.linspace(<span class="fl">0.</span>, <span class="fl">1.</span>, n_steps<span class="op">+</span><span class="dv">1</span>), marker<span class="op">=</span><span class="st">'*'</span>)</span>
<span id="cb82-86"><a href="#cb82-86" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Volume preservation?
         Euler: det(trafo) = 1.090
modified Euler: det(trafo) = 1.000
      Leapfrog: det(trafo) = 1.000</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-67-output-2.png" width="1107" height="399"></p>
</div>
</div>
</section>
</section>
<section id="hamiltonian-monte-carlo-1" class="level2">
<h2 class="anchored" data-anchor-id="hamiltonian-monte-carlo-1">Hamiltonian Monte Carlo</h2>
<p>Hamiltonian Monte Carlo uses the leapfrog integrator to solve Hamilton’s equations of motion. The resulting proposal state is then accepted or rejected according to the Metropolis-Hastings criterion on the augmented <span class="math inline">\((x, v)\)</span> space (phase space). That is, we accept the new state with probability</p>
<p><span class="math display">\[
\min\left\{1, \exp(-\Delta H)\right\}
\]</span></p>
<p>which holds since Hamiltonian dynamics and the leapfrog integrator preserve volume (otherwise we would have to take into account the proposal probabilities for the forward and backward dynamics).</p>
<section id="algorithm-hamiltonian-monte-carlo" class="level3">
<h3 class="anchored" data-anchor-id="algorithm-hamiltonian-monte-carlo">Algorithm: Hamiltonian Monte Carlo</h3>
<p>Generate an initial state <span class="math inline">\(x^{(0)} \sim p^{(0)}(x)\)</span> using some initial distribution. For <span class="math inline">\(s=0, 1, 2, \ldots\)</span> cycle over the following iterations</p>
<p>We have to negate the momenta at the end of the trajectory to make the proposal symmetric. Since Hamiltonian dynamics is reversible, flipping the sign of the momenta guarantees that if we reach <span class="math inline">\((x', v')\)</span> starting from <span class="math inline">\((x, v)\)</span> with Hamiltonian dynamics, then we will go back to <span class="math inline">\((x, v)\)</span> using a dynamics that starts from <span class="math inline">\((x', -v')\)</span>.</p>
<div class="cell" data-execution_count="67">
<div class="sourceCode cell-code" id="cb84"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> store(args, storage<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> storage <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a>        storage.append([np.copy(arg) <span class="cf">for</span> arg <span class="kw">in</span> args])</span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> leapfrog(x, v, gradient, eps, n_steps, traj<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Leapfrog integration</span></span>
<span id="cb84-8"><a href="#cb84-8" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb84-9"><a href="#cb84-9" aria-hidden="true" tabindex="-1"></a>    store([x, v], traj)</span>
<span id="cb84-10"><a href="#cb84-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n_steps):</span>
<span id="cb84-11"><a href="#cb84-11" aria-hidden="true" tabindex="-1"></a>        v <span class="op">-=</span> (eps<span class="op">/</span><span class="dv">2</span>) <span class="op">*</span> gradient(x)</span>
<span id="cb84-12"><a href="#cb84-12" aria-hidden="true" tabindex="-1"></a>        x <span class="op">+=</span> eps <span class="op">*</span> v</span>
<span id="cb84-13"><a href="#cb84-13" aria-hidden="true" tabindex="-1"></a>        v <span class="op">-=</span> (eps<span class="op">/</span><span class="dv">2</span>) <span class="op">*</span> gradient(x)</span>
<span id="cb84-14"><a href="#cb84-14" aria-hidden="true" tabindex="-1"></a>        store([x, v], traj)</span>
<span id="cb84-15"><a href="#cb84-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x, v</span>
<span id="cb84-16"><a href="#cb84-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-17"><a href="#cb84-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-18"><a href="#cb84-18" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> CoupledOscillator:</span>
<span id="cb84-19"><a href="#cb84-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Coupled oscillator with force constants stored in attribute 'K'"""</span></span>
<span id="cb84-20"><a href="#cb84-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, K):</span>
<span id="cb84-21"><a href="#cb84-21" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.K <span class="op">=</span> np.array(K)</span>
<span id="cb84-22"><a href="#cb84-22" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.v, <span class="va">self</span>.U <span class="op">=</span> np.linalg.eigh(<span class="va">self</span>.K)</span>
<span id="cb84-23"><a href="#cb84-23" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.w <span class="op">=</span> np.sqrt(np.clip(<span class="va">self</span>.v, <span class="fl">0.</span>, <span class="va">None</span>))</span>
<span id="cb84-24"><a href="#cb84-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-25"><a href="#cb84-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> propagate(<span class="va">self</span>, x, v, eps):</span>
<span id="cb84-26"><a href="#cb84-26" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Move system from (x, v) to new state using Hamiltonian dynamics."""</span></span>
<span id="cb84-27"><a href="#cb84-27" aria-hidden="true" tabindex="-1"></a>        x, v <span class="op">=</span> <span class="va">self</span>.U.T <span class="op">@</span> x, <span class="va">self</span>.U.T <span class="op">@</span> v</span>
<span id="cb84-28"><a href="#cb84-28" aria-hidden="true" tabindex="-1"></a>        X <span class="op">=</span> np.cos(<span class="va">self</span>.w<span class="op">*</span>eps) <span class="op">*</span> x <span class="op">+</span> np.sin(<span class="va">self</span>.w<span class="op">*</span>eps) <span class="op">/</span> <span class="va">self</span>.w <span class="op">*</span> v</span>
<span id="cb84-29"><a href="#cb84-29" aria-hidden="true" tabindex="-1"></a>        V <span class="op">=</span> <span class="op">-</span>np.sin(<span class="va">self</span>.w<span class="op">*</span>eps) <span class="op">*</span> <span class="va">self</span>.w <span class="op">*</span> x <span class="op">+</span> np.cos(<span class="va">self</span>.w<span class="op">*</span>eps) <span class="op">*</span> v</span>
<span id="cb84-30"><a href="#cb84-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.U <span class="op">@</span> X, <span class="va">self</span>.U <span class="op">@</span> V</span>
<span id="cb84-31"><a href="#cb84-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb84-32"><a href="#cb84-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> energy(<span class="va">self</span>, x):</span>
<span id="cb84-33"><a href="#cb84-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="fl">0.5</span> <span class="op">*</span> np.<span class="bu">sum</span>(x <span class="op">*</span> (x <span class="op">@</span> <span class="va">self</span>.K), <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb84-34"><a href="#cb84-34" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb84-35"><a href="#cb84-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> gradient(<span class="va">self</span>, x):</span>
<span id="cb84-36"><a href="#cb84-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> x <span class="op">@</span> <span class="va">self</span>.K</span>
<span id="cb84-37"><a href="#cb84-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-38"><a href="#cb84-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> hamiltonian(<span class="va">self</span>, x, v):</span>
<span id="cb84-39"><a href="#cb84-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.energy(x) <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> np.linalg.norm(v, axis<span class="op">=-</span><span class="dv">1</span>)<span class="op">**</span><span class="dv">2</span></span>
<span id="cb84-40"><a href="#cb84-40" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb84-41"><a href="#cb84-41" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> covariance_matrix(sigma1<span class="op">=</span><span class="fl">1.</span>, sigma2<span class="op">=</span><span class="fl">1.</span>, rho<span class="op">=</span><span class="fl">0.</span>):</span>
<span id="cb84-42"><a href="#cb84-42" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Build two-dimensional covariance matrix. </span></span>
<span id="cb84-43"><a href="#cb84-43" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb84-44"><a href="#cb84-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> <span class="op">-</span><span class="fl">1.</span> <span class="op">&lt;=</span> rho <span class="op">&lt;=</span> <span class="fl">1.</span></span>
<span id="cb84-45"><a href="#cb84-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-46"><a href="#cb84-46" aria-hidden="true" tabindex="-1"></a>    Sigma <span class="op">=</span> np.diag([sigma1, sigma2]) <span class="op">\</span></span>
<span id="cb84-47"><a href="#cb84-47" aria-hidden="true" tabindex="-1"></a>            <span class="op">@</span> np.array([[<span class="dv">1</span>, rho], [rho, <span class="dv">1</span>]]) <span class="op">\</span></span>
<span id="cb84-48"><a href="#cb84-48" aria-hidden="true" tabindex="-1"></a>            <span class="op">@</span> np.diag([sigma1, sigma2])</span>
<span id="cb84-49"><a href="#cb84-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-50"><a href="#cb84-50" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> Sigma</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="68">
<div class="sourceCode cell-code" id="cb85"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a>sigma1, sigma2, rho <span class="op">=</span> <span class="fl">1.</span>, <span class="fl">1.</span>, <span class="fl">0.95</span></span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> np.linalg.inv(covariance_matrix(sigma1, sigma2, rho))</span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a>osci <span class="op">=</span> CoupledOscillator(K)</span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true" tabindex="-1"></a><span class="co"># start position and velocity</span></span>
<span id="cb85-6"><a href="#cb85-6" aria-hidden="true" tabindex="-1"></a>x0 <span class="op">=</span> np.array([<span class="op">-</span><span class="fl">1.5</span>, <span class="op">-</span><span class="fl">1.55</span>])</span>
<span id="cb85-7"><a href="#cb85-7" aria-hidden="true" tabindex="-1"></a>v0 <span class="op">=</span> np.array([<span class="op">-</span><span class="fl">1.</span>, <span class="dv">1</span>])</span>
<span id="cb85-8"><a href="#cb85-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb85-9"><a href="#cb85-9" aria-hidden="true" tabindex="-1"></a>n_steps, eps <span class="op">=</span> <span class="dv">250</span>, <span class="fl">0.035</span></span>
<span id="cb85-10"><a href="#cb85-10" aria-hidden="true" tabindex="-1"></a>n_steps, eps <span class="op">=</span> <span class="dv">25</span>, <span class="fl">0.25</span></span>
<span id="cb85-11"><a href="#cb85-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-12"><a href="#cb85-12" aria-hidden="true" tabindex="-1"></a>xvals1 <span class="op">=</span> xvals2 <span class="op">=</span> np.linspace(<span class="op">-</span><span class="fl">1.</span>, <span class="fl">1.</span>, <span class="dv">101</span>) <span class="op">*</span> <span class="fl">2.5</span></span>
<span id="cb85-13"><a href="#cb85-13" aria-hidden="true" tabindex="-1"></a>X1, X2 <span class="op">=</span> np.meshgrid(xvals1, xvals2, indexing<span class="op">=</span><span class="st">'ij'</span>)</span>
<span id="cb85-14"><a href="#cb85-14" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> np.transpose([X1.flatten(), X2.flatten()])</span>
<span id="cb85-15"><a href="#cb85-15" aria-hidden="true" tabindex="-1"></a>logp <span class="op">=</span> <span class="op">-</span>osci.energy(grid).reshape(<span class="bu">len</span>(xvals1), <span class="bu">len</span>(xvals2))</span>
<span id="cb85-16"><a href="#cb85-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-17"><a href="#cb85-17" aria-hidden="true" tabindex="-1"></a><span class="co"># exact dynamics</span></span>
<span id="cb85-18"><a href="#cb85-18" aria-hidden="true" tabindex="-1"></a>traj1 <span class="op">=</span> [(x0, v0)]</span>
<span id="cb85-19"><a href="#cb85-19" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="bu">len</span>(traj1) <span class="op">&lt;</span> n_steps <span class="op">+</span> <span class="dv">1</span>:</span>
<span id="cb85-20"><a href="#cb85-20" aria-hidden="true" tabindex="-1"></a>    traj1.append(osci.propagate(<span class="op">*</span>traj1[<span class="op">-</span><span class="dv">1</span>], eps<span class="op">=</span>eps))</span>
<span id="cb85-21"><a href="#cb85-21" aria-hidden="true" tabindex="-1"></a>x1, v1 <span class="op">=</span> np.array(<span class="bu">list</span>(<span class="bu">zip</span>(<span class="op">*</span>traj1)))</span>
<span id="cb85-22"><a href="#cb85-22" aria-hidden="true" tabindex="-1"></a>H1 <span class="op">=</span> osci.hamiltonian(x1, v1)</span>
<span id="cb85-23"><a href="#cb85-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-24"><a href="#cb85-24" aria-hidden="true" tabindex="-1"></a><span class="co"># leapfrog integration</span></span>
<span id="cb85-25"><a href="#cb85-25" aria-hidden="true" tabindex="-1"></a>traj2 <span class="op">=</span> []</span>
<span id="cb85-26"><a href="#cb85-26" aria-hidden="true" tabindex="-1"></a>leapfrog(x0, v0, osci.gradient, eps, n_steps, traj2)</span>
<span id="cb85-27"><a href="#cb85-27" aria-hidden="true" tabindex="-1"></a>x2, v2 <span class="op">=</span> np.array(<span class="bu">list</span>(<span class="bu">zip</span>(<span class="op">*</span>traj2)))</span>
<span id="cb85-28"><a href="#cb85-28" aria-hidden="true" tabindex="-1"></a>H2 <span class="op">=</span> osci.hamiltonian(x2, v2)</span>
<span id="cb85-29"><a href="#cb85-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-30"><a href="#cb85-30" aria-hidden="true" tabindex="-1"></a><span class="co"># plot</span></span>
<span id="cb85-31"><a href="#cb85-31" aria-hidden="true" tabindex="-1"></a>plt.rc(<span class="st">'font'</span>, size<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb85-32"><a href="#cb85-32" aria-hidden="true" tabindex="-1"></a>limits <span class="op">=</span> (<span class="op">-</span><span class="fl">2.2</span>, <span class="fl">2.2</span>)</span>
<span id="cb85-33"><a href="#cb85-33" aria-hidden="true" tabindex="-1"></a>kw <span class="op">=</span> <span class="bu">dict</span>(xlim<span class="op">=</span>limits, ylim<span class="op">=</span>limits, aspect<span class="op">=</span><span class="fl">1.0</span>)</span>
<span id="cb85-34"><a href="#cb85-34" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">9</span>, <span class="dv">9</span>), sharex<span class="op">=</span><span class="st">'col'</span>, </span>
<span id="cb85-35"><a href="#cb85-35" aria-hidden="true" tabindex="-1"></a>                         sharey<span class="op">=</span><span class="st">'all'</span>, subplot_kw<span class="op">=</span>kw)</span>
<span id="cb85-36"><a href="#cb85-36" aria-hidden="true" tabindex="-1"></a>axes <span class="op">=</span> <span class="bu">list</span>(axes.flat)</span>
<span id="cb85-37"><a href="#cb85-37" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ax, x <span class="kw">in</span> <span class="bu">zip</span>(axes, [x1, v1, x2, v2]):</span>
<span id="cb85-38"><a href="#cb85-38" aria-hidden="true" tabindex="-1"></a>    ax.plot(<span class="op">*</span>x.T, color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb85-39"><a href="#cb85-39" aria-hidden="true" tabindex="-1"></a>    ax.scatter(<span class="op">*</span>x.T, s<span class="op">=</span><span class="dv">10</span>, c<span class="op">=</span>np.linspace(<span class="fl">0.</span>, <span class="fl">1.</span>, <span class="bu">len</span>(x)))</span>
<span id="cb85-40"><a href="#cb85-40" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>].set_xlabel(<span class="vs">r'$x_1$'</span>)</span>
<span id="cb85-41"><a href="#cb85-41" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>].set_ylabel(<span class="vs">r'$x_2$'</span>)</span>
<span id="cb85-42"><a href="#cb85-42" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_ylabel(<span class="vs">r'$x_2$'</span>)</span>
<span id="cb85-43"><a href="#cb85-43" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">3</span>].set_xlabel(<span class="vs">r'$v_1$'</span>)</span>
<span id="cb85-44"><a href="#cb85-44" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">3</span>].set_ylabel(<span class="vs">r'$v_2$'</span>)</span>
<span id="cb85-45"><a href="#cb85-45" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].set_ylabel(<span class="vs">r'$v_2$'</span>)</span>
<span id="cb85-46"><a href="#cb85-46" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ax <span class="kw">in</span> axes[:<span class="dv">2</span>]:</span>
<span id="cb85-47"><a href="#cb85-47" aria-hidden="true" tabindex="-1"></a>    ax.set_title(<span class="st">'exact dynamics'</span>)</span>
<span id="cb85-48"><a href="#cb85-48" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ax <span class="kw">in</span> axes[<span class="op">-</span><span class="dv">2</span>:]:</span>
<span id="cb85-49"><a href="#cb85-49" aria-hidden="true" tabindex="-1"></a>    ax.set_title(<span class="st">'leapfrog'</span>)</span>
<span id="cb85-50"><a href="#cb85-50" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].contour(xvals1, xvals2, np.exp(logp), <span class="dv">3</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb85-51"><a href="#cb85-51" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>].contour(xvals1, xvals2, np.exp(logp), <span class="dv">3</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb85-52"><a href="#cb85-52" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-69-output-1.png" width="828" height="839"></p>
</div>
</div>
<p>The exact dynamics conserves the Hamiltonian (as it should), whereas the leapfrog dynamics does not exactly preserve the Hamiltonian:</p>
<div class="cell" data-execution_count="69">
<div class="sourceCode cell-code" id="cb86"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>ax.plot(H1, lw<span class="op">=</span><span class="dv">3</span>, color<span class="op">=</span><span class="st">'r'</span>, ls<span class="op">=</span><span class="st">'-'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, label<span class="op">=</span><span class="st">'exact dynamics'</span>)</span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a>ax.plot(H2, lw<span class="op">=</span><span class="dv">3</span>, color<span class="op">=</span><span class="st">'k'</span>, ls<span class="op">=</span><span class="st">'--'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, marker<span class="op">=</span><span class="st">'o'</span>, label<span class="op">=</span><span class="st">'leapfrog'</span>)</span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="vs">r'time step $n\epsilon$'</span>)</span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="vs">r'Hamiltonian $H(x, v)$'</span>)</span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a>ax.set_ylim(<span class="fl">2.0</span>, <span class="fl">2.8</span>)</span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true" tabindex="-1"></a>ax.legend(loc<span class="op">=</span>(<span class="fl">1.1</span>, <span class="fl">0.5</span>))<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-70-output-1.png" width="906" height="456"></p>
</div>
</div>
</section>
<section id="comparison-with-standard-metropolis-hastings" class="level3">
<h3 class="anchored" data-anchor-id="comparison-with-standard-metropolis-hastings">Comparison with standard Metropolis-Hastings</h3>
<div class="cell" data-execution_count="70">
<div class="sourceCode cell-code" id="cb87"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Metropolis:</span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, model, state, n_samples<span class="op">=</span><span class="fl">1e2</span>, stepsize<span class="op">=</span><span class="fl">1e-1</span>):</span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.model <span class="op">=</span> model</span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.initial_state <span class="op">=</span> np.array(state)</span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.n_samples <span class="op">=</span> <span class="bu">int</span>(n_samples)</span>
<span id="cb87-7"><a href="#cb87-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.stepsize <span class="op">=</span> <span class="bu">float</span>(stepsize)</span>
<span id="cb87-8"><a href="#cb87-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._reset()</span>
<span id="cb87-9"><a href="#cb87-9" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb87-10"><a href="#cb87-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _reset(<span class="va">self</span>):</span>
<span id="cb87-11"><a href="#cb87-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.counter <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb87-12"><a href="#cb87-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.state <span class="op">=</span> <span class="va">self</span>.initial_state</span>
<span id="cb87-13"><a href="#cb87-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.n_accepted <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb87-14"><a href="#cb87-14" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb87-15"><a href="#cb87-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__next__</span>(<span class="va">self</span>):</span>
<span id="cb87-16"><a href="#cb87-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-17"><a href="#cb87-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.counter <span class="op">&gt;=</span> <span class="va">self</span>.n_samples:</span>
<span id="cb87-18"><a href="#cb87-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">StopIteration</span></span>
<span id="cb87-19"><a href="#cb87-19" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.counter <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb87-20"><a href="#cb87-20" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb87-21"><a href="#cb87-21" aria-hidden="true" tabindex="-1"></a>        <span class="co"># random walk </span></span>
<span id="cb87-22"><a href="#cb87-22" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.state.copy()</span>
<span id="cb87-23"><a href="#cb87-23" aria-hidden="true" tabindex="-1"></a>        X <span class="op">=</span> x <span class="op">+</span> <span class="va">self</span>.stepsize <span class="op">*</span> np.random.standard_normal(x.shape)</span>
<span id="cb87-24"><a href="#cb87-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-25"><a href="#cb87-25" aria-hidden="true" tabindex="-1"></a>        <span class="co"># accept/reject</span></span>
<span id="cb87-26"><a href="#cb87-26" aria-hidden="true" tabindex="-1"></a>        diff <span class="op">=</span> <span class="va">self</span>.model.energy(x) <span class="op">-</span> <span class="va">self</span>.model.energy(X)</span>
<span id="cb87-27"><a href="#cb87-27" aria-hidden="true" tabindex="-1"></a>        accept <span class="op">=</span> np.log(np.random.random()) <span class="op">&lt;</span> diff</span>
<span id="cb87-28"><a href="#cb87-28" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.n_accepted <span class="op">+=</span> <span class="bu">int</span>(accept)</span>
<span id="cb87-29"><a href="#cb87-29" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb87-30"><a href="#cb87-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> accept: <span class="va">self</span>.state <span class="op">=</span> X</span>
<span id="cb87-31"><a href="#cb87-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-32"><a href="#cb87-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.state</span>
<span id="cb87-33"><a href="#cb87-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-34"><a href="#cb87-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__iter__</span>(<span class="va">self</span>):</span>
<span id="cb87-35"><a href="#cb87-35" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._reset()</span>
<span id="cb87-36"><a href="#cb87-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span></span>
<span id="cb87-37"><a href="#cb87-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-38"><a href="#cb87-38" aria-hidden="true" tabindex="-1"></a>    <span class="at">@property</span></span>
<span id="cb87-39"><a href="#cb87-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> acceptance_rate(<span class="va">self</span>):</span>
<span id="cb87-40"><a href="#cb87-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.n_accepted <span class="op">/</span> <span class="va">self</span>.n_samples        </span>
<span id="cb87-41"><a href="#cb87-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-42"><a href="#cb87-42" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb87-43"><a href="#cb87-43" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> HamiltonianMonteCarlo(Metropolis):</span>
<span id="cb87-44"><a href="#cb87-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-45"><a href="#cb87-45" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, model, state, n_samples, eps, n_leapfrog):</span>
<span id="cb87-46"><a href="#cb87-46" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>(model, state, n_samples, eps)</span>
<span id="cb87-47"><a href="#cb87-47" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.n_leapfrog <span class="op">=</span> <span class="bu">int</span>(n_leapfrog)</span>
<span id="cb87-48"><a href="#cb87-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-49"><a href="#cb87-49" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__next__</span>(<span class="va">self</span>):</span>
<span id="cb87-50"><a href="#cb87-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-51"><a href="#cb87-51" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.counter <span class="op">&gt;=</span> <span class="va">self</span>.n_samples:</span>
<span id="cb87-52"><a href="#cb87-52" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">StopIteration</span></span>
<span id="cb87-53"><a href="#cb87-53" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.counter <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb87-54"><a href="#cb87-54" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb87-55"><a href="#cb87-55" aria-hidden="true" tabindex="-1"></a>        <span class="co"># leapfrog integration</span></span>
<span id="cb87-56"><a href="#cb87-56" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.state.copy()</span>
<span id="cb87-57"><a href="#cb87-57" aria-hidden="true" tabindex="-1"></a>        v <span class="op">=</span> np.random.standard_normal(x.shape)</span>
<span id="cb87-58"><a href="#cb87-58" aria-hidden="true" tabindex="-1"></a>        h <span class="op">=</span> <span class="va">self</span>.model.hamiltonian(x, v)</span>
<span id="cb87-59"><a href="#cb87-59" aria-hidden="true" tabindex="-1"></a>        X, V <span class="op">=</span> leapfrog(</span>
<span id="cb87-60"><a href="#cb87-60" aria-hidden="true" tabindex="-1"></a>            x, v, <span class="va">self</span>.model.gradient, <span class="va">self</span>.stepsize, <span class="va">self</span>.n_leapfrog)</span>
<span id="cb87-61"><a href="#cb87-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-62"><a href="#cb87-62" aria-hidden="true" tabindex="-1"></a>        <span class="co"># accept/reject</span></span>
<span id="cb87-63"><a href="#cb87-63" aria-hidden="true" tabindex="-1"></a>        H <span class="op">=</span> <span class="va">self</span>.model.hamiltonian(X, <span class="op">-</span>V)</span>
<span id="cb87-64"><a href="#cb87-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-65"><a href="#cb87-65" aria-hidden="true" tabindex="-1"></a>        accept <span class="op">=</span> np.log(np.random.random()) <span class="op">&lt;</span> h<span class="op">-</span>H</span>
<span id="cb87-66"><a href="#cb87-66" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.n_accepted <span class="op">+=</span> <span class="bu">int</span>(accept)</span>
<span id="cb87-67"><a href="#cb87-67" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb87-68"><a href="#cb87-68" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> accept: <span class="va">self</span>.state <span class="op">=</span> X</span>
<span id="cb87-69"><a href="#cb87-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-70"><a href="#cb87-70" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.state</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="71">
<div class="sourceCode cell-code" id="cb88"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 2d Gaussian</span></span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a>sigma1 <span class="op">=</span> sigma2 <span class="op">=</span> <span class="fl">1.</span></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a>rho <span class="op">=</span> <span class="fl">0.98</span></span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a>Sigma <span class="op">=</span> covariance_matrix(sigma1, sigma2, rho)</span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> CoupledOscillator(np.linalg.inv(Sigma))</span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true" tabindex="-1"></a><span class="co"># running HMC and random walk Metropolis</span></span>
<span id="cb88-8"><a href="#cb88-8" aria-hidden="true" tabindex="-1"></a>n_samples <span class="op">=</span> <span class="fl">1e3</span></span>
<span id="cb88-9"><a href="#cb88-9" aria-hidden="true" tabindex="-1"></a>eps, n_leapfrog <span class="op">=</span> <span class="fl">0.18</span>, <span class="dv">20</span></span>
<span id="cb88-10"><a href="#cb88-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-11"><a href="#cb88-11" aria-hidden="true" tabindex="-1"></a>initial <span class="op">=</span> np.array([<span class="op">-</span><span class="fl">1.55</span>, <span class="op">-</span><span class="fl">1.5</span>])</span>
<span id="cb88-12"><a href="#cb88-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-13"><a href="#cb88-13" aria-hidden="true" tabindex="-1"></a>hmc <span class="op">=</span> HamiltonianMonteCarlo(model, initial, n_samples, eps, n_leapfrog)</span>
<span id="cb88-14"><a href="#cb88-14" aria-hidden="true" tabindex="-1"></a>hmc_samples <span class="op">=</span> np.array(<span class="bu">list</span>(hmc))</span>
<span id="cb88-15"><a href="#cb88-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-16"><a href="#cb88-16" aria-hidden="true" tabindex="-1"></a><span class="co"># to be fair, we allow for 'n_leapfrog' more sampling steps in Metropolis </span></span>
<span id="cb88-17"><a href="#cb88-17" aria-hidden="true" tabindex="-1"></a><span class="co"># sampling</span></span>
<span id="cb88-18"><a href="#cb88-18" aria-hidden="true" tabindex="-1"></a>metro <span class="op">=</span> Metropolis(model, initial, n_samples <span class="op">*</span> n_leapfrog, eps)</span>
<span id="cb88-19"><a href="#cb88-19" aria-hidden="true" tabindex="-1"></a>metro_samples <span class="op">=</span> np.array(<span class="bu">list</span>(metro))[::n_leapfrog]</span>
<span id="cb88-20"><a href="#cb88-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-21"><a href="#cb88-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'acceptance_rate: </span><span class="sc">{0:.2%}</span><span class="st"> (HMC), </span><span class="sc">{1:.2%}</span><span class="st"> (Metropolis)'</span>.<span class="bu">format</span>(</span>
<span id="cb88-22"><a href="#cb88-22" aria-hidden="true" tabindex="-1"></a>    hmc.acceptance_rate, metro.acceptance_rate))</span>
<span id="cb88-23"><a href="#cb88-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-24"><a href="#cb88-24" aria-hidden="true" tabindex="-1"></a><span class="co"># plotting</span></span>
<span id="cb88-25"><a href="#cb88-25" aria-hidden="true" tabindex="-1"></a>burnin <span class="op">=</span> <span class="bu">int</span>(<span class="fl">0.1</span><span class="op">*</span>n_samples)</span>
<span id="cb88-26"><a href="#cb88-26" aria-hidden="true" tabindex="-1"></a>limits <span class="op">=</span> (<span class="op">-</span><span class="fl">3.5</span>, <span class="fl">3.5</span>)</span>
<span id="cb88-27"><a href="#cb88-27" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="op">*</span>limits, num<span class="op">=</span><span class="dv">101</span>)</span>
<span id="cb88-28"><a href="#cb88-28" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> np.meshgrid(x, x, indexing<span class="op">=</span><span class="st">'ij'</span>)</span>
<span id="cb88-29"><a href="#cb88-29" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> np.transpose([grid[<span class="dv">0</span>].flatten(), grid[<span class="dv">1</span>].flatten()])</span>
<span id="cb88-30"><a href="#cb88-30" aria-hidden="true" tabindex="-1"></a>prob <span class="op">=</span> np.exp(<span class="op">-</span>model.energy(grid)).reshape(<span class="bu">len</span>(x), <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb88-31"><a href="#cb88-31" aria-hidden="true" tabindex="-1"></a>px <span class="op">=</span> np.exp(<span class="op">-</span><span class="fl">0.5</span> <span class="op">*</span> x<span class="op">**</span><span class="dv">2</span> <span class="op">/</span> sigma1<span class="op">**</span><span class="dv">2</span> <span class="op">-</span> <span class="fl">0.5</span> <span class="op">*</span> np.log(<span class="dv">2</span><span class="op">*</span>np.pi<span class="op">*</span>sigma1<span class="op">**</span><span class="dv">2</span>))</span>
<span id="cb88-32"><a href="#cb88-32" aria-hidden="true" tabindex="-1"></a>py <span class="op">=</span> np.exp(<span class="op">-</span><span class="fl">0.5</span> <span class="op">*</span> x<span class="op">**</span><span class="dv">2</span> <span class="op">/</span> sigma2<span class="op">**</span><span class="dv">2</span> <span class="op">-</span> <span class="fl">0.5</span> <span class="op">*</span> np.log(<span class="dv">2</span><span class="op">*</span>np.pi<span class="op">*</span>sigma2<span class="op">**</span><span class="dv">2</span>))</span>
<span id="cb88-33"><a href="#cb88-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-34"><a href="#cb88-34" aria-hidden="true" tabindex="-1"></a>kw_panel <span class="op">=</span> <span class="bu">dict</span>(xlim<span class="op">=</span>limits)</span>
<span id="cb88-35"><a href="#cb88-35" aria-hidden="true" tabindex="-1"></a>kw_scatter <span class="op">=</span> <span class="bu">dict</span>(alpha<span class="op">=</span><span class="fl">0.1</span>, s<span class="op">=</span><span class="dv">10</span>, color<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb88-36"><a href="#cb88-36" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">9</span>, <span class="dv">6</span>), subplot_kw<span class="op">=</span>kw_panel)</span>
<span id="cb88-37"><a href="#cb88-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-38"><a href="#cb88-38" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ax, samples <span class="kw">in</span> <span class="bu">zip</span>(axes[:,<span class="dv">0</span>], [hmc_samples, metro_samples]):</span>
<span id="cb88-39"><a href="#cb88-39" aria-hidden="true" tabindex="-1"></a>    ax.scatter(<span class="op">*</span>samples.T, <span class="op">**</span>kw_scatter)</span>
<span id="cb88-40"><a href="#cb88-40" aria-hidden="true" tabindex="-1"></a>    ax.contour(x, x, prob, <span class="dv">5</span>)</span>
<span id="cb88-41"><a href="#cb88-41" aria-hidden="true" tabindex="-1"></a>    ax.set_ylim(<span class="op">*</span>limits)</span>
<span id="cb88-42"><a href="#cb88-42" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ax, samples <span class="kw">in</span> <span class="bu">zip</span>(axes[:,<span class="dv">1</span>], [hmc_samples, metro_samples]):</span>
<span id="cb88-43"><a href="#cb88-43" aria-hidden="true" tabindex="-1"></a>    ax.hist(samples[burnin:,<span class="dv">0</span>], bins<span class="op">=</span><span class="dv">21</span>, density<span class="op">=</span><span class="va">True</span>, color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.2</span>)</span>
<span id="cb88-44"><a href="#cb88-44" aria-hidden="true" tabindex="-1"></a>    ax.plot(x, px, color<span class="op">=</span><span class="st">'r'</span>, lw<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb88-45"><a href="#cb88-45" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ax, samples <span class="kw">in</span> <span class="bu">zip</span>(axes[:,<span class="dv">2</span>], [hmc_samples, metro_samples]):</span>
<span id="cb88-46"><a href="#cb88-46" aria-hidden="true" tabindex="-1"></a>    ax.hist(samples[burnin:,<span class="dv">1</span>], bins<span class="op">=</span><span class="dv">30</span>, density<span class="op">=</span><span class="va">True</span>, color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.2</span>)</span>
<span id="cb88-47"><a href="#cb88-47" aria-hidden="true" tabindex="-1"></a>    ax.plot(x, py, color<span class="op">=</span><span class="st">'r'</span>, lw<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb88-48"><a href="#cb88-48" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>acceptance_rate: 90.30% (HMC), 63.47% (Metropolis)</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-72-output-2.png" width="837" height="550"></p>
</div>
</div>
<div class="cell" data-execution_count="72">
<div class="sourceCode cell-code" id="cb90"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a>methods <span class="op">=</span> (<span class="st">'HMC'</span>, <span class="st">'Metropolis'</span>)</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">4</span>))</span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> samples, method <span class="kw">in</span> <span class="bu">zip</span>([hmc_samples, metro_samples], methods):</span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a>    ax.plot(samples[burnin:,<span class="dv">0</span>], label<span class="op">=</span>method, alpha<span class="op">=</span><span class="fl">0.5</span>, </span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a>           color<span class="op">=</span>{<span class="st">'HMC'</span>: <span class="st">'k'</span>, <span class="st">'Metropolis'</span>: <span class="st">'r'</span>}[method])</span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="vs">r'iteration $s$'</span>)</span>
<span id="cb90-7"><a href="#cb90-7" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="vs">r'first coordinate $x_1^{(s)}$'</span>)</span>
<span id="cb90-8"><a href="#cb90-8" aria-hidden="true" tabindex="-1"></a>ax.legend()<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-73-output-1.png" width="987" height="372"></p>
</div>
</div>
<p>Behavior in high-dimensional sample spaces (another example from Radford Neal):</p>
<div class="cell" data-execution_count="73">
<div class="sourceCode cell-code" id="cb91"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="co">"""HMC in high dimensions: example from Radford Neal's HMC review</span></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a><span class="co">"""</span></span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> RandomStepsize:</span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Randomized stepsize mixin. </span></span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb91-6"><a href="#cb91-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, lower, upper):</span>
<span id="cb91-7"><a href="#cb91-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.lower <span class="op">=</span> <span class="bu">float</span>(lower)</span>
<span id="cb91-8"><a href="#cb91-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.upper <span class="op">=</span> <span class="bu">float</span>(upper)</span>
<span id="cb91-9"><a href="#cb91-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._value <span class="op">=</span> <span class="va">None</span></span>
<span id="cb91-10"><a href="#cb91-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">assert</span> <span class="va">self</span>.lower <span class="op">&lt;=</span> <span class="va">self</span>.upper</span>
<span id="cb91-11"><a href="#cb91-11" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb91-12"><a href="#cb91-12" aria-hidden="true" tabindex="-1"></a>    <span class="at">@property</span></span>
<span id="cb91-13"><a href="#cb91-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> stepsize(<span class="va">self</span>):</span>
<span id="cb91-14"><a href="#cb91-14" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._value <span class="op">=</span> np.random.uniform(<span class="va">self</span>.lower, <span class="va">self</span>.upper)</span>
<span id="cb91-15"><a href="#cb91-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>._value</span>
<span id="cb91-16"><a href="#cb91-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb91-17"><a href="#cb91-17" aria-hidden="true" tabindex="-1"></a>    <span class="at">@stepsize.setter</span></span>
<span id="cb91-18"><a href="#cb91-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> stepsize(<span class="va">self</span>, value):</span>
<span id="cb91-19"><a href="#cb91-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">pass</span></span>
<span id="cb91-20"><a href="#cb91-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-21"><a href="#cb91-21" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> MetropolisWithRandomStepsize(Metropolis, RandomStepsize):</span>
<span id="cb91-22"><a href="#cb91-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, model, initial, n_samples, lower, upper):</span>
<span id="cb91-23"><a href="#cb91-23" aria-hidden="true" tabindex="-1"></a>        Metropolis.<span class="fu">__init__</span>(<span class="va">self</span>, model, initial, n_samples, lower)</span>
<span id="cb91-24"><a href="#cb91-24" aria-hidden="true" tabindex="-1"></a>        RandomStepsize.<span class="fu">__init__</span>(<span class="va">self</span>, lower, upper)</span>
<span id="cb91-25"><a href="#cb91-25" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb91-26"><a href="#cb91-26" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> HMCWithRandomStepsize(HamiltonianMonteCarlo, RandomStepsize):</span>
<span id="cb91-27"><a href="#cb91-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, model, initial, n_samples, lower, upper, n_leapfrog):</span>
<span id="cb91-28"><a href="#cb91-28" aria-hidden="true" tabindex="-1"></a>        HamiltonianMonteCarlo.<span class="fu">__init__</span>(</span>
<span id="cb91-29"><a href="#cb91-29" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>, model, initial, n_samples, lower, n_leapfrog</span>
<span id="cb91-30"><a href="#cb91-30" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb91-31"><a href="#cb91-31" aria-hidden="true" tabindex="-1"></a>        RandomStepsize.<span class="fu">__init__</span>(<span class="va">self</span>, lower, upper)</span>
<span id="cb91-32"><a href="#cb91-32" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb91-33"><a href="#cb91-33" aria-hidden="true" tabindex="-1"></a>ndim <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb91-34"><a href="#cb91-34" aria-hidden="true" tabindex="-1"></a>sigma <span class="op">=</span> np.linspace(<span class="fl">0.01</span>, <span class="fl">1.</span>, ndim)</span>
<span id="cb91-35"><a href="#cb91-35" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> CoupledOscillator(np.diag(<span class="dv">1</span><span class="op">/</span>sigma<span class="op">**</span><span class="dv">2</span>))</span>
<span id="cb91-36"><a href="#cb91-36" aria-hidden="true" tabindex="-1"></a>initial <span class="op">=</span> np.zeros(ndim)</span>
<span id="cb91-37"><a href="#cb91-37" aria-hidden="true" tabindex="-1"></a>n_samples <span class="op">=</span> <span class="dv">2000</span></span>
<span id="cb91-38"><a href="#cb91-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-39"><a href="#cb91-39" aria-hidden="true" tabindex="-1"></a><span class="co"># hmc</span></span>
<span id="cb91-40"><a href="#cb91-40" aria-hidden="true" tabindex="-1"></a>n_leapfrog <span class="op">=</span> <span class="dv">150</span></span>
<span id="cb91-41"><a href="#cb91-41" aria-hidden="true" tabindex="-1"></a>hmc <span class="op">=</span> HMCWithRandomStepsize(</span>
<span id="cb91-42"><a href="#cb91-42" aria-hidden="true" tabindex="-1"></a>        model, initial, n_samples, <span class="fl">0.0104</span>, <span class="fl">0.0156</span>, n_leapfrog)</span>
<span id="cb91-43"><a href="#cb91-43" aria-hidden="true" tabindex="-1"></a>samples_hmc <span class="op">=</span> np.array(<span class="bu">list</span>(hmc))</span>
<span id="cb91-44"><a href="#cb91-44" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(hmc.acceptance_rate)</span>
<span id="cb91-45"><a href="#cb91-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-46"><a href="#cb91-46" aria-hidden="true" tabindex="-1"></a><span class="co"># metropolis</span></span>
<span id="cb91-47"><a href="#cb91-47" aria-hidden="true" tabindex="-1"></a>metro <span class="op">=</span> MetropolisWithRandomStepsize(</span>
<span id="cb91-48"><a href="#cb91-48" aria-hidden="true" tabindex="-1"></a>        model, initial, n_samples <span class="op">*</span> n_leapfrog, <span class="fl">0.0176</span>, <span class="fl">0.0264</span>)</span>
<span id="cb91-49"><a href="#cb91-49" aria-hidden="true" tabindex="-1"></a>samples_metro <span class="op">=</span> np.array(<span class="bu">list</span>(metro))[::n_leapfrog]</span>
<span id="cb91-50"><a href="#cb91-50" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(metro.acceptance_rate)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>0.869</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>0.24941333333333332</code></pre>
</div>
</div>
<div class="cell" data-execution_count="74">
<div class="sourceCode cell-code" id="cb94"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a>burnin <span class="op">=</span> <span class="bu">int</span>(n_samples<span class="op">/</span><span class="dv">10</span>)</span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a><span class="co"># plotting</span></span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">9</span>, <span class="dv">9</span>), sharey<span class="op">=</span><span class="st">'row'</span>, sharex<span class="op">=</span><span class="st">'col'</span>)</span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ax, samples <span class="kw">in</span> <span class="bu">zip</span>(axes[<span class="dv">0</span>,:], [samples_metro, samples_hmc]):</span>
<span id="cb94-6"><a href="#cb94-6" aria-hidden="true" tabindex="-1"></a>    ax.scatter(samples[burnin:].std(<span class="dv">0</span>), samples[burnin:].mean(<span class="dv">0</span>))</span>
<span id="cb94-7"><a href="#cb94-7" aria-hidden="true" tabindex="-1"></a>    ax.axhline(<span class="fl">0.</span>, ls<span class="op">=</span><span class="st">'--'</span>, color<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb94-8"><a href="#cb94-8" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>,<span class="dv">0</span>].set_ylim(<span class="op">-</span><span class="fl">0.7</span>, <span class="fl">0.7</span>)</span>
<span id="cb94-9"><a href="#cb94-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ax, samples <span class="kw">in</span> <span class="bu">zip</span>(axes[<span class="dv">1</span>,:], [samples_metro, samples_hmc]):</span>
<span id="cb94-10"><a href="#cb94-10" aria-hidden="true" tabindex="-1"></a>    ax.plot([<span class="fl">0.</span>, <span class="fl">1.</span>], [<span class="fl">0.</span>, <span class="fl">1.</span>], ls<span class="op">=</span><span class="st">'--'</span>, color<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb94-11"><a href="#cb94-11" aria-hidden="true" tabindex="-1"></a>    ax.scatter(samples[burnin:].std(<span class="dv">0</span>), sigma)</span>
<span id="cb94-12"><a href="#cb94-12" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>,<span class="dv">0</span>].set_title(<span class="st">'Random walk Metropolis'</span>)</span>
<span id="cb94-13"><a href="#cb94-13" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>,<span class="dv">1</span>].set_title(<span class="st">'Hamiltonian Monte Carlo'</span>)</span>
<span id="cb94-14"><a href="#cb94-14" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>,<span class="dv">0</span>].set_ylabel(<span class="vs">r'sample mean $\{x_i^{(s)}\}$'</span>)</span>
<span id="cb94-15"><a href="#cb94-15" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>,<span class="dv">0</span>].set_xlabel(<span class="vs">r'sample variance $\{x_i^{(s)}\}$'</span>)</span>
<span id="cb94-16"><a href="#cb94-16" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>,<span class="dv">1</span>].set_xlabel(<span class="vs">r'sample variance $\{x_i^{(s)}\}$'</span>)</span>
<span id="cb94-17"><a href="#cb94-17" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>,<span class="dv">0</span>].set_ylabel(<span class="vs">r'$\sigma_i$'</span>)</span>
<span id="cb94-18"><a href="#cb94-18" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-75-output-1.png" width="834" height="834"></p>
</div>
</div>
<p>A practical issue in applications of HMC is that the algorithm requires the gradient of minus log <span class="math inline">\(p(x)\)</span>. For some models it is far from straightforward to implement the gradient. Moreover, the gradient evaluations are on top of the evaluations of <span class="math inline">\(\log p(x)\)</span>, which are typical for MCMC approaches based on Metropolis-Hastings. Some remedy is provided by the possibility to use <a href="https://en.wikipedia.org/wiki/Automatic_differentiation"><em>automatic differentiation</em></a> to compute the gradient without implementing it explicitly. This strategy is used, for example, in the <a href="https://en.wikipedia.org/wiki/Stan_(software)">STAN</a> software for statistical inference or in probabilistic programming packages such as <a href="https://www.tensorflow.org/probability">tensorflow probability</a>, <a href="https://docs.pymc.io/">PyMC 3</a>, or <a href="https://pyro.ai/">pyro</a>.</p>
<p>Another issue of practical importance is the question how to choose the algorithmic parameters, i.e.&nbsp;the number of integration steps <span class="math inline">\(T\)</span> and the step size <span class="math inline">\(\epsilon\)</span>. Some attempts to choose these parameters automatically has been proposed and implemented in the <a href="https://arxiv.org/abs/1111.4246">NUTS</a> algorithm.</p>
<p>A special case of HMC is <a href="https://en.wikipedia.org/wiki/Stochastic_gradient_Langevin_dynamics">Langevin dynamics</a> which omits the acceptance/rejection step altogether and has gained some popularity in Bayesian deep learning when combined with stochastic gradient methods.</p>
</section>
</section>
<section id="practical-issues" class="level2">
<h2 class="anchored" data-anchor-id="practical-issues">Practical Issues</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<figure class="figure">
<img src="images/Murray_Thesis_Fig2-1.png" title="Challenges" class="img-fluid figure-img">
</figure>
<p></p><figcaption class="figure-caption">Challenges in MCMC</figcaption><p></p>
</figure>
</div>
<p>Figure from <a href="http://homepages.inf.ed.ac.uk/imurray2/pub/07thesis/murray_thesis_2007.pdf">Iain Murray: Advances in Markov chain Monte Carlo methods</a></p>
<section id="challenges" class="level3">
<h3 class="anchored" data-anchor-id="challenges">Challenges</h3>
<ul>
<li><p><strong>Local exploration</strong>: MCMC samplers typically employ a proposal kernel that changes the current state only locally. The magnitude of changes in the variables is controlled by the <em>step size</em> or a similar algorithmic parameter. The step size is limited by the need to maintain a reasonable acceptance rate. The time it takes for a diffusive random walk to explore a distance scales with <span class="math display">\[
(\text{distance} / \text{step size})^2  
\]</span></p></li>
<li><p><strong>Convergence</strong>: Typically, the chain starts from a highly improbable state, far away from any mode (local peak in the probability density function). To find a nearby mode, takes some time, again scaling unfavorably with dimension. But even if a mode has been found, it is not guaranteed that the Markov chain will find other modes in a reasonable amount of simulation time. These other modes could be more important in the sense that they carry more probability mass; so missing out on these modes can result in highly biased approximations.</p></li>
<li><p><strong>Mixing</strong>: To find all relevant modes, is one of the greatest challenges when sampling high-dimensional probabilistic models with multiple peaks (which is the rule rather than the exception). There are many reasons for having to deal with multi-modal distributions. A common reason are symmetries such as invariance under permutation of labels resulting in the <a href="https://link.springer.com/chapter/10.1007/978-3-662-01131-7_26">label-switching problem</a> in Gaussian mixture modeling. None of the methods that we discussed so far are particularly suited to explore multi-modal probability distributions. A common approach is to use <em>tempering</em> to flatten the probability such that the Markov chain can explore sample space more freely, and simulate a chain of tempered distributions, either sequentially (e.g.&nbsp;in <a href="https://link.springer.com/article/10.1023/A:1008923215028"><em>Annealed importance sampling</em> (AIS)</a>) or in parallel (e.g.&nbsp;in <a href="https://en.wikipedia.org/wiki/Parallel_tempering"><em>Parallel tempering</em></a>). Unfortunately, there is not enough time to discuss these important methods.</p></li>
<li><p><strong>Balancing density and volume</strong>: Another important issue is to not only find all relevant modes, but also visit them in due proportion. A probability peak might be very pronounced, but only carry a small amount of probability mass. If the Markov chain is stuck in this mode, samples coming from that mode will be overrepresented.</p></li>
</ul>
<p>Let’s illustrate some of these problems for a discrete toy system.</p>
<div class="cell" data-execution_count="75">
<div class="sourceCode cell-code" id="cb95"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.special <span class="im">import</span> logsumexp</span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a><span class="co">"""</span></span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a><span class="co">Discretized bimodal target used to study convergence. </span></span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a><span class="co">"""</span></span>
<span id="cb95-5"><a href="#cb95-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-6"><a href="#cb95-6" aria-hidden="true" tabindex="-1"></a>SEED <span class="op">=</span> [</span>
<span id="cb95-7"><a href="#cb95-7" aria-hidden="true" tabindex="-1"></a>        <span class="co"># produces bimodal distribution biased towards first mode</span></span>
<span id="cb95-8"><a href="#cb95-8" aria-hidden="true" tabindex="-1"></a>        <span class="dv">41</span>,</span>
<span id="cb95-9"><a href="#cb95-9" aria-hidden="true" tabindex="-1"></a>        <span class="co"># produces bimodal distribution biased towards second mode</span></span>
<span id="cb95-10"><a href="#cb95-10" aria-hidden="true" tabindex="-1"></a>        <span class="dv">1234</span>,</span>
<span id="cb95-11"><a href="#cb95-11" aria-hidden="true" tabindex="-1"></a>        <span class="co"># produces unimodal sample distribution</span></span>
<span id="cb95-12"><a href="#cb95-12" aria-hidden="true" tabindex="-1"></a>        <span class="dv">43</span>,   </span>
<span id="cb95-13"><a href="#cb95-13" aria-hidden="true" tabindex="-1"></a>        ][<span class="dv">1</span>]</span>
<span id="cb95-14"><a href="#cb95-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-15"><a href="#cb95-15" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BimodalMixture:</span>
<span id="cb95-16"><a href="#cb95-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-17"><a href="#cb95-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>,</span>
<span id="cb95-18"><a href="#cb95-18" aria-hidden="true" tabindex="-1"></a>                 centers<span class="op">=</span>np.array([<span class="fl">0.</span>, <span class="fl">1.</span>]),</span>
<span id="cb95-19"><a href="#cb95-19" aria-hidden="true" tabindex="-1"></a>                 widths<span class="op">=</span>np.array([<span class="fl">1.</span>, <span class="fl">1.</span>]),</span>
<span id="cb95-20"><a href="#cb95-20" aria-hidden="true" tabindex="-1"></a>                 weight<span class="op">=</span><span class="fl">0.5</span>):</span>
<span id="cb95-21"><a href="#cb95-21" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.centers <span class="op">=</span> np.array(centers)</span>
<span id="cb95-22"><a href="#cb95-22" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.widths <span class="op">=</span> np.array(widths)</span>
<span id="cb95-23"><a href="#cb95-23" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.weight <span class="op">=</span> <span class="bu">float</span>(weight)</span>
<span id="cb95-24"><a href="#cb95-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-25"><a href="#cb95-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> log_prob(<span class="va">self</span>, x):</span>
<span id="cb95-26"><a href="#cb95-26" aria-hidden="true" tabindex="-1"></a>        dist <span class="op">=</span> np.subtract.outer(x, <span class="va">self</span>.centers)</span>
<span id="cb95-27"><a href="#cb95-27" aria-hidden="true" tabindex="-1"></a>        logp <span class="op">=</span> <span class="op">-</span><span class="fl">0.5</span> <span class="op">*</span> dist<span class="op">**</span><span class="dv">2</span> <span class="op">/</span> <span class="va">self</span>.widths<span class="op">**</span><span class="dv">2</span> <span class="op">\</span></span>
<span id="cb95-28"><a href="#cb95-28" aria-hidden="true" tabindex="-1"></a>          <span class="op">-</span> <span class="fl">0.5</span> <span class="op">*</span> np.log(<span class="dv">2</span><span class="op">*</span>np.pi<span class="op">*</span><span class="va">self</span>.widths<span class="op">**</span><span class="dv">2</span>) <span class="op">\</span></span>
<span id="cb95-29"><a href="#cb95-29" aria-hidden="true" tabindex="-1"></a>          <span class="op">+</span> np.log(<span class="va">self</span>.weight) <span class="op">+</span> np.log(<span class="dv">1</span><span class="op">-</span><span class="va">self</span>.weight)</span>
<span id="cb95-30"><a href="#cb95-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> logsumexp(logp, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb95-31"><a href="#cb95-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-32"><a href="#cb95-32" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> make_proposal(n_neighbors, n_states):</span>
<span id="cb95-33"><a href="#cb95-33" aria-hidden="true" tabindex="-1"></a>    Q <span class="op">=</span> np.<span class="bu">sum</span>([np.eye(n_states, k<span class="op">=</span>k) <span class="cf">for</span> k </span>
<span id="cb95-34"><a href="#cb95-34" aria-hidden="true" tabindex="-1"></a>                <span class="kw">in</span> <span class="bu">range</span>(<span class="op">-</span>n_neighbors, n_neighbors<span class="op">+</span><span class="dv">1</span>)], <span class="dv">0</span>)</span>
<span id="cb95-35"><a href="#cb95-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> Q <span class="op">/</span> Q.<span class="bu">sum</span>(<span class="dv">1</span>)</span>
<span id="cb95-36"><a href="#cb95-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-37"><a href="#cb95-37" aria-hidden="true" tabindex="-1"></a><span class="co"># setting bimodal toy system</span></span>
<span id="cb95-38"><a href="#cb95-38" aria-hidden="true" tabindex="-1"></a>centers <span class="op">=</span> np.array([<span class="op">-</span><span class="fl">1.</span>, <span class="fl">1.</span>]) <span class="op">*</span> <span class="dv">4</span></span>
<span id="cb95-39"><a href="#cb95-39" aria-hidden="true" tabindex="-1"></a>widths <span class="op">=</span> np.array([<span class="fl">0.2</span>, <span class="fl">2.</span>])</span>
<span id="cb95-40"><a href="#cb95-40" aria-hidden="true" tabindex="-1"></a>weight <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb95-41"><a href="#cb95-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-42"><a href="#cb95-42" aria-hidden="true" tabindex="-1"></a>prob <span class="op">=</span> BimodalMixture(centers, widths, weight)</span>
<span id="cb95-43"><a href="#cb95-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-44"><a href="#cb95-44" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">100</span>            <span class="co"># number of states</span></span>
<span id="cb95-45"><a href="#cb95-45" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> np.arange(n)   <span class="co"># sample space</span></span>
<span id="cb95-46"><a href="#cb95-46" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> np.exp(prob.log_prob(np.linspace(<span class="op">-</span><span class="fl">7.</span>, <span class="fl">10.</span>, n)))</span>
<span id="cb95-47"><a href="#cb95-47" aria-hidden="true" tabindex="-1"></a>p <span class="op">/=</span> p.<span class="bu">sum</span>()       <span class="co"># discretized probability density</span></span>
<span id="cb95-48"><a href="#cb95-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-49"><a href="#cb95-49" aria-hidden="true" tabindex="-1"></a><span class="co"># use local proposal chain</span></span>
<span id="cb95-50"><a href="#cb95-50" aria-hidden="true" tabindex="-1"></a>stepsize <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb95-51"><a href="#cb95-51" aria-hidden="true" tabindex="-1"></a>n_samples <span class="op">=</span> <span class="fl">1e4</span></span>
<span id="cb95-52"><a href="#cb95-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-53"><a href="#cb95-53" aria-hidden="true" tabindex="-1"></a><span class="co"># random walk with uniform proposal and reflective boundary</span></span>
<span id="cb95-54"><a href="#cb95-54" aria-hidden="true" tabindex="-1"></a>Q <span class="op">=</span> make_proposal(stepsize, n) </span>
<span id="cb95-55"><a href="#cb95-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-56"><a href="#cb95-56" aria-hidden="true" tabindex="-1"></a><span class="co"># run Metropolis-Hastings</span></span>
<span id="cb95-57"><a href="#cb95-57" aria-hidden="true" tabindex="-1"></a>np.random.seed(SEED) </span>
<span id="cb95-58"><a href="#cb95-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-59"><a href="#cb95-59" aria-hidden="true" tabindex="-1"></a>n_accepted <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb95-60"><a href="#cb95-60" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> X[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb95-61"><a href="#cb95-61" aria-hidden="true" tabindex="-1"></a>samples <span class="op">=</span> [x]</span>
<span id="cb95-62"><a href="#cb95-62" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="bu">len</span>(samples) <span class="op">&lt;</span> n_samples:</span>
<span id="cb95-63"><a href="#cb95-63" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> np.random.choice(X, p<span class="op">=</span>Q[:,x])</span>
<span id="cb95-64"><a href="#cb95-64" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> Q[x,y] <span class="op">*</span> p[y] <span class="op">/</span> (Q[y, x] <span class="op">*</span> p[x])</span>
<span id="cb95-65"><a href="#cb95-65" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> r <span class="op">&gt;</span> np.random.random():</span>
<span id="cb95-66"><a href="#cb95-66" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> y</span>
<span id="cb95-67"><a href="#cb95-67" aria-hidden="true" tabindex="-1"></a>        n_accepted <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb95-68"><a href="#cb95-68" aria-hidden="true" tabindex="-1"></a>    samples.append(x)</span>
<span id="cb95-69"><a href="#cb95-69" aria-hidden="true" tabindex="-1"></a>samples <span class="op">=</span> np.array(samples)</span>
<span id="cb95-70"><a href="#cb95-70" aria-hidden="true" tabindex="-1"></a>logp <span class="op">=</span> np.log(p[samples])</span>
<span id="cb95-71"><a href="#cb95-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-72"><a href="#cb95-72" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'acceptance rate: </span><span class="sc">{0:.1%}</span><span class="st">'</span>.<span class="bu">format</span>(n_accepted<span class="op">/</span>n_samples))</span>
<span id="cb95-73"><a href="#cb95-73" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'</span><span class="sc">{0:.1%}</span><span class="st"> of all samples are in left mode'</span>.<span class="bu">format</span>(</span>
<span id="cb95-74"><a href="#cb95-74" aria-hidden="true" tabindex="-1"></a>    np.mean(samples<span class="op">&lt;</span><span class="dv">25</span>)))</span>
<span id="cb95-75"><a href="#cb95-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-76"><a href="#cb95-76" aria-hidden="true" tabindex="-1"></a><span class="co"># plot results</span></span>
<span id="cb95-77"><a href="#cb95-77" aria-hidden="true" tabindex="-1"></a>plt.rc(<span class="st">'font'</span>, size<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb95-78"><a href="#cb95-78" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">5</span>))</span>
<span id="cb95-79"><a href="#cb95-79" aria-hidden="true" tabindex="-1"></a>ax.plot(X, p, color<span class="op">=</span><span class="st">'r'</span>, lw<span class="op">=</span><span class="dv">2</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb95-80"><a href="#cb95-80" aria-hidden="true" tabindex="-1"></a>ax.hist(samples, bins<span class="op">=</span><span class="dv">40</span>, density<span class="op">=</span><span class="va">True</span>, color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.2</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>acceptance rate: 78.0%
22.6% of all samples are in left mode</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-76-output-2.png" width="814" height="417"></p>
</div>
</div>
<div class="cell" data-execution_count="76">
<div class="sourceCode cell-code" id="cb97"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">5</span>))</span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a>ax.axhline(np.log(p).<span class="bu">max</span>(), color<span class="op">=</span><span class="st">'r'</span>, lw<span class="op">=</span><span class="dv">3</span>, ls<span class="op">=</span><span class="st">'--'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>,</span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a>              label<span class="op">=</span><span class="vs">r'$\max\{\log</span><span class="sc">{p}</span><span class="vs">\}$'</span>)</span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a>ax.plot(logp, color<span class="op">=</span><span class="st">'k'</span>, lw<span class="op">=</span><span class="dv">3</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, label<span class="op">=</span><span class="vs">r'$\log p(x^{(s)}))$'</span>)</span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true" tabindex="-1"></a>ax.legend()</span>
<span id="cb97-6"><a href="#cb97-6" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-77-output-1.png" width="939" height="458"></p>
</div>
</div>
</section>
<section id="convergence" class="level3">
<h3 class="anchored" data-anchor-id="convergence">Convergence</h3>
<section id="convergence-rates-for-markov-chains" class="level4">
<h4 class="anchored" data-anchor-id="convergence-rates-for-markov-chains">Convergence rates for Markov chains</h4>
<p>The speed of convergence of a Markov chain <span class="math inline">\(P\)</span> with stationary distribution <span class="math inline">\(\pi\)</span> depends on how quickly contributions to the distance</p>
<p><span id="eq-distance"><span class="math display">\[
\left|p^{(S)} - \pi\right|
\tag{79}\]</span></span></p>
<p>die out as <span class="math inline">\(S\to\infty\)</span>. Distance (<a href="#eq-distance">Equation&nbsp;79</a>) is dominated by the second largest eigenvalue <span class="math inline">\(\lambda_2\)</span> of <span class="math inline">\(P\)</span>. Since the Markov chain is assumed to be irreducible and aperiodic, we have strictly <span class="math inline">\(|\lambda_2| &lt; 1\)</span>. If <span class="math inline">\(u_2, u_3, \ldots\)</span> are the eigenvectors of <span class="math inline">\(P\)</span> with eigenvalues <span class="math inline">\(1 &gt; |\lambda_2| \ge |\lambda_3| &gt;\ldots\)</span>, then we can write the initial distribution as <span class="math display">\[
p^{(0)} = \pi + a_2 u_2 + a_3 u_3 + \ldots
\]</span> After <span class="math inline">\(S\)</span> transitions, the initial <span class="math inline">\(p^{(0)}\)</span> will be propagated to <span class="math display">\[
p^{(S)} = \pi + a_2 \lambda_2^S u_2 + a_3 \lambda_3^S u_3 + \ldots
\]</span> and therefore <span class="math display">\[
\left|p^{(S)} - \pi\right| \sim |\lambda_2|^S
\]</span></p>
<p>The convergence rate depends on the step size, which calls for ways to <em>tune</em> algorithmic parameters of MCMC methods:</p>
<div class="cell" data-execution_count="77">
<div class="sourceCode cell-code" id="cb98"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> metropolis_map(Q, p):</span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Construct Metropolis kernel from proposal kernel and target distribution</span></span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb98-5"><a href="#cb98-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># M = np.clip(Q, 0., (Q * p).T / p)</span></span>
<span id="cb98-6"><a href="#cb98-6" aria-hidden="true" tabindex="-1"></a>    M <span class="op">=</span> np.<span class="bu">min</span>([Q, (Q <span class="op">*</span> p).T <span class="op">/</span> p], axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb98-7"><a href="#cb98-7" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> np.arange(<span class="bu">len</span>(M))</span>
<span id="cb98-8"><a href="#cb98-8" aria-hidden="true" tabindex="-1"></a>    M[i,i] <span class="op">=</span> <span class="fl">0.</span></span>
<span id="cb98-9"><a href="#cb98-9" aria-hidden="true" tabindex="-1"></a>    M[i,i] <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> M.<span class="bu">sum</span>(<span class="dv">0</span>)</span>
<span id="cb98-10"><a href="#cb98-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-11"><a href="#cb98-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> M</span>
<span id="cb98-12"><a href="#cb98-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-13"><a href="#cb98-13" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> second_eigval(M):</span>
<span id="cb98-14"><a href="#cb98-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.sort(np.<span class="bu">abs</span>(np.linalg.eigvals(M)))[::<span class="op">-</span><span class="dv">1</span>][<span class="dv">1</span>]    </span>
<span id="cb98-15"><a href="#cb98-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-16"><a href="#cb98-16" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> propagate(M, p0, n):</span>
<span id="cb98-17"><a href="#cb98-17" aria-hidden="true" tabindex="-1"></a>    P <span class="op">=</span> [p0.copy()]</span>
<span id="cb98-18"><a href="#cb98-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb98-19"><a href="#cb98-19" aria-hidden="true" tabindex="-1"></a>        P.append(M <span class="op">@</span> P[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb98-20"><a href="#cb98-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array(P)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="78">
<div class="sourceCode cell-code" id="cb99"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a>stepsizes <span class="op">=</span> (<span class="dv">5</span>, <span class="dv">10</span>, <span class="dv">15</span>, <span class="dv">20</span>)</span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a>distances <span class="op">=</span> []</span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a>rates <span class="op">=</span> []</span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true" tabindex="-1"></a>p0 <span class="op">=</span> np.eye(n)[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb99-6"><a href="#cb99-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> stepsize <span class="kw">in</span> stepsizes:</span>
<span id="cb99-7"><a href="#cb99-7" aria-hidden="true" tabindex="-1"></a>    Q <span class="op">=</span> make_proposal(stepsize, n)</span>
<span id="cb99-8"><a href="#cb99-8" aria-hidden="true" tabindex="-1"></a>    M <span class="op">=</span> metropolis_map(Q, p)</span>
<span id="cb99-9"><a href="#cb99-9" aria-hidden="true" tabindex="-1"></a>    P <span class="op">=</span> propagate(M, p0, <span class="dv">10000</span>)</span>
<span id="cb99-10"><a href="#cb99-10" aria-hidden="true" tabindex="-1"></a>    d <span class="op">=</span> np.fabs(P <span class="op">-</span> p).<span class="bu">sum</span>(<span class="dv">1</span>)</span>
<span id="cb99-11"><a href="#cb99-11" aria-hidden="true" tabindex="-1"></a>    distances.append(d)</span>
<span id="cb99-12"><a href="#cb99-12" aria-hidden="true" tabindex="-1"></a>    rates.append(<span class="op">-</span>np.log(second_eigval(M)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="79">
<div class="sourceCode cell-code" id="cb100"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> plt.rcParams[<span class="st">'axes.prop_cycle'</span>].by_key()[<span class="st">'color'</span>]</span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">10</span>,<span class="dv">5</span>))</span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(stepsizes)):</span>
<span id="cb100-4"><a href="#cb100-4" aria-hidden="true" tabindex="-1"></a>    ax.plot(distances[i], alpha<span class="op">=</span><span class="fl">0.3</span>, lw<span class="op">=</span><span class="dv">5</span>, </span>
<span id="cb100-5"><a href="#cb100-5" aria-hidden="true" tabindex="-1"></a>            label<span class="op">=</span><span class="st">'step size=</span><span class="sc">{0}</span><span class="st">'</span>.<span class="bu">format</span>(stepsizes[i]))</span>
<span id="cb100-6"><a href="#cb100-6" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.arange(<span class="dv">10000</span>)</span>
<span id="cb100-7"><a href="#cb100-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(stepsizes)):</span>
<span id="cb100-8"><a href="#cb100-8" aria-hidden="true" tabindex="-1"></a>    ax.plot(np.exp(<span class="op">-</span>rates[i]<span class="op">*</span>t), ls<span class="op">=</span><span class="st">'--'</span>, alpha<span class="op">=</span><span class="fl">0.9</span>, </span>
<span id="cb100-9"><a href="#cb100-9" aria-hidden="true" tabindex="-1"></a>            color<span class="op">=</span>colors[i], label<span class="op">=</span><span class="vs">r'$\exp\{-\lambda_2 s\}$'</span>)</span>
<span id="cb100-10"><a href="#cb100-10" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="vs">r'iteration $s$'</span>)</span>
<span id="cb100-11"><a href="#cb100-11" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="vs">r'$|\pi - p^{(s)}|$'</span>)</span>
<span id="cb100-12"><a href="#cb100-12" aria-hidden="true" tabindex="-1"></a>ax.legend()</span>
<span id="cb100-13"><a href="#cb100-13" aria-hidden="true" tabindex="-1"></a>ax.set_ylim(<span class="fl">0.</span>, <span class="fl">1.</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-80-output-1.png" width="831" height="448"></p>
</div>
</div>
<div class="cell" data-execution_count="80">
<div class="sourceCode cell-code" id="cb101"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a>stepsizes <span class="op">=</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">31</span>)</span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a>rates <span class="op">=</span> []</span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> stepsize <span class="kw">in</span> stepsizes:</span>
<span id="cb101-5"><a href="#cb101-5" aria-hidden="true" tabindex="-1"></a>    Q <span class="op">=</span> make_proposal(stepsize, n)</span>
<span id="cb101-6"><a href="#cb101-6" aria-hidden="true" tabindex="-1"></a>    M <span class="op">=</span> metropolis_map(Q, p)</span>
<span id="cb101-7"><a href="#cb101-7" aria-hidden="true" tabindex="-1"></a>    rates.append(<span class="op">-</span>np.log(second_eigval(M)))</span>
<span id="cb101-8"><a href="#cb101-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb101-9"><a href="#cb101-9" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">5</span>, <span class="dv">5</span>))</span>
<span id="cb101-10"><a href="#cb101-10" aria-hidden="true" tabindex="-1"></a>ax.scatter(stepsizes, rates, s<span class="op">=</span><span class="dv">200</span>, color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb101-11"><a href="#cb101-11" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="vs">r'-$\log|\lambda_2|$'</span>)</span>
<span id="cb101-12"><a href="#cb101-12" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">'stepsize'</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-81-output-1.png" width="480" height="440"></p>
</div>
</div>
</section>
</section>
<section id="burn-in-bias" class="level3">
<h3 class="anchored" data-anchor-id="burn-in-bias">Burn-in bias</h3>
<p>The MCMC chain does not start from the stationary distribution, so <span class="math display">\[
\mathbb E_{p^{(s)}}[f] \not= \mathbb E_p[f]\, ,
\]</span> and the difference can be substantial for small <span class="math inline">\(s\)</span>, thereby inducing significant bias to the Monte Carlo estimator:</p>
<p><span class="math display">\[
\frac{1}{S} \sum_{s=1}^S f\bigl(x^{(s)}\bigr).
\]</span></p>
<p>It is difficult to assess the reliability of MCMC approximations, because of the dependence of the samples <span class="math inline">\(x^{(s)}\)</span>. The dependence usually adds variance to the estimator, when compared against simple Monte Carlo averages.</p>
<p>To minimize biases stemming from a poor choice of the initial distribution <span class="math inline">\(p^{(0)}\)</span>, it is common practice to discard the first samples <span class="math inline">\(x^{(0)}, \ldots, x^{(B)}\)</span> called <em>burn-in</em>. It is assumed that <span class="math inline">\(x^{(B+1)}\)</span> will approximately follow the target distribution <span class="math inline">\(p\)</span>. The Monte Carlo approximation then becomes: <span id="eq-burnin"><span class="math display">\[
\frac{1}{S-B} \sum_{s=B+1}^S f\bigl(x^{(s)}\bigr)\, .
\tag{80}\]</span></span> Several statistics can be used to detect bias in MCMC simulations. However, they usually rely on rather strong assumptions, such as the asymptotic normality, or at least uni-modality of the target.</p>
</section>
<section id="auto-correlation-diagnostic" class="level3">
<h3 class="anchored" data-anchor-id="auto-correlation-diagnostic">Auto-correlation diagnostic</h3>
<p>The asymptotic variance of the MCMC estimator can be shown to converge against <span id="eq-variance"><span class="math display">\[
\text{var}\left[\frac{1}{S}\sum_s f\bigl(x^{(s)}\bigr) \right] \xrightarrow[S\to\infty]{} \frac{1}{S} \text{var}_p[f] (1 + 2 \sum_{s\ge 1} \rho_s)  
\tag{81}\]</span></span> where <span class="math inline">\(\rho_s\)</span> are the <em>correlations</em> between the initial samples and the <span class="math inline">\(s\)</span>-th samples <span id="eq-correlation"><span class="math display">\[
\rho_s = \text{corr}[f(x^{(0)}), f(x^{(s)})] \, .
\tag{82}\]</span></span> For uncorrelated samples <span class="math inline">\(\rho_s=0\)</span> and we are back to the standard variance of Monte Carlo estimators: <span class="math inline">\(\text{var}[f]/S\)</span>. However, due to correlations the variance can be increased significantly (in principle, the variance can approach infinity for perfectly correlated samples).</p>
<p>Another way to look at this is that correlations decrease the <em>effective sample size</em> (ESS), which becomes <span id="eq-ess"><span class="math display">\[
S_{\text{eff}} = \frac{S}{1 + 2 \sum_{s\ge 1} \rho_s} = \frac{S}{\text{IACT}}
\tag{83}\]</span></span> where <span class="math inline">\(\text{IACT} = 1 + 2 \sum_{s\ge 1} \rho_s\)</span> is the <em>integrated auto-correlation time</em>.</p>
<div class="cell" data-execution_count="81">
<div class="sourceCode cell-code" id="cb102"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="co"># autocorrelation analysis of bimodal target</span></span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> autocorrelation(x, n):</span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb102-5"><a href="#cb102-5" aria-hidden="true" tabindex="-1"></a><span class="co">    auto-correlation of a times series</span></span>
<span id="cb102-6"><a href="#cb102-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-7"><a href="#cb102-7" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters</span></span>
<span id="cb102-8"><a href="#cb102-8" aria-hidden="true" tabindex="-1"></a><span class="co">    ----------</span></span>
<span id="cb102-9"><a href="#cb102-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-10"><a href="#cb102-10" aria-hidden="true" tabindex="-1"></a><span class="co">    x: array containing time series</span></span>
<span id="cb102-11"><a href="#cb102-11" aria-hidden="true" tabindex="-1"></a><span class="co">    n: Integer specifying maximal lag for which to compute the auto-correlation</span></span>
<span id="cb102-12"><a href="#cb102-12" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb102-13"><a href="#cb102-13" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> x <span class="op">-</span> x.mean()</span>
<span id="cb102-14"><a href="#cb102-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array([np.mean(x[i:] <span class="op">*</span> x[:<span class="bu">len</span>(x) <span class="op">-</span> i]) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n)]) <span class="op">/</span> np.std(x)<span class="op">**</span><span class="dv">2</span></span>
<span id="cb102-15"><a href="#cb102-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-16"><a href="#cb102-16" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> run_metropolis(Q, p, X, n_samples<span class="op">=</span><span class="fl">1e4</span>):</span>
<span id="cb102-17"><a href="#cb102-17" aria-hidden="true" tabindex="-1"></a>    samples <span class="op">=</span> [X[<span class="op">-</span><span class="dv">1</span>]]</span>
<span id="cb102-18"><a href="#cb102-18" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> samples[<span class="dv">0</span>]</span>
<span id="cb102-19"><a href="#cb102-19" aria-hidden="true" tabindex="-1"></a>    n_acc <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb102-20"><a href="#cb102-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="bu">len</span>(samples) <span class="op">&lt;</span> n_samples:</span>
<span id="cb102-21"><a href="#cb102-21" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> np.random.choice(X, p<span class="op">=</span>Q[:,x])</span>
<span id="cb102-22"><a href="#cb102-22" aria-hidden="true" tabindex="-1"></a>        r <span class="op">=</span> Q[x,y] <span class="op">*</span> p[y] <span class="op">/</span> (Q[y, x] <span class="op">*</span> p[x])</span>
<span id="cb102-23"><a href="#cb102-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> r <span class="op">&gt;</span> np.random.random():</span>
<span id="cb102-24"><a href="#cb102-24" aria-hidden="true" tabindex="-1"></a>            x <span class="op">=</span> y</span>
<span id="cb102-25"><a href="#cb102-25" aria-hidden="true" tabindex="-1"></a>            n_acc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb102-26"><a href="#cb102-26" aria-hidden="true" tabindex="-1"></a>        samples.append(x)</span>
<span id="cb102-27"><a href="#cb102-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array(samples), n_acc</span>
<span id="cb102-28"><a href="#cb102-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-29"><a href="#cb102-29" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">41</span>) </span>
<span id="cb102-30"><a href="#cb102-30" aria-hidden="true" tabindex="-1"></a>stepsizes <span class="op">=</span> (<span class="dv">5</span>, <span class="dv">10</span>, <span class="dv">15</span>, <span class="dv">20</span>)</span>
<span id="cb102-31"><a href="#cb102-31" aria-hidden="true" tabindex="-1"></a>ac <span class="op">=</span> []</span>
<span id="cb102-32"><a href="#cb102-32" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> stepsize <span class="kw">in</span> stepsizes:</span>
<span id="cb102-33"><a href="#cb102-33" aria-hidden="true" tabindex="-1"></a>    Q <span class="op">=</span> make_proposal(stepsize, <span class="bu">len</span>(p))</span>
<span id="cb102-34"><a href="#cb102-34" aria-hidden="true" tabindex="-1"></a>    S, n_acc <span class="op">=</span> run_metropolis(Q, p, X, <span class="fl">2e4</span>)</span>
<span id="cb102-35"><a href="#cb102-35" aria-hidden="true" tabindex="-1"></a>    ac.append(autocorrelation(S<span class="op">*</span><span class="fl">1.</span>, <span class="dv">10000</span>))</span>
<span id="cb102-36"><a href="#cb102-36" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">'stepsize=</span><span class="sc">{0}</span><span class="st">: acceptance-rate=</span><span class="sc">{1:.1%}</span><span class="st">'</span>.<span class="bu">format</span>(</span>
<span id="cb102-37"><a href="#cb102-37" aria-hidden="true" tabindex="-1"></a>        stepsize, n_acc<span class="op">/</span><span class="bu">len</span>(S)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>stepsize=5: acceptance-rate=57.4%</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>stepsize=10: acceptance-rate=59.1%</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>stepsize=15: acceptance-rate=47.0%</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>stepsize=20: acceptance-rate=36.6%</code></pre>
</div>
</div>
<div class="cell" data-execution_count="82">
<div class="sourceCode cell-code" id="cb107"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">10</span>,<span class="dv">5</span>))</span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(stepsizes)):</span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a>    ax.plot(ac[i], alpha<span class="op">=</span><span class="fl">0.3</span>, lw<span class="op">=</span><span class="dv">5</span>, </span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true" tabindex="-1"></a>            label<span class="op">=</span><span class="st">'stepsize=</span><span class="sc">{0}</span><span class="st">'</span>.<span class="bu">format</span>(stepsizes[i]))</span>
<span id="cb107-5"><a href="#cb107-5" aria-hidden="true" tabindex="-1"></a>ax.axhline(<span class="dv">0</span>, ls<span class="op">=</span><span class="st">'--'</span>, color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb107-6"><a href="#cb107-6" aria-hidden="true" tabindex="-1"></a>ax.set_xlim(<span class="dv">0</span>, <span class="dv">4000</span>)</span>
<span id="cb107-7"><a href="#cb107-7" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="vs">r'iteration $s$'</span>)</span>
<span id="cb107-8"><a href="#cb107-8" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="vs">r'autocorrelation'</span>)</span>
<span id="cb107-9"><a href="#cb107-9" aria-hidden="true" tabindex="-1"></a>ax.legend()<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="lecture_files/figure-html/cell-83-output-1.png" width="866" height="440"></p>
</div>
</div>
</section>
<section id="practical-summary-from-viholas-lecture-notes" class="level3">
<h3 class="anchored" data-anchor-id="practical-summary-from-viholas-lecture-notes">Practical summary (from Vihola’s lecture notes)</h3>
<p>When using MCMC, always do the following checks:</p>
<ol type="1">
<li><p>Plot MCMC traces of the variables and key functions of the variables. They should look stationary after burn-in.</p></li>
<li><p>Make multiple MCMC runs from different initial states and check that the marginal distributions (or the estimators) look similar. This test reveals if your chain is “almost reducible”.</p></li>
<li><p>Plot sample autocorrelations of the variables and functions.</p></li>
<li><p>Calculate the effective sample size and check that it is reasonably large.</p></li>
</ol>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>